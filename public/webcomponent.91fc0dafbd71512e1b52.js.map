{"version":3,"sources":["webpack:///webcomponent.91fc0dafbd71512e1b52.js","webpack:///webpack/bootstrap 91fc0dafbd71512e1b52?e44c","webpack:///./~/webcomponents.js/webcomponents.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","window","WebComponents","flags","file","script","document","querySelector","noOpts","location","search","slice","split","forEach","option","match","parts","a","i","attributes","name","value","log","f","shadow","shadowdom","polyfill","HTMLElement","prototype","createShadowRoot","register","CustomElements","WeakMap","defineProperty","Object","counter","Date","now","this","Math","random","set","key","entry","writable","get","undefined","delete","has","ShadowDOMPolyfill","scope","detectEval","chrome","app","runtime","navigator","getDeviceStorage","Function","ex","assert","b","Error","mixin","to","from","names","getOwnPropertyNames","length","getOwnPropertyDescriptor","mixinStatics","oneOf","object","propertyNames","defineNonEnumerableDataProperty","nonEnumerableDataDescriptor","getWrapperConstructor","node","opt_instance","nativePrototype","__proto__","getPrototypeOf","isFirefox","error","wrapperConstructor","constructorTable","parentWrapperConstructor","GeneratedWrapper","createWrapperConstructor","registerInternal","addForwardingProperties","wrapperPrototype","installProperty","registerInstanceProperties","instanceObject","isEventHandlerName","test","isIdentifierName","getGetter","hasEval","__impl4cf1e782hg__","getSetter","v","getMethod","apply","arguments","getDescriptor","source","dummyDescriptor","target","allowMethod","opt_blacklist","polymerBlackList_","__lookupGetter__","getter","setter","descriptor","isEvent","getEventHandlerGetter","isBrokenSafari","getEventHandlerSetter","configurable","enumerable","nativeConstructor","nativePrototypeTable","isWrapperFor","registerObject","superWrapperConstructor","create","constructor","isWrapper","isNative","wrap","impl","wrapper","__wrapper8e3dd93a60__","unwrap","unsafeUnwrap","setWrapper","unwrapIfNeeded","wrapIfNeeded","rewrap","defineGetter","getterDescriptor","defineWrapGetter","forwardMethodsToWrapper","constructors","w","wrappers","userAgent","descr","Node","registerWrapper","newSplice","index","removed","addedCount","ArraySplice","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","calcEditDistances","current","currentStart","currentEnd","old","oldStart","oldEnd","rowCount","columnCount","distances","Array","j","equals","north","west","spliceOperationsFromEditDistances","edits","min","northWest","push","reverse","calcSplices","prefixCount","suffixCount","minLength","sharedPrefix","sharedSuffix","splice","ops","splices","oldIndex","searchLength","index1","index2","count","calculateSplices","previous","currentValue","previousValue","context","handle","pending","copies","callbacks","setEndOfMicrotask","func","timerFunc","OriginalMutationObserver","MutationObserver","observer","textNode","createTextNode","observe","characterData","data","setTimeout","scheduleCallback","scheduled_","globalMutationObservers","isScheduled","notifyObservers","notifyList","sort","x","y","uid_","mo","queue","takeRecords","removeTransientObserversFor","callback_","MutationRecord","type","addedNodes","NodeList","removedNodes","previousSibling","nextSibling","attributeName","attributeNamespace","oldValue","registerTransientObservers","ancestor","parentNode","registrations","registrationsTable","registration","options","subtree","addTransientObserver","nodes_","removeTransientObservers","enqueueMutation","interestedObservers","associatedStrings","attributeFilter","namespace","indexOf","childList","attributeOldValue","characterDataOldValue","uid","record","records_","MutationObserverOptions","TypeError","callback","uidCounter","Registration","transientObservedNodes","newOptions","disconnect","copyOfRecords","TreeScope","root","parent","setTreeScope","treeScope","treeScope_","sr","shadowRoot","olderShadowRoot","child","firstChild","getTreeScope","Window","renderer","ShadowRoot","getRendererForHost","host","contains","isShadowRoot","rootOfNode","getEventPath","event","path","destinationInsertionPoints","getDestinationInsertionPoints","insertionPoint","isShadowInsertionPoint","inSameTree","eventMustBeStopped","HTMLShadowElement","eventRetargetting","currentTarget","currentTargetTree","originalTarget","originalTargetTree","relativeTargetTree","lowestCommonInclusiveAncestor","getTreeScopeAncestors","ancestors","tsA","tsB","ancestorsA","ancestorsB","result","pop","relatedTargetResolution","relatedTarget","lowestCommonAncestorTree","relatedTargetTree","relatedTargetEventPath","commonAncestorTree","dispatchOriginalEvent","originalEvent","handledEventsTable","dispatchEvent","pendingError","err","isLoadLikeEvent","originalWrapperTarget","currentlyDispatchingEvents","renderAllPending","eventPath","overrideTarget","win","bubbles","doc","Document","defaultView","eventPathTable","dispatchCapturing","dispatchAtTarget","dispatchBubbling","eventPhaseTable","NONE","currentTargetTable","defaultPrevented","phase","CAPTURING_PHASE","invoke","AT_TARGET","BUBBLING_PHASE","listeners","listenersTable","unwrappedRelatedTarget","addEventListener","adjusted","relatedTargetTable","anyRemoved","targetTable","depth","len","listener","capture","handler","handleEvent","stopImmediatePropagationTable","copy","stopPropagationTable","Listener","Boolean","Event","OriginalEvent","constructEvent","OriginalBeforeUnloadEvent","BeforeUnloadEvent","unwrapOptions","registerGenericEvent","SuperEvent","GenericEvent","createEvent","getInitFunction","relatedTargetIndex","supportsEventConstructors","defaultDict","defaultInitDicts","args","keys","isValidListener","fun","isMutationEvent","EventTarget","getTargetToListenAt","hasListener","hasListenerInAncestors","wrapEventTargetMethods","methodNames","elementFromPoint","self","element","originalElementFromPoint","idx","lastIndexOf","inlineEventHandlers","eventHandlersTable","eventType","removeEventListener","wrapped","e","rv","preventDefault","returnValue","that","remove","keyLocation","eventPhase","stopPropagation","stopImmediatePropagation","supportsDefaultPrevented","initEvent","cancelable","UIEvent","CustomEvent","relatedTargetProto","mouseEventProto","initMouseEvent","focusEventProto","initFocusEvent","MouseEvent","FocusEvent","configureEventConstructor","initDict","superName","superDict","detail","view","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","OriginalEventTarget","addEventListener_","found","removeEventListener_","nativeEvent","tempListener","dispatchEvent_","nonEnum","obj","prop","nonEnumDescriptor","Touch","TouchList","wrapTouchList","nativeTouchList","list","TouchEvent","OriginalTouchEvent","item","touches","targetTouches","changedTouches","initTouchEvent","wrapNodeList","wrapperList","addWrapNodeListMethod","wrapHTMLCollection","HTMLCollection","assertIsNodeWrapper","createOneElementNodeList","nodes","enqueueRemovalForInsertedNodes","enqueueRemovalForInsertedDocumentFragment","df","collectNodes","previousNode","nextNode","DocumentFragment","collectNodesForDocumentFragment","surpressMutations","removeChild","parentNode_","previousSibling_","nextSibling_","oldParent","collectNodesNative","snapshotNodeList","nodeList","nodeWasAdded","nodeIsInserted_","nodesWereAdded","nodeWasRemoved","nodesWereRemoved","ensureSameOwnerDocument","ownerDoc","nodeType","DOCUMENT_NODE","ownerDocument","adoptNode","adoptNodesIfNeeded","owner","adoptNodeNoRemove","unwrapNodesForInsertion","createDocumentFragment","appendChild","clearChildNodes","firstChild_","tmp","lastChild_","removeAllChildNodes","invalidateShadowRenderer","childWrapper","childNode","originalRemoveChild","invalidateParent","cleanupNodes","n","cloneNode","deep","opt_doc","clone","originalImportNode","originalCloneNode","HTMLTemplateElement","cloneContent","content","original","OriginalNode","importNode","OriginalDocumentFragment","originalCompareDocumentPosition","compareDocumentPosition","originalIsEqualNode","isEqualNode","originalInsertBefore","insertBefore","originalReplaceChild","replaceChild","isIEOrEdge","removeChildOriginalHelper","refWrapper","refNode","lastChild","useNative","ieChild","childNodes","childWrapperNextSibling","childWrapperPreviousSibling","thisFirstChild","thisLastChild","newChildWrapper","oldChildWrapper","oldChildNode","hasChildNodes","parentElement","ELEMENT_NODE","textContent","s","COMMENT_NODE","otherNode","normalize","modNode","remNodes","TEXT_NODE","querySelectorAll","filterNodeList","wrappedItem","shimSelector","selector","String","replace","shimMatchesSelector","findOne","el","firstElementChild","matches","nextElementSibling","matchesSelector","matchesTagName","localName","localNameLowerCase","ln","namespaceURI","XHTML_NS","matchesEveryThing","matchesLocalNameOnly","ns","matchesNameSpace","matchesLocalNameNS","findElements","arg0","arg1","querySelectorAllFiltered","OriginalElement","originalElementQuerySelectorAll","OriginalDocument","originalDocumentQuerySelectorAll","getElementsByTagNameFiltered","lowercase","originalElementGetElementsByTagName","originalDocumentGetElementsByTagName","getElementsByTagNameNSFiltered","originalElementGetElementsByTagNameNS","originalDocumentGetElementsByTagNameNS","originalDocumentQuerySelector","originalElementQuerySelector","documentElement","getElementsByTagName","getElementsByTagNameNS","Element","HTMLDocument","SelectorsInterface","shimmed","MatchesInterface","originalMatches","GetElementsByInterface","toLowerCase","getElementsByClassName","className","forwardElement","backwardsElement","ParentNodeInterface","lastElementChild","childElementCount","children","ChildNodeInterface","previousElementSibling","NonElementParentNodeInterface","getElementById","CharacterData","OriginalCharacterData","nodeValue","toUInt32","Text","OriginalText","splitText","offset","head","tail","newTextNode","getClass","getAttribute","enqueueClassAttributeChange","invalidateClass","invalidateRendererBasedOnAttribute","changeClass","tokenList","method","ownerElement","ownerElement_","retv","DOMTokenList","console","warn","oldAdd","add","oldRemove","oldToggle","toggle","dependsOnAttribute","invalidate","enqueAttributeChange","matchesNames","filter","matchesName","classListTable","newShadowRoot","polymerShadowRoot_","setAttribute","removeAttribute","classList","webkitCreateShadowRoot","createElementNS","escapeReplace","escapeAttr","escapeAttrRegExp","escapeData","escapeDataRegExp","makeSet","arr","needsSelfClosingSlash","doctype","publicId","systemId","getOuterHTML","attr","tagName","attrs","voidElements","getInnerHTML","plaintextParents","setInnerHTML","opt_tagName","tempElement","createElement","innerHTML","frag","contextElement","html","getterRequiresRendering","getterAndSetterRequiresRendering","methodRequiresRendering","oldIe","OriginalHTMLElement","OriginalHTMLTemplateElement","outerHTML","insertAdjacentHTML","position","text","hidden","hasAttribute","HTMLCanvasElement","OriginalHTMLCanvasElement","getContext","HTMLContentElement","OriginalHTMLContentElement","select","HTMLFormElement","OriginalHTMLFormElement","elements","HTMLImageElement","Image","width","height","OriginalHTMLImageElement","OriginalHTMLShadowElement","getTemplateContentsOwner","d","templateContentsOwnerTable","implementation","createHTMLDocument","extractContent","templateElement","contentTable","HTMLMediaElement","OriginalHTMLMediaElement","HTMLAudioElement","Audio","src","OriginalHTMLAudioElement","trimText","trim","HTMLOptionElement","Option","defaultSelected","selected","OriginalHTMLOptionElement","form","HTMLSelectElement","OriginalHTMLSelectElement","before","indexOrNode","HTMLTableElement","OriginalHTMLTableElement","caption","createCaption","tHead","createTHead","createTFoot","tFoot","tBodies","createTBody","rows","insertRow","HTMLTableSectionElement","OriginalHTMLTableSectionElement","HTMLTableRowElement","OriginalHTMLTableRowElement","cells","insertCell","HTMLUnknownElement","OriginalHTMLUnknownElement","SVGElement","SVG_NS","OriginalSVGElement","svgTitleElement","ownerSVGElement","SVGUseElement","parentInterface","OriginalSVGUseElement","gWrapper","useElement","SVGGElement","parentInterfacePrototype","instanceRoot","animatedInstanceRoot","SVGElementInstance","OriginalSVGElementInstance","correspondingElement","correspondingUseElement","CanvasRenderingContext2D","OriginalCanvasRenderingContext2D","canvas","drawImage","createPattern","WebGLRenderingContext","OriginalWebGLRenderingContext","texImage2D","texSubImage2D","OriginalWebGLRenderingContextBase","instanceProperties","drawingBufferHeight","drawingBufferWidth","Comment","createComment","hostWrapper","oldShadowRoot","nextOlderShadowTreeTable","shadowHostTable","getSelection","activeElement","unwrappedActiveElement","getHost","hostNodeToShadowNode","shadowNodeToHostNode","Range","OriginalRange","startContainer","endContainer","commonAncestorContainer","setStart","setEnd","setStartBefore","setStartAfter","setEndBefore","setEndAfter","selectNode","selectNodeContents","compareBoundaryPoints","how","sourceRange","extractContents","cloneContents","insertNode","surroundContents","newParent","cloneRange","isPointInRange","comparePoint","intersectsNode","toString","createContextualFragment","createRange","updateWrapperUpAndSideways","parentNodeWrapper","refChildWrapper","newChild","refChild","lastChildWrapper","nodeWrapper","resetDistributedNodes","distributedNodesTable","getDistributedNodes","getChildNodesSnapshot","pendingDirtyRenderers","parentRenderer","dirty","render","handleRequestAnimationFrame","renderTimer","rendererForHostTable","ShadowRenderer","getShadowRootAncestor","getRendererForShadowRoot","RenderNode","skip","invalidateAttributes","associateNode","poolPopulation","pool","isInsertionPoint","getShadowInsertionPoint","res","destributeNodeInto","points","destinationInsertionPointsTable","resetDestinationInsertionPoints","contentElement","selectorStartCharRe","isFinalDestination","isShadowHost","shadowHost","getShadowTrees","trees","tree","request","spliceDiff","renderNode","rawNode","append","sync","opt_added","newChildren","oldChildren","added","newIndex","lastIndex","removedCount","newChildRenderNode","opt_renderNode","distribution","buildRenderTree","topMostRenderer","resetAllSubtrees","distributionResolution","resetAll","shadowTrees","poolDistribution","shadowTree","updateDependentAttributes","anyDistributed","compose","childRenderNode","distributedNodes","distributedNode","_","polymerShadowRenderer_","force","visual","elementsWithFormProperty","Selection","OriginalSelection","anchorNode","focusNode","addRange","range","collapse","containsNode","allowPartial","getRangeAt","removeRange","selectAllChildren","extend","TreeWalker","OriginalTreeWalker","currentNode","wrapMethod","originalAdoptNode","adoptSubtree","adoptOlderShadowRoots","DOMImplementation","wrapImplMethod","forwardImplMethod","implementationTable","originalGetSelection","getElementsByName","JSON","stringify","originalCreateTreeWalker","createTreeWalker","TreeWalkerWrapper","whatToShow","expandEntityReferences","newFilter","acceptNode","registerElement","originalRegisterElement","CustomElementConstructor","extendsOption","proto","prototypes","newPrototype","HTMLBodyElement","HTMLHeadElement","HTMLHtmlElement","originalCreateDocument","createDocument","OriginalWindow","originalGetComputedStyle","getComputedStyle","originalGetDefaultComputedStyle","getDefaultComputedStyle","pseudo","OriginalDataTransfer","DataTransfer","Clipboard","OriginalDataTransferSetDragImage","setDragImage","image","FormData","formElement","OriginalFormData","originalSend","XMLHttpRequest","send","overrideConstructor","nativeConstructorName","area","audio","base","body","br","col","datalist","del","dir","div","dl","embed","fieldset","font","frame","frameset","h1","hr","iframe","img","input","keygen","label","legend","li","link","map","marquee","menu","menuitem","meta","meter","ol","optgroup","output","param","pre","progress","q","span","style","table","tbody","template","textarea","thead","time","title","tr","track","ul","video","stylesToCssText","styles","preserveComments","cssText","cssCommentRe","cssTextToStyle","cssToRules","rules","sheet","cssRules","initFrame","initialized","contentDocument","href","baseURI","inFrame","fn","withCssRules","isChrome","addCssToDocument","getSheet","addOwnSheet","SHIMMED_ATTRIBUTE","ShadowCSS","strictStyling","registry","shimStyling","extendsName","scopeStyles","prepareRoot","typeExtension","isTypeExtension","scopeSelector","makeScopeSelector","scopeCssText","shimmedStyle","shimStyle","shimCssText","insertDirectives","def","registerRoot","replaceTextInStyles","rootStyles","removeStyles","applyScopeToContent","l","findStyles","extendee","concat","NO_SHIM_ATTRIBUTE","insertPolyfillDirectivesInCssText","insertPolyfillRulesInCssText","cssCommentNextSelectorRe","p1","cssContentNextSelectorRe","cssCommentRuleRe","cssContentRuleRe","p2","p3","rule","unscoped","extractUnscopedRulesFromCssText","insertPolyfillHostInCssText","convertColonHost","convertColonHostContext","convertShadowDOMSelectors","scopeRules","r","cssCommentUnscopedRuleRe","exec","cssContentUnscopedRuleRe","convertColonRule","cssColonHostRe","colonHostPartReplacer","cssColonHostContextRe","colonHostContextPartReplacer","regExp","partReplacer","polyfillHostNoCombinator","join","part","suffix","polyfillHost","shadowDOMSelectorsRe","selectorText","propertiesFromRule","CSSRule","MEDIA_RULE","media","mediaText","KEYFRAMES_RULE","ieSafeCssTextFromKeyFrameRule","keyText","strict","selectorNeedsScoping","applyStrictSelectorScope","applySelectorScope","isArray","re","makeScopeMatcher","RegExp","selectorReSuffix","selectorScope","applySelectorScopeList","applySimpleSelectorScope","scopeSelectorList","polyfillHostRe","splits","scoped","attrName","sep","t","colonHostContextRe","polyfillHostContext","colonHostRe","action","parenSuffix","display","SHIM_ATTRIBUTE","urlResolver","HTMLImports","SHIM_SHEET_SELECTOR","SHIM_STYLE_SELECTOR","importer","documentPreloadSelectors","importsPreloadSelectors","parser","documentSelectors","originalParseGeneric","parseGeneric","elt","__importElement","__resource","resolveUrlsInStyle","addElementToDocument","__importParsed","markParsingComplete","parseNext","hasResource","rel","isRelativeScheme","scheme","relative","invalid","clear","_isInvalid","IDNAToASCII","h","percentEscape","unicode","charCodeAt","encodeURIComponent","percentEscapeQuery","parse","stateOverride","message","errors","state","cursor","buffer","seenAt","seenBracket","loop","EOF","ALPHA","ALPHANUMERIC","_scheme","_isRelative","_query","_fragment","_schemeData","_host","_port","_path","_username","_password","nextC","nextNextC","cp","tempC","temp","parseInt","relativePathDotMapping","jURL","url","_url","hasWorkingUrl","forceJURL","u","URL","pathname","ftp","gopher","http","https","ws","wss","authority","protocol","hostname","port","hash","origin","OriginalURL","createObjectURL","blob","revokeObjectURL","global","scheduledObservers","setImmediate","dispatchCallbacks","observers","o1","o2","anyNonEmpty","forEachAncestorAndObserverEnqueueRecord","enqueue","JsMutationObserver","copyMutationRecord","getRecord","currentRecord","getRecordWithOldValue","recordWithOldValue","clearRecords","recordRepresentsCurrentMutation","selectRecord","lastRecord","newRecord","setImmediateQueue","sentinel","postMessage","SyntaxError","removeListeners","addListeners","records","recordToReplaceLast","addListeners_","removeListeners_","relatedNode","attrChange","MutationEvent","ADDITION","prevValue","changedNode","_isPolyfilled","performance","start","requestAnimationFrame","nativeRaf","webkitRequestAnimationFrame","mozRequestAnimationFrame","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","clearTimeout","workingDefaultPrevented","origPreventDefault","isIE","inType","params","initCustomEvent","origEvent","whenReady","rootDocument","whenDocumentReady","watchImportsLoad","isDocumentReady","readyState","requiredReadyState","checkReady","READY_EVENT","markTargetLoaded","__loaded","checkDone","parsedCount","importCount","allImports","imports","loadedImports","newImports","errorImports","loadedImport","errorLoadingImport","imp","isImportLoaded","handleImports","isImport","handleImport","IMPORT_LINK_TYPE","hasShadowDOMPolyfill","currentScriptDescriptor","currentScript","scripts","mxns","ready","readyTime","getTime","evt","addModule","initializeModules","CSS_URL_REGEXP","CSS_IMPORT_REGEXP","linkUrl","resolver","resolveUrlsInCssText","urlObj","replaceUrls","regexp","post","urlPath","xhr","async","ok","status","load","next","nextContext","debug","bust","open","redirectedUrl","locationHeader","getResponseHeader","substr","response","responseText","loadDocument","responseType","Loader","onLoad","onComplete","cache","onload","oncomplete","inflight","addNodes","require","addNode","__nodeUrl","dedupe","fetch","pieces","header","atob","decodeURIComponent","receive","bind","receiveXhr","resource","$p","Observer","addCallback","mutations","nodeIsImport","generateScriptDataUrl","scriptContent","generateScriptContent","generateSourceMapHint","__importedScripts","moniker","num","cloneStyle","IMPORT_SELECTOR","importParser","importsSelectors","dynamicElements","nextToParse","isParsed","markParsing","parseDynamic","quiet","parsingElement","markDynamicParsingComplete","parseImport","__doc","__importsParsingHook","__error","__pending","shift","parseLink","linkElt","parseStyle","__appliedElement","trackElement","rootImportForElement","__importLink","done","fakeLoad","csr","IMPORT_RULE","styleSheet","parseScript","scriptElt","_mayParse","nextToParseInDoc","nextToParseDynamic","parseSelectorsForNode","needsDynamicParsing","isImportLink","isLinkRel","hasBaseURIAccessor","makeDocument","_URL","bootstrap","documents","loadNode","importLoader","loadSubtree","marshalNodes","loadSelectorsForNode","bootDocument","loadedAll","baseURIDescriptor","dynamic","parsed","loading","shouldLoadNode","shouldParseNode","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","attachEvent","hasNative","forSubtree","cb","findAllElements","forRoots","find","forDocumentTree","_forDocumentTree","processingDocuments","addedNode","isAttached","addedSubtree","upgrade","attached","deferMutation","pendingMutations","isPendingMutations","takeMutations","hasThrottledAttached","_attached","__upgraded__","__attached","attachedCallback","detachedNode","detached","_detached","detachedCallback","inDocument","DOCUMENT_FRAGMENT_NODE","watchShadow","__watched","dom","mx","group","groupEnd","__observer","inRoot","upgradeDocument","isMainDocument","upgradeDocumentTree","hasPolyfillMutations","originalCreateShadowRoot","upgradeSubtree","upgradeAll","decorate","is","definition","getRegisteredDefinition","tag","upgradeWithDefinition","implementPrototype","created","customMixin","inTarget","inSrc","inNative","used","k","createdCallback","isReservedTag","__name","lifecycle","ancestry","resolveTagName","resolvePrototypeChain","overrideAttributeApi","registerDefinition","ctor","generateConstructor","_polyfilled","changeAttribute","operation","newValue","attributeChangedCallback","reservedTagList","extnds","baseTag","inst","foundPrototype","instantiate","domCreateElement","HTML_NAMESPACE","domCreateElementNS","wrapDomMethodToForceUpgrade","methodName","orig","isInstance","elapsed","nop","eager","loadEvent","args2","Platform"],"mappings":"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","file":"webcomponent.91fc0dafbd71512e1b52.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t// @version 0.7.20\n\t(function() {\n\t  window.WebComponents = window.WebComponents || {\n\t    flags: {}\n\t  };\n\t  var file = \"webcomponents.js\";\n\t  var script = document.querySelector('script[src*=\"' + file + '\"]');\n\t  var flags = {};\n\t  if (!flags.noOpts) {\n\t    location.search.slice(1).split(\"&\").forEach(function(option) {\n\t      var parts = option.split(\"=\");\n\t      var match;\n\t      if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {\n\t        flags[match[1]] = parts[1] || true;\n\t      }\n\t    });\n\t    if (script) {\n\t      for (var i = 0, a; a = script.attributes[i]; i++) {\n\t        if (a.name !== \"src\") {\n\t          flags[a.name] = a.value || true;\n\t        }\n\t      }\n\t    }\n\t    if (flags.log && flags.log.split) {\n\t      var parts = flags.log.split(\",\");\n\t      flags.log = {};\n\t      parts.forEach(function(f) {\n\t        flags.log[f] = true;\n\t      });\n\t    } else {\n\t      flags.log = {};\n\t    }\n\t  }\n\t  flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;\n\t  if (flags.shadow === \"native\") {\n\t    flags.shadow = false;\n\t  } else {\n\t    flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;\n\t  }\n\t  if (flags.register) {\n\t    window.CustomElements = window.CustomElements || {\n\t      flags: {}\n\t    };\n\t    window.CustomElements.flags.register = flags.register;\n\t  }\n\t  WebComponents.flags = flags;\n\t})();\n\t\n\tif (WebComponents.flags.shadow) {\n\t  if (typeof WeakMap === \"undefined\") {\n\t    (function() {\n\t      var defineProperty = Object.defineProperty;\n\t      var counter = Date.now() % 1e9;\n\t      var WeakMap = function() {\n\t        this.name = \"__st\" + (Math.random() * 1e9 >>> 0) + (counter++ + \"__\");\n\t      };\n\t      WeakMap.prototype = {\n\t        set: function(key, value) {\n\t          var entry = key[this.name];\n\t          if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {\n\t            value: [ key, value ],\n\t            writable: true\n\t          });\n\t          return this;\n\t        },\n\t        get: function(key) {\n\t          var entry;\n\t          return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;\n\t        },\n\t        \"delete\": function(key) {\n\t          var entry = key[this.name];\n\t          if (!entry || entry[0] !== key) return false;\n\t          entry[0] = entry[1] = undefined;\n\t          return true;\n\t        },\n\t        has: function(key) {\n\t          var entry = key[this.name];\n\t          if (!entry) return false;\n\t          return entry[0] === key;\n\t        }\n\t      };\n\t      window.WeakMap = WeakMap;\n\t    })();\n\t  }\n\t  window.ShadowDOMPolyfill = {};\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var constructorTable = new WeakMap();\n\t    var nativePrototypeTable = new WeakMap();\n\t    var wrappers = Object.create(null);\n\t    function detectEval() {\n\t      if (typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime) {\n\t        return false;\n\t      }\n\t      if (navigator.getDeviceStorage) {\n\t        return false;\n\t      }\n\t      try {\n\t        var f = new Function(\"return true;\");\n\t        return f();\n\t      } catch (ex) {\n\t        return false;\n\t      }\n\t    }\n\t    var hasEval = detectEval();\n\t    function assert(b) {\n\t      if (!b) throw new Error(\"Assertion failed\");\n\t    }\n\t    var defineProperty = Object.defineProperty;\n\t    var getOwnPropertyNames = Object.getOwnPropertyNames;\n\t    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\t    function mixin(to, from) {\n\t      var names = getOwnPropertyNames(from);\n\t      for (var i = 0; i < names.length; i++) {\n\t        var name = names[i];\n\t        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n\t      }\n\t      return to;\n\t    }\n\t    function mixinStatics(to, from) {\n\t      var names = getOwnPropertyNames(from);\n\t      for (var i = 0; i < names.length; i++) {\n\t        var name = names[i];\n\t        switch (name) {\n\t         case \"arguments\":\n\t         case \"caller\":\n\t         case \"length\":\n\t         case \"name\":\n\t         case \"prototype\":\n\t         case \"toString\":\n\t          continue;\n\t        }\n\t        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n\t      }\n\t      return to;\n\t    }\n\t    function oneOf(object, propertyNames) {\n\t      for (var i = 0; i < propertyNames.length; i++) {\n\t        if (propertyNames[i] in object) return propertyNames[i];\n\t      }\n\t    }\n\t    var nonEnumerableDataDescriptor = {\n\t      value: undefined,\n\t      configurable: true,\n\t      enumerable: false,\n\t      writable: true\n\t    };\n\t    function defineNonEnumerableDataProperty(object, name, value) {\n\t      nonEnumerableDataDescriptor.value = value;\n\t      defineProperty(object, name, nonEnumerableDataDescriptor);\n\t    }\n\t    getOwnPropertyNames(window);\n\t    function getWrapperConstructor(node, opt_instance) {\n\t      var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);\n\t      if (isFirefox) {\n\t        try {\n\t          getOwnPropertyNames(nativePrototype);\n\t        } catch (error) {\n\t          nativePrototype = nativePrototype.__proto__;\n\t        }\n\t      }\n\t      var wrapperConstructor = constructorTable.get(nativePrototype);\n\t      if (wrapperConstructor) return wrapperConstructor;\n\t      var parentWrapperConstructor = getWrapperConstructor(nativePrototype);\n\t      var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);\n\t      registerInternal(nativePrototype, GeneratedWrapper, opt_instance);\n\t      return GeneratedWrapper;\n\t    }\n\t    function addForwardingProperties(nativePrototype, wrapperPrototype) {\n\t      installProperty(nativePrototype, wrapperPrototype, true);\n\t    }\n\t    function registerInstanceProperties(wrapperPrototype, instanceObject) {\n\t      installProperty(instanceObject, wrapperPrototype, false);\n\t    }\n\t    var isFirefox = /Firefox/.test(navigator.userAgent);\n\t    var dummyDescriptor = {\n\t      get: function() {},\n\t      set: function(v) {},\n\t      configurable: true,\n\t      enumerable: true\n\t    };\n\t    function isEventHandlerName(name) {\n\t      return /^on[a-z]+$/.test(name);\n\t    }\n\t    function isIdentifierName(name) {\n\t      return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);\n\t    }\n\t    function getGetter(name) {\n\t      return hasEval && isIdentifierName(name) ? new Function(\"return this.__impl4cf1e782hg__.\" + name) : function() {\n\t        return this.__impl4cf1e782hg__[name];\n\t      };\n\t    }\n\t    function getSetter(name) {\n\t      return hasEval && isIdentifierName(name) ? new Function(\"v\", \"this.__impl4cf1e782hg__.\" + name + \" = v\") : function(v) {\n\t        this.__impl4cf1e782hg__[name] = v;\n\t      };\n\t    }\n\t    function getMethod(name) {\n\t      return hasEval && isIdentifierName(name) ? new Function(\"return this.__impl4cf1e782hg__.\" + name + \".apply(this.__impl4cf1e782hg__, arguments)\") : function() {\n\t        return this.__impl4cf1e782hg__[name].apply(this.__impl4cf1e782hg__, arguments);\n\t      };\n\t    }\n\t    function getDescriptor(source, name) {\n\t      try {\n\t        return Object.getOwnPropertyDescriptor(source, name);\n\t      } catch (ex) {\n\t        return dummyDescriptor;\n\t      }\n\t    }\n\t    var isBrokenSafari = function() {\n\t      var descr = Object.getOwnPropertyDescriptor(Node.prototype, \"nodeType\");\n\t      return descr && !descr.get && !descr.set;\n\t    }();\n\t    function installProperty(source, target, allowMethod, opt_blacklist) {\n\t      var names = getOwnPropertyNames(source);\n\t      for (var i = 0; i < names.length; i++) {\n\t        var name = names[i];\n\t        if (name === \"polymerBlackList_\") continue;\n\t        if (name in target) continue;\n\t        if (source.polymerBlackList_ && source.polymerBlackList_[name]) continue;\n\t        if (isFirefox) {\n\t          source.__lookupGetter__(name);\n\t        }\n\t        var descriptor = getDescriptor(source, name);\n\t        var getter, setter;\n\t        if (typeof descriptor.value === \"function\") {\n\t          if (allowMethod) {\n\t            target[name] = getMethod(name);\n\t          }\n\t          continue;\n\t        }\n\t        var isEvent = isEventHandlerName(name);\n\t        if (isEvent) getter = scope.getEventHandlerGetter(name); else getter = getGetter(name);\n\t        if (descriptor.writable || descriptor.set || isBrokenSafari) {\n\t          if (isEvent) setter = scope.getEventHandlerSetter(name); else setter = getSetter(name);\n\t        }\n\t        var configurable = isBrokenSafari || descriptor.configurable;\n\t        defineProperty(target, name, {\n\t          get: getter,\n\t          set: setter,\n\t          configurable: configurable,\n\t          enumerable: descriptor.enumerable\n\t        });\n\t      }\n\t    }\n\t    function register(nativeConstructor, wrapperConstructor, opt_instance) {\n\t      if (nativeConstructor == null) {\n\t        return;\n\t      }\n\t      var nativePrototype = nativeConstructor.prototype;\n\t      registerInternal(nativePrototype, wrapperConstructor, opt_instance);\n\t      mixinStatics(wrapperConstructor, nativeConstructor);\n\t    }\n\t    function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {\n\t      var wrapperPrototype = wrapperConstructor.prototype;\n\t      assert(constructorTable.get(nativePrototype) === undefined);\n\t      constructorTable.set(nativePrototype, wrapperConstructor);\n\t      nativePrototypeTable.set(wrapperPrototype, nativePrototype);\n\t      addForwardingProperties(nativePrototype, wrapperPrototype);\n\t      if (opt_instance) registerInstanceProperties(wrapperPrototype, opt_instance);\n\t      defineNonEnumerableDataProperty(wrapperPrototype, \"constructor\", wrapperConstructor);\n\t      wrapperConstructor.prototype = wrapperPrototype;\n\t    }\n\t    function isWrapperFor(wrapperConstructor, nativeConstructor) {\n\t      return constructorTable.get(nativeConstructor.prototype) === wrapperConstructor;\n\t    }\n\t    function registerObject(object) {\n\t      var nativePrototype = Object.getPrototypeOf(object);\n\t      var superWrapperConstructor = getWrapperConstructor(nativePrototype);\n\t      var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);\n\t      registerInternal(nativePrototype, GeneratedWrapper, object);\n\t      return GeneratedWrapper;\n\t    }\n\t    function createWrapperConstructor(superWrapperConstructor) {\n\t      function GeneratedWrapper(node) {\n\t        superWrapperConstructor.call(this, node);\n\t      }\n\t      var p = Object.create(superWrapperConstructor.prototype);\n\t      p.constructor = GeneratedWrapper;\n\t      GeneratedWrapper.prototype = p;\n\t      return GeneratedWrapper;\n\t    }\n\t    function isWrapper(object) {\n\t      return object && object.__impl4cf1e782hg__;\n\t    }\n\t    function isNative(object) {\n\t      return !isWrapper(object);\n\t    }\n\t    function wrap(impl) {\n\t      if (impl === null) return null;\n\t      assert(isNative(impl));\n\t      var wrapper = impl.__wrapper8e3dd93a60__;\n\t      if (wrapper != null) {\n\t        return wrapper;\n\t      }\n\t      return impl.__wrapper8e3dd93a60__ = new (getWrapperConstructor(impl, impl))(impl);\n\t    }\n\t    function unwrap(wrapper) {\n\t      if (wrapper === null) return null;\n\t      assert(isWrapper(wrapper));\n\t      return wrapper.__impl4cf1e782hg__;\n\t    }\n\t    function unsafeUnwrap(wrapper) {\n\t      return wrapper.__impl4cf1e782hg__;\n\t    }\n\t    function setWrapper(impl, wrapper) {\n\t      wrapper.__impl4cf1e782hg__ = impl;\n\t      impl.__wrapper8e3dd93a60__ = wrapper;\n\t    }\n\t    function unwrapIfNeeded(object) {\n\t      return object && isWrapper(object) ? unwrap(object) : object;\n\t    }\n\t    function wrapIfNeeded(object) {\n\t      return object && !isWrapper(object) ? wrap(object) : object;\n\t    }\n\t    function rewrap(node, wrapper) {\n\t      if (wrapper === null) return;\n\t      assert(isNative(node));\n\t      assert(wrapper === undefined || isWrapper(wrapper));\n\t      node.__wrapper8e3dd93a60__ = wrapper;\n\t    }\n\t    var getterDescriptor = {\n\t      get: undefined,\n\t      configurable: true,\n\t      enumerable: true\n\t    };\n\t    function defineGetter(constructor, name, getter) {\n\t      getterDescriptor.get = getter;\n\t      defineProperty(constructor.prototype, name, getterDescriptor);\n\t    }\n\t    function defineWrapGetter(constructor, name) {\n\t      defineGetter(constructor, name, function() {\n\t        return wrap(this.__impl4cf1e782hg__[name]);\n\t      });\n\t    }\n\t    function forwardMethodsToWrapper(constructors, names) {\n\t      constructors.forEach(function(constructor) {\n\t        names.forEach(function(name) {\n\t          constructor.prototype[name] = function() {\n\t            var w = wrapIfNeeded(this);\n\t            return w[name].apply(w, arguments);\n\t          };\n\t        });\n\t      });\n\t    }\n\t    scope.addForwardingProperties = addForwardingProperties;\n\t    scope.assert = assert;\n\t    scope.constructorTable = constructorTable;\n\t    scope.defineGetter = defineGetter;\n\t    scope.defineWrapGetter = defineWrapGetter;\n\t    scope.forwardMethodsToWrapper = forwardMethodsToWrapper;\n\t    scope.isIdentifierName = isIdentifierName;\n\t    scope.isWrapper = isWrapper;\n\t    scope.isWrapperFor = isWrapperFor;\n\t    scope.mixin = mixin;\n\t    scope.nativePrototypeTable = nativePrototypeTable;\n\t    scope.oneOf = oneOf;\n\t    scope.registerObject = registerObject;\n\t    scope.registerWrapper = register;\n\t    scope.rewrap = rewrap;\n\t    scope.setWrapper = setWrapper;\n\t    scope.unsafeUnwrap = unsafeUnwrap;\n\t    scope.unwrap = unwrap;\n\t    scope.unwrapIfNeeded = unwrapIfNeeded;\n\t    scope.wrap = wrap;\n\t    scope.wrapIfNeeded = wrapIfNeeded;\n\t    scope.wrappers = wrappers;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    function newSplice(index, removed, addedCount) {\n\t      return {\n\t        index: index,\n\t        removed: removed,\n\t        addedCount: addedCount\n\t      };\n\t    }\n\t    var EDIT_LEAVE = 0;\n\t    var EDIT_UPDATE = 1;\n\t    var EDIT_ADD = 2;\n\t    var EDIT_DELETE = 3;\n\t    function ArraySplice() {}\n\t    ArraySplice.prototype = {\n\t      calcEditDistances: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n\t        var rowCount = oldEnd - oldStart + 1;\n\t        var columnCount = currentEnd - currentStart + 1;\n\t        var distances = new Array(rowCount);\n\t        for (var i = 0; i < rowCount; i++) {\n\t          distances[i] = new Array(columnCount);\n\t          distances[i][0] = i;\n\t        }\n\t        for (var j = 0; j < columnCount; j++) distances[0][j] = j;\n\t        for (var i = 1; i < rowCount; i++) {\n\t          for (var j = 1; j < columnCount; j++) {\n\t            if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1]; else {\n\t              var north = distances[i - 1][j] + 1;\n\t              var west = distances[i][j - 1] + 1;\n\t              distances[i][j] = north < west ? north : west;\n\t            }\n\t          }\n\t        }\n\t        return distances;\n\t      },\n\t      spliceOperationsFromEditDistances: function(distances) {\n\t        var i = distances.length - 1;\n\t        var j = distances[0].length - 1;\n\t        var current = distances[i][j];\n\t        var edits = [];\n\t        while (i > 0 || j > 0) {\n\t          if (i == 0) {\n\t            edits.push(EDIT_ADD);\n\t            j--;\n\t            continue;\n\t          }\n\t          if (j == 0) {\n\t            edits.push(EDIT_DELETE);\n\t            i--;\n\t            continue;\n\t          }\n\t          var northWest = distances[i - 1][j - 1];\n\t          var west = distances[i - 1][j];\n\t          var north = distances[i][j - 1];\n\t          var min;\n\t          if (west < north) min = west < northWest ? west : northWest; else min = north < northWest ? north : northWest;\n\t          if (min == northWest) {\n\t            if (northWest == current) {\n\t              edits.push(EDIT_LEAVE);\n\t            } else {\n\t              edits.push(EDIT_UPDATE);\n\t              current = northWest;\n\t            }\n\t            i--;\n\t            j--;\n\t          } else if (min == west) {\n\t            edits.push(EDIT_DELETE);\n\t            i--;\n\t            current = west;\n\t          } else {\n\t            edits.push(EDIT_ADD);\n\t            j--;\n\t            current = north;\n\t          }\n\t        }\n\t        edits.reverse();\n\t        return edits;\n\t      },\n\t      calcSplices: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n\t        var prefixCount = 0;\n\t        var suffixCount = 0;\n\t        var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\t        if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);\n\t        if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\t        currentStart += prefixCount;\n\t        oldStart += prefixCount;\n\t        currentEnd -= suffixCount;\n\t        oldEnd -= suffixCount;\n\t        if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n\t        if (currentStart == currentEnd) {\n\t          var splice = newSplice(currentStart, [], 0);\n\t          while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);\n\t          return [ splice ];\n\t        } else if (oldStart == oldEnd) return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\t        var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n\t        var splice = undefined;\n\t        var splices = [];\n\t        var index = currentStart;\n\t        var oldIndex = oldStart;\n\t        for (var i = 0; i < ops.length; i++) {\n\t          switch (ops[i]) {\n\t           case EDIT_LEAVE:\n\t            if (splice) {\n\t              splices.push(splice);\n\t              splice = undefined;\n\t            }\n\t            index++;\n\t            oldIndex++;\n\t            break;\n\t\n\t           case EDIT_UPDATE:\n\t            if (!splice) splice = newSplice(index, [], 0);\n\t            splice.addedCount++;\n\t            index++;\n\t            splice.removed.push(old[oldIndex]);\n\t            oldIndex++;\n\t            break;\n\t\n\t           case EDIT_ADD:\n\t            if (!splice) splice = newSplice(index, [], 0);\n\t            splice.addedCount++;\n\t            index++;\n\t            break;\n\t\n\t           case EDIT_DELETE:\n\t            if (!splice) splice = newSplice(index, [], 0);\n\t            splice.removed.push(old[oldIndex]);\n\t            oldIndex++;\n\t            break;\n\t          }\n\t        }\n\t        if (splice) {\n\t          splices.push(splice);\n\t        }\n\t        return splices;\n\t      },\n\t      sharedPrefix: function(current, old, searchLength) {\n\t        for (var i = 0; i < searchLength; i++) if (!this.equals(current[i], old[i])) return i;\n\t        return searchLength;\n\t      },\n\t      sharedSuffix: function(current, old, searchLength) {\n\t        var index1 = current.length;\n\t        var index2 = old.length;\n\t        var count = 0;\n\t        while (count < searchLength && this.equals(current[--index1], old[--index2])) count++;\n\t        return count;\n\t      },\n\t      calculateSplices: function(current, previous) {\n\t        return this.calcSplices(current, 0, current.length, previous, 0, previous.length);\n\t      },\n\t      equals: function(currentValue, previousValue) {\n\t        return currentValue === previousValue;\n\t      }\n\t    };\n\t    scope.ArraySplice = ArraySplice;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(context) {\n\t    \"use strict\";\n\t    var OriginalMutationObserver = window.MutationObserver;\n\t    var callbacks = [];\n\t    var pending = false;\n\t    var timerFunc;\n\t    function handle() {\n\t      pending = false;\n\t      var copies = callbacks.slice(0);\n\t      callbacks = [];\n\t      for (var i = 0; i < copies.length; i++) {\n\t        (0, copies[i])();\n\t      }\n\t    }\n\t    if (OriginalMutationObserver) {\n\t      var counter = 1;\n\t      var observer = new OriginalMutationObserver(handle);\n\t      var textNode = document.createTextNode(counter);\n\t      observer.observe(textNode, {\n\t        characterData: true\n\t      });\n\t      timerFunc = function() {\n\t        counter = (counter + 1) % 2;\n\t        textNode.data = counter;\n\t      };\n\t    } else {\n\t      timerFunc = window.setTimeout;\n\t    }\n\t    function setEndOfMicrotask(func) {\n\t      callbacks.push(func);\n\t      if (pending) return;\n\t      pending = true;\n\t      timerFunc(handle, 0);\n\t    }\n\t    context.setEndOfMicrotask = setEndOfMicrotask;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var setEndOfMicrotask = scope.setEndOfMicrotask;\n\t    var wrapIfNeeded = scope.wrapIfNeeded;\n\t    var wrappers = scope.wrappers;\n\t    var registrationsTable = new WeakMap();\n\t    var globalMutationObservers = [];\n\t    var isScheduled = false;\n\t    function scheduleCallback(observer) {\n\t      if (observer.scheduled_) return;\n\t      observer.scheduled_ = true;\n\t      globalMutationObservers.push(observer);\n\t      if (isScheduled) return;\n\t      setEndOfMicrotask(notifyObservers);\n\t      isScheduled = true;\n\t    }\n\t    function notifyObservers() {\n\t      isScheduled = false;\n\t      while (globalMutationObservers.length) {\n\t        var notifyList = globalMutationObservers;\n\t        globalMutationObservers = [];\n\t        notifyList.sort(function(x, y) {\n\t          return x.uid_ - y.uid_;\n\t        });\n\t        for (var i = 0; i < notifyList.length; i++) {\n\t          var mo = notifyList[i];\n\t          mo.scheduled_ = false;\n\t          var queue = mo.takeRecords();\n\t          removeTransientObserversFor(mo);\n\t          if (queue.length) {\n\t            mo.callback_(queue, mo);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    function MutationRecord(type, target) {\n\t      this.type = type;\n\t      this.target = target;\n\t      this.addedNodes = new wrappers.NodeList();\n\t      this.removedNodes = new wrappers.NodeList();\n\t      this.previousSibling = null;\n\t      this.nextSibling = null;\n\t      this.attributeName = null;\n\t      this.attributeNamespace = null;\n\t      this.oldValue = null;\n\t    }\n\t    function registerTransientObservers(ancestor, node) {\n\t      for (;ancestor; ancestor = ancestor.parentNode) {\n\t        var registrations = registrationsTable.get(ancestor);\n\t        if (!registrations) continue;\n\t        for (var i = 0; i < registrations.length; i++) {\n\t          var registration = registrations[i];\n\t          if (registration.options.subtree) registration.addTransientObserver(node);\n\t        }\n\t      }\n\t    }\n\t    function removeTransientObserversFor(observer) {\n\t      for (var i = 0; i < observer.nodes_.length; i++) {\n\t        var node = observer.nodes_[i];\n\t        var registrations = registrationsTable.get(node);\n\t        if (!registrations) return;\n\t        for (var j = 0; j < registrations.length; j++) {\n\t          var registration = registrations[j];\n\t          if (registration.observer === observer) registration.removeTransientObservers();\n\t        }\n\t      }\n\t    }\n\t    function enqueueMutation(target, type, data) {\n\t      var interestedObservers = Object.create(null);\n\t      var associatedStrings = Object.create(null);\n\t      for (var node = target; node; node = node.parentNode) {\n\t        var registrations = registrationsTable.get(node);\n\t        if (!registrations) continue;\n\t        for (var j = 0; j < registrations.length; j++) {\n\t          var registration = registrations[j];\n\t          var options = registration.options;\n\t          if (node !== target && !options.subtree) continue;\n\t          if (type === \"attributes\" && !options.attributes) continue;\n\t          if (type === \"attributes\" && options.attributeFilter && (data.namespace !== null || options.attributeFilter.indexOf(data.name) === -1)) {\n\t            continue;\n\t          }\n\t          if (type === \"characterData\" && !options.characterData) continue;\n\t          if (type === \"childList\" && !options.childList) continue;\n\t          var observer = registration.observer;\n\t          interestedObservers[observer.uid_] = observer;\n\t          if (type === \"attributes\" && options.attributeOldValue || type === \"characterData\" && options.characterDataOldValue) {\n\t            associatedStrings[observer.uid_] = data.oldValue;\n\t          }\n\t        }\n\t      }\n\t      for (var uid in interestedObservers) {\n\t        var observer = interestedObservers[uid];\n\t        var record = new MutationRecord(type, target);\n\t        if (\"name\" in data && \"namespace\" in data) {\n\t          record.attributeName = data.name;\n\t          record.attributeNamespace = data.namespace;\n\t        }\n\t        if (data.addedNodes) record.addedNodes = data.addedNodes;\n\t        if (data.removedNodes) record.removedNodes = data.removedNodes;\n\t        if (data.previousSibling) record.previousSibling = data.previousSibling;\n\t        if (data.nextSibling) record.nextSibling = data.nextSibling;\n\t        if (associatedStrings[uid] !== undefined) record.oldValue = associatedStrings[uid];\n\t        scheduleCallback(observer);\n\t        observer.records_.push(record);\n\t      }\n\t    }\n\t    var slice = Array.prototype.slice;\n\t    function MutationObserverOptions(options) {\n\t      this.childList = !!options.childList;\n\t      this.subtree = !!options.subtree;\n\t      if (!(\"attributes\" in options) && (\"attributeOldValue\" in options || \"attributeFilter\" in options)) {\n\t        this.attributes = true;\n\t      } else {\n\t        this.attributes = !!options.attributes;\n\t      }\n\t      if (\"characterDataOldValue\" in options && !(\"characterData\" in options)) this.characterData = true; else this.characterData = !!options.characterData;\n\t      if (!this.attributes && (options.attributeOldValue || \"attributeFilter\" in options) || !this.characterData && options.characterDataOldValue) {\n\t        throw new TypeError();\n\t      }\n\t      this.characterData = !!options.characterData;\n\t      this.attributeOldValue = !!options.attributeOldValue;\n\t      this.characterDataOldValue = !!options.characterDataOldValue;\n\t      if (\"attributeFilter\" in options) {\n\t        if (options.attributeFilter == null || typeof options.attributeFilter !== \"object\") {\n\t          throw new TypeError();\n\t        }\n\t        this.attributeFilter = slice.call(options.attributeFilter);\n\t      } else {\n\t        this.attributeFilter = null;\n\t      }\n\t    }\n\t    var uidCounter = 0;\n\t    function MutationObserver(callback) {\n\t      this.callback_ = callback;\n\t      this.nodes_ = [];\n\t      this.records_ = [];\n\t      this.uid_ = ++uidCounter;\n\t      this.scheduled_ = false;\n\t    }\n\t    MutationObserver.prototype = {\n\t      constructor: MutationObserver,\n\t      observe: function(target, options) {\n\t        target = wrapIfNeeded(target);\n\t        var newOptions = new MutationObserverOptions(options);\n\t        var registration;\n\t        var registrations = registrationsTable.get(target);\n\t        if (!registrations) registrationsTable.set(target, registrations = []);\n\t        for (var i = 0; i < registrations.length; i++) {\n\t          if (registrations[i].observer === this) {\n\t            registration = registrations[i];\n\t            registration.removeTransientObservers();\n\t            registration.options = newOptions;\n\t          }\n\t        }\n\t        if (!registration) {\n\t          registration = new Registration(this, target, newOptions);\n\t          registrations.push(registration);\n\t          this.nodes_.push(target);\n\t        }\n\t      },\n\t      disconnect: function() {\n\t        this.nodes_.forEach(function(node) {\n\t          var registrations = registrationsTable.get(node);\n\t          for (var i = 0; i < registrations.length; i++) {\n\t            var registration = registrations[i];\n\t            if (registration.observer === this) {\n\t              registrations.splice(i, 1);\n\t              break;\n\t            }\n\t          }\n\t        }, this);\n\t        this.records_ = [];\n\t      },\n\t      takeRecords: function() {\n\t        var copyOfRecords = this.records_;\n\t        this.records_ = [];\n\t        return copyOfRecords;\n\t      }\n\t    };\n\t    function Registration(observer, target, options) {\n\t      this.observer = observer;\n\t      this.target = target;\n\t      this.options = options;\n\t      this.transientObservedNodes = [];\n\t    }\n\t    Registration.prototype = {\n\t      addTransientObserver: function(node) {\n\t        if (node === this.target) return;\n\t        scheduleCallback(this.observer);\n\t        this.transientObservedNodes.push(node);\n\t        var registrations = registrationsTable.get(node);\n\t        if (!registrations) registrationsTable.set(node, registrations = []);\n\t        registrations.push(this);\n\t      },\n\t      removeTransientObservers: function() {\n\t        var transientObservedNodes = this.transientObservedNodes;\n\t        this.transientObservedNodes = [];\n\t        for (var i = 0; i < transientObservedNodes.length; i++) {\n\t          var node = transientObservedNodes[i];\n\t          var registrations = registrationsTable.get(node);\n\t          for (var j = 0; j < registrations.length; j++) {\n\t            if (registrations[j] === this) {\n\t              registrations.splice(j, 1);\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    };\n\t    scope.enqueueMutation = enqueueMutation;\n\t    scope.registerTransientObservers = registerTransientObservers;\n\t    scope.wrappers.MutationObserver = MutationObserver;\n\t    scope.wrappers.MutationRecord = MutationRecord;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    function TreeScope(root, parent) {\n\t      this.root = root;\n\t      this.parent = parent;\n\t    }\n\t    TreeScope.prototype = {\n\t      get renderer() {\n\t        if (this.root instanceof scope.wrappers.ShadowRoot) {\n\t          return scope.getRendererForHost(this.root.host);\n\t        }\n\t        return null;\n\t      },\n\t      contains: function(treeScope) {\n\t        for (;treeScope; treeScope = treeScope.parent) {\n\t          if (treeScope === this) return true;\n\t        }\n\t        return false;\n\t      }\n\t    };\n\t    function setTreeScope(node, treeScope) {\n\t      if (node.treeScope_ !== treeScope) {\n\t        node.treeScope_ = treeScope;\n\t        for (var sr = node.shadowRoot; sr; sr = sr.olderShadowRoot) {\n\t          sr.treeScope_.parent = treeScope;\n\t        }\n\t        for (var child = node.firstChild; child; child = child.nextSibling) {\n\t          setTreeScope(child, treeScope);\n\t        }\n\t      }\n\t    }\n\t    function getTreeScope(node) {\n\t      if (node instanceof scope.wrappers.Window) {\n\t        debugger;\n\t      }\n\t      if (node.treeScope_) return node.treeScope_;\n\t      var parent = node.parentNode;\n\t      var treeScope;\n\t      if (parent) treeScope = getTreeScope(parent); else treeScope = new TreeScope(node, null);\n\t      return node.treeScope_ = treeScope;\n\t    }\n\t    scope.TreeScope = TreeScope;\n\t    scope.getTreeScope = getTreeScope;\n\t    scope.setTreeScope = setTreeScope;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n\t    var getTreeScope = scope.getTreeScope;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var setWrapper = scope.setWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var wrappers = scope.wrappers;\n\t    var wrappedFuns = new WeakMap();\n\t    var listenersTable = new WeakMap();\n\t    var handledEventsTable = new WeakMap();\n\t    var currentlyDispatchingEvents = new WeakMap();\n\t    var targetTable = new WeakMap();\n\t    var currentTargetTable = new WeakMap();\n\t    var relatedTargetTable = new WeakMap();\n\t    var eventPhaseTable = new WeakMap();\n\t    var stopPropagationTable = new WeakMap();\n\t    var stopImmediatePropagationTable = new WeakMap();\n\t    var eventHandlersTable = new WeakMap();\n\t    var eventPathTable = new WeakMap();\n\t    function isShadowRoot(node) {\n\t      return node instanceof wrappers.ShadowRoot;\n\t    }\n\t    function rootOfNode(node) {\n\t      return getTreeScope(node).root;\n\t    }\n\t    function getEventPath(node, event) {\n\t      var path = [];\n\t      var current = node;\n\t      path.push(current);\n\t      while (current) {\n\t        var destinationInsertionPoints = getDestinationInsertionPoints(current);\n\t        if (destinationInsertionPoints && destinationInsertionPoints.length > 0) {\n\t          for (var i = 0; i < destinationInsertionPoints.length; i++) {\n\t            var insertionPoint = destinationInsertionPoints[i];\n\t            if (isShadowInsertionPoint(insertionPoint)) {\n\t              var shadowRoot = rootOfNode(insertionPoint);\n\t              var olderShadowRoot = shadowRoot.olderShadowRoot;\n\t              if (olderShadowRoot) path.push(olderShadowRoot);\n\t            }\n\t            path.push(insertionPoint);\n\t          }\n\t          current = destinationInsertionPoints[destinationInsertionPoints.length - 1];\n\t        } else {\n\t          if (isShadowRoot(current)) {\n\t            if (inSameTree(node, current) && eventMustBeStopped(event)) {\n\t              break;\n\t            }\n\t            current = current.host;\n\t            path.push(current);\n\t          } else {\n\t            current = current.parentNode;\n\t            if (current) path.push(current);\n\t          }\n\t        }\n\t      }\n\t      return path;\n\t    }\n\t    function eventMustBeStopped(event) {\n\t      if (!event) return false;\n\t      switch (event.type) {\n\t       case \"abort\":\n\t       case \"error\":\n\t       case \"select\":\n\t       case \"change\":\n\t       case \"load\":\n\t       case \"reset\":\n\t       case \"resize\":\n\t       case \"scroll\":\n\t       case \"selectstart\":\n\t        return true;\n\t      }\n\t      return false;\n\t    }\n\t    function isShadowInsertionPoint(node) {\n\t      return node instanceof HTMLShadowElement;\n\t    }\n\t    function getDestinationInsertionPoints(node) {\n\t      return scope.getDestinationInsertionPoints(node);\n\t    }\n\t    function eventRetargetting(path, currentTarget) {\n\t      if (path.length === 0) return currentTarget;\n\t      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\n\t      var currentTargetTree = getTreeScope(currentTarget);\n\t      var originalTarget = path[0];\n\t      var originalTargetTree = getTreeScope(originalTarget);\n\t      var relativeTargetTree = lowestCommonInclusiveAncestor(currentTargetTree, originalTargetTree);\n\t      for (var i = 0; i < path.length; i++) {\n\t        var node = path[i];\n\t        if (getTreeScope(node) === relativeTargetTree) return node;\n\t      }\n\t      return path[path.length - 1];\n\t    }\n\t    function getTreeScopeAncestors(treeScope) {\n\t      var ancestors = [];\n\t      for (;treeScope; treeScope = treeScope.parent) {\n\t        ancestors.push(treeScope);\n\t      }\n\t      return ancestors;\n\t    }\n\t    function lowestCommonInclusiveAncestor(tsA, tsB) {\n\t      var ancestorsA = getTreeScopeAncestors(tsA);\n\t      var ancestorsB = getTreeScopeAncestors(tsB);\n\t      var result = null;\n\t      while (ancestorsA.length > 0 && ancestorsB.length > 0) {\n\t        var a = ancestorsA.pop();\n\t        var b = ancestorsB.pop();\n\t        if (a === b) result = a; else break;\n\t      }\n\t      return result;\n\t    }\n\t    function getTreeScopeRoot(ts) {\n\t      if (!ts.parent) return ts;\n\t      return getTreeScopeRoot(ts.parent);\n\t    }\n\t    function relatedTargetResolution(event, currentTarget, relatedTarget) {\n\t      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\n\t      var currentTargetTree = getTreeScope(currentTarget);\n\t      var relatedTargetTree = getTreeScope(relatedTarget);\n\t      var relatedTargetEventPath = getEventPath(relatedTarget, event);\n\t      var lowestCommonAncestorTree;\n\t      var lowestCommonAncestorTree = lowestCommonInclusiveAncestor(currentTargetTree, relatedTargetTree);\n\t      if (!lowestCommonAncestorTree) lowestCommonAncestorTree = relatedTargetTree.root;\n\t      for (var commonAncestorTree = lowestCommonAncestorTree; commonAncestorTree; commonAncestorTree = commonAncestorTree.parent) {\n\t        var adjustedRelatedTarget;\n\t        for (var i = 0; i < relatedTargetEventPath.length; i++) {\n\t          var node = relatedTargetEventPath[i];\n\t          if (getTreeScope(node) === commonAncestorTree) return node;\n\t        }\n\t      }\n\t      return null;\n\t    }\n\t    function inSameTree(a, b) {\n\t      return getTreeScope(a) === getTreeScope(b);\n\t    }\n\t    var NONE = 0;\n\t    var CAPTURING_PHASE = 1;\n\t    var AT_TARGET = 2;\n\t    var BUBBLING_PHASE = 3;\n\t    var pendingError;\n\t    function dispatchOriginalEvent(originalEvent) {\n\t      if (handledEventsTable.get(originalEvent)) return;\n\t      handledEventsTable.set(originalEvent, true);\n\t      dispatchEvent(wrap(originalEvent), wrap(originalEvent.target));\n\t      if (pendingError) {\n\t        var err = pendingError;\n\t        pendingError = null;\n\t        throw err;\n\t      }\n\t    }\n\t    function isLoadLikeEvent(event) {\n\t      switch (event.type) {\n\t       case \"load\":\n\t       case \"beforeunload\":\n\t       case \"unload\":\n\t        return true;\n\t      }\n\t      return false;\n\t    }\n\t    function dispatchEvent(event, originalWrapperTarget) {\n\t      if (currentlyDispatchingEvents.get(event)) throw new Error(\"InvalidStateError\");\n\t      currentlyDispatchingEvents.set(event, true);\n\t      scope.renderAllPending();\n\t      var eventPath;\n\t      var overrideTarget;\n\t      var win;\n\t      if (isLoadLikeEvent(event) && !event.bubbles) {\n\t        var doc = originalWrapperTarget;\n\t        if (doc instanceof wrappers.Document && (win = doc.defaultView)) {\n\t          overrideTarget = doc;\n\t          eventPath = [];\n\t        }\n\t      }\n\t      if (!eventPath) {\n\t        if (originalWrapperTarget instanceof wrappers.Window) {\n\t          win = originalWrapperTarget;\n\t          eventPath = [];\n\t        } else {\n\t          eventPath = getEventPath(originalWrapperTarget, event);\n\t          if (!isLoadLikeEvent(event)) {\n\t            var doc = eventPath[eventPath.length - 1];\n\t            if (doc instanceof wrappers.Document) win = doc.defaultView;\n\t          }\n\t        }\n\t      }\n\t      eventPathTable.set(event, eventPath);\n\t      if (dispatchCapturing(event, eventPath, win, overrideTarget)) {\n\t        if (dispatchAtTarget(event, eventPath, win, overrideTarget)) {\n\t          dispatchBubbling(event, eventPath, win, overrideTarget);\n\t        }\n\t      }\n\t      eventPhaseTable.set(event, NONE);\n\t      currentTargetTable.delete(event, null);\n\t      currentlyDispatchingEvents.delete(event);\n\t      return event.defaultPrevented;\n\t    }\n\t    function dispatchCapturing(event, eventPath, win, overrideTarget) {\n\t      var phase = CAPTURING_PHASE;\n\t      if (win) {\n\t        if (!invoke(win, event, phase, eventPath, overrideTarget)) return false;\n\t      }\n\t      for (var i = eventPath.length - 1; i > 0; i--) {\n\t        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return false;\n\t      }\n\t      return true;\n\t    }\n\t    function dispatchAtTarget(event, eventPath, win, overrideTarget) {\n\t      var phase = AT_TARGET;\n\t      var currentTarget = eventPath[0] || win;\n\t      return invoke(currentTarget, event, phase, eventPath, overrideTarget);\n\t    }\n\t    function dispatchBubbling(event, eventPath, win, overrideTarget) {\n\t      var phase = BUBBLING_PHASE;\n\t      for (var i = 1; i < eventPath.length; i++) {\n\t        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return;\n\t      }\n\t      if (win && eventPath.length > 0) {\n\t        invoke(win, event, phase, eventPath, overrideTarget);\n\t      }\n\t    }\n\t    function invoke(currentTarget, event, phase, eventPath, overrideTarget) {\n\t      var listeners = listenersTable.get(currentTarget);\n\t      if (!listeners) return true;\n\t      var target = overrideTarget || eventRetargetting(eventPath, currentTarget);\n\t      if (target === currentTarget) {\n\t        if (phase === CAPTURING_PHASE) return true;\n\t        if (phase === BUBBLING_PHASE) phase = AT_TARGET;\n\t      } else if (phase === BUBBLING_PHASE && !event.bubbles) {\n\t        return true;\n\t      }\n\t      if (\"relatedTarget\" in event) {\n\t        var originalEvent = unwrap(event);\n\t        var unwrappedRelatedTarget = originalEvent.relatedTarget;\n\t        if (unwrappedRelatedTarget) {\n\t          if (unwrappedRelatedTarget instanceof Object && unwrappedRelatedTarget.addEventListener) {\n\t            var relatedTarget = wrap(unwrappedRelatedTarget);\n\t            var adjusted = relatedTargetResolution(event, currentTarget, relatedTarget);\n\t            if (adjusted === target) return true;\n\t          } else {\n\t            adjusted = null;\n\t          }\n\t          relatedTargetTable.set(event, adjusted);\n\t        }\n\t      }\n\t      eventPhaseTable.set(event, phase);\n\t      var type = event.type;\n\t      var anyRemoved = false;\n\t      targetTable.set(event, target);\n\t      currentTargetTable.set(event, currentTarget);\n\t      listeners.depth++;\n\t      for (var i = 0, len = listeners.length; i < len; i++) {\n\t        var listener = listeners[i];\n\t        if (listener.removed) {\n\t          anyRemoved = true;\n\t          continue;\n\t        }\n\t        if (listener.type !== type || !listener.capture && phase === CAPTURING_PHASE || listener.capture && phase === BUBBLING_PHASE) {\n\t          continue;\n\t        }\n\t        try {\n\t          if (typeof listener.handler === \"function\") listener.handler.call(currentTarget, event); else listener.handler.handleEvent(event);\n\t          if (stopImmediatePropagationTable.get(event)) return false;\n\t        } catch (ex) {\n\t          if (!pendingError) pendingError = ex;\n\t        }\n\t      }\n\t      listeners.depth--;\n\t      if (anyRemoved && listeners.depth === 0) {\n\t        var copy = listeners.slice();\n\t        listeners.length = 0;\n\t        for (var i = 0; i < copy.length; i++) {\n\t          if (!copy[i].removed) listeners.push(copy[i]);\n\t        }\n\t      }\n\t      return !stopPropagationTable.get(event);\n\t    }\n\t    function Listener(type, handler, capture) {\n\t      this.type = type;\n\t      this.handler = handler;\n\t      this.capture = Boolean(capture);\n\t    }\n\t    Listener.prototype = {\n\t      equals: function(that) {\n\t        return this.handler === that.handler && this.type === that.type && this.capture === that.capture;\n\t      },\n\t      get removed() {\n\t        return this.handler === null;\n\t      },\n\t      remove: function() {\n\t        this.handler = null;\n\t      }\n\t    };\n\t    var OriginalEvent = window.Event;\n\t    OriginalEvent.prototype.polymerBlackList_ = {\n\t      returnValue: true,\n\t      keyLocation: true\n\t    };\n\t    function Event(type, options) {\n\t      if (type instanceof OriginalEvent) {\n\t        var impl = type;\n\t        if (!OriginalBeforeUnloadEvent && impl.type === \"beforeunload\" && !(this instanceof BeforeUnloadEvent)) {\n\t          return new BeforeUnloadEvent(impl);\n\t        }\n\t        setWrapper(impl, this);\n\t      } else {\n\t        return wrap(constructEvent(OriginalEvent, \"Event\", type, options));\n\t      }\n\t    }\n\t    Event.prototype = {\n\t      get target() {\n\t        return targetTable.get(this);\n\t      },\n\t      get currentTarget() {\n\t        return currentTargetTable.get(this);\n\t      },\n\t      get eventPhase() {\n\t        return eventPhaseTable.get(this);\n\t      },\n\t      get path() {\n\t        var eventPath = eventPathTable.get(this);\n\t        if (!eventPath) return [];\n\t        return eventPath.slice();\n\t      },\n\t      stopPropagation: function() {\n\t        stopPropagationTable.set(this, true);\n\t      },\n\t      stopImmediatePropagation: function() {\n\t        stopPropagationTable.set(this, true);\n\t        stopImmediatePropagationTable.set(this, true);\n\t      }\n\t    };\n\t    var supportsDefaultPrevented = function() {\n\t      var e = document.createEvent(\"Event\");\n\t      e.initEvent(\"test\", true, true);\n\t      e.preventDefault();\n\t      return e.defaultPrevented;\n\t    }();\n\t    if (!supportsDefaultPrevented) {\n\t      Event.prototype.preventDefault = function() {\n\t        if (!this.cancelable) return;\n\t        unsafeUnwrap(this).preventDefault();\n\t        Object.defineProperty(this, \"defaultPrevented\", {\n\t          get: function() {\n\t            return true;\n\t          },\n\t          configurable: true\n\t        });\n\t      };\n\t    }\n\t    registerWrapper(OriginalEvent, Event, document.createEvent(\"Event\"));\n\t    function unwrapOptions(options) {\n\t      if (!options || !options.relatedTarget) return options;\n\t      return Object.create(options, {\n\t        relatedTarget: {\n\t          value: unwrap(options.relatedTarget)\n\t        }\n\t      });\n\t    }\n\t    function registerGenericEvent(name, SuperEvent, prototype) {\n\t      var OriginalEvent = window[name];\n\t      var GenericEvent = function(type, options) {\n\t        if (type instanceof OriginalEvent) setWrapper(type, this); else return wrap(constructEvent(OriginalEvent, name, type, options));\n\t      };\n\t      GenericEvent.prototype = Object.create(SuperEvent.prototype);\n\t      if (prototype) mixin(GenericEvent.prototype, prototype);\n\t      if (OriginalEvent) {\n\t        try {\n\t          registerWrapper(OriginalEvent, GenericEvent, new OriginalEvent(\"temp\"));\n\t        } catch (ex) {\n\t          registerWrapper(OriginalEvent, GenericEvent, document.createEvent(name));\n\t        }\n\t      }\n\t      return GenericEvent;\n\t    }\n\t    var UIEvent = registerGenericEvent(\"UIEvent\", Event);\n\t    var CustomEvent = registerGenericEvent(\"CustomEvent\", Event);\n\t    var relatedTargetProto = {\n\t      get relatedTarget() {\n\t        var relatedTarget = relatedTargetTable.get(this);\n\t        if (relatedTarget !== undefined) return relatedTarget;\n\t        return wrap(unwrap(this).relatedTarget);\n\t      }\n\t    };\n\t    function getInitFunction(name, relatedTargetIndex) {\n\t      return function() {\n\t        arguments[relatedTargetIndex] = unwrap(arguments[relatedTargetIndex]);\n\t        var impl = unwrap(this);\n\t        impl[name].apply(impl, arguments);\n\t      };\n\t    }\n\t    var mouseEventProto = mixin({\n\t      initMouseEvent: getInitFunction(\"initMouseEvent\", 14)\n\t    }, relatedTargetProto);\n\t    var focusEventProto = mixin({\n\t      initFocusEvent: getInitFunction(\"initFocusEvent\", 5)\n\t    }, relatedTargetProto);\n\t    var MouseEvent = registerGenericEvent(\"MouseEvent\", UIEvent, mouseEventProto);\n\t    var FocusEvent = registerGenericEvent(\"FocusEvent\", UIEvent, focusEventProto);\n\t    var defaultInitDicts = Object.create(null);\n\t    var supportsEventConstructors = function() {\n\t      try {\n\t        new window.FocusEvent(\"focus\");\n\t      } catch (ex) {\n\t        return false;\n\t      }\n\t      return true;\n\t    }();\n\t    function constructEvent(OriginalEvent, name, type, options) {\n\t      if (supportsEventConstructors) return new OriginalEvent(type, unwrapOptions(options));\n\t      var event = unwrap(document.createEvent(name));\n\t      var defaultDict = defaultInitDicts[name];\n\t      var args = [ type ];\n\t      Object.keys(defaultDict).forEach(function(key) {\n\t        var v = options != null && key in options ? options[key] : defaultDict[key];\n\t        if (key === \"relatedTarget\") v = unwrap(v);\n\t        args.push(v);\n\t      });\n\t      event[\"init\" + name].apply(event, args);\n\t      return event;\n\t    }\n\t    if (!supportsEventConstructors) {\n\t      var configureEventConstructor = function(name, initDict, superName) {\n\t        if (superName) {\n\t          var superDict = defaultInitDicts[superName];\n\t          initDict = mixin(mixin({}, superDict), initDict);\n\t        }\n\t        defaultInitDicts[name] = initDict;\n\t      };\n\t      configureEventConstructor(\"Event\", {\n\t        bubbles: false,\n\t        cancelable: false\n\t      });\n\t      configureEventConstructor(\"CustomEvent\", {\n\t        detail: null\n\t      }, \"Event\");\n\t      configureEventConstructor(\"UIEvent\", {\n\t        view: null,\n\t        detail: 0\n\t      }, \"Event\");\n\t      configureEventConstructor(\"MouseEvent\", {\n\t        screenX: 0,\n\t        screenY: 0,\n\t        clientX: 0,\n\t        clientY: 0,\n\t        ctrlKey: false,\n\t        altKey: false,\n\t        shiftKey: false,\n\t        metaKey: false,\n\t        button: 0,\n\t        relatedTarget: null\n\t      }, \"UIEvent\");\n\t      configureEventConstructor(\"FocusEvent\", {\n\t        relatedTarget: null\n\t      }, \"UIEvent\");\n\t    }\n\t    var OriginalBeforeUnloadEvent = window.BeforeUnloadEvent;\n\t    function BeforeUnloadEvent(impl) {\n\t      Event.call(this, impl);\n\t    }\n\t    BeforeUnloadEvent.prototype = Object.create(Event.prototype);\n\t    mixin(BeforeUnloadEvent.prototype, {\n\t      get returnValue() {\n\t        return unsafeUnwrap(this).returnValue;\n\t      },\n\t      set returnValue(v) {\n\t        unsafeUnwrap(this).returnValue = v;\n\t      }\n\t    });\n\t    if (OriginalBeforeUnloadEvent) registerWrapper(OriginalBeforeUnloadEvent, BeforeUnloadEvent);\n\t    function isValidListener(fun) {\n\t      if (typeof fun === \"function\") return true;\n\t      return fun && fun.handleEvent;\n\t    }\n\t    function isMutationEvent(type) {\n\t      switch (type) {\n\t       case \"DOMAttrModified\":\n\t       case \"DOMAttributeNameChanged\":\n\t       case \"DOMCharacterDataModified\":\n\t       case \"DOMElementNameChanged\":\n\t       case \"DOMNodeInserted\":\n\t       case \"DOMNodeInsertedIntoDocument\":\n\t       case \"DOMNodeRemoved\":\n\t       case \"DOMNodeRemovedFromDocument\":\n\t       case \"DOMSubtreeModified\":\n\t        return true;\n\t      }\n\t      return false;\n\t    }\n\t    var OriginalEventTarget = window.EventTarget;\n\t    function EventTarget(impl) {\n\t      setWrapper(impl, this);\n\t    }\n\t    var methodNames = [ \"addEventListener\", \"removeEventListener\", \"dispatchEvent\" ];\n\t    [ Node, Window ].forEach(function(constructor) {\n\t      var p = constructor.prototype;\n\t      methodNames.forEach(function(name) {\n\t        Object.defineProperty(p, name + \"_\", {\n\t          value: p[name]\n\t        });\n\t      });\n\t    });\n\t    function getTargetToListenAt(wrapper) {\n\t      if (wrapper instanceof wrappers.ShadowRoot) wrapper = wrapper.host;\n\t      return unwrap(wrapper);\n\t    }\n\t    EventTarget.prototype = {\n\t      addEventListener: function(type, fun, capture) {\n\t        if (!isValidListener(fun) || isMutationEvent(type)) return;\n\t        var listener = new Listener(type, fun, capture);\n\t        var listeners = listenersTable.get(this);\n\t        if (!listeners) {\n\t          listeners = [];\n\t          listeners.depth = 0;\n\t          listenersTable.set(this, listeners);\n\t        } else {\n\t          for (var i = 0; i < listeners.length; i++) {\n\t            if (listener.equals(listeners[i])) return;\n\t          }\n\t        }\n\t        listeners.push(listener);\n\t        var target = getTargetToListenAt(this);\n\t        target.addEventListener_(type, dispatchOriginalEvent, true);\n\t      },\n\t      removeEventListener: function(type, fun, capture) {\n\t        capture = Boolean(capture);\n\t        var listeners = listenersTable.get(this);\n\t        if (!listeners) return;\n\t        var count = 0, found = false;\n\t        for (var i = 0; i < listeners.length; i++) {\n\t          if (listeners[i].type === type && listeners[i].capture === capture) {\n\t            count++;\n\t            if (listeners[i].handler === fun) {\n\t              found = true;\n\t              listeners[i].remove();\n\t            }\n\t          }\n\t        }\n\t        if (found && count === 1) {\n\t          var target = getTargetToListenAt(this);\n\t          target.removeEventListener_(type, dispatchOriginalEvent, true);\n\t        }\n\t      },\n\t      dispatchEvent: function(event) {\n\t        var nativeEvent = unwrap(event);\n\t        var eventType = nativeEvent.type;\n\t        handledEventsTable.set(nativeEvent, false);\n\t        scope.renderAllPending();\n\t        var tempListener;\n\t        if (!hasListenerInAncestors(this, eventType)) {\n\t          tempListener = function() {};\n\t          this.addEventListener(eventType, tempListener, true);\n\t        }\n\t        try {\n\t          return unwrap(this).dispatchEvent_(nativeEvent);\n\t        } finally {\n\t          if (tempListener) this.removeEventListener(eventType, tempListener, true);\n\t        }\n\t      }\n\t    };\n\t    function hasListener(node, type) {\n\t      var listeners = listenersTable.get(node);\n\t      if (listeners) {\n\t        for (var i = 0; i < listeners.length; i++) {\n\t          if (!listeners[i].removed && listeners[i].type === type) return true;\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t    function hasListenerInAncestors(target, type) {\n\t      for (var node = unwrap(target); node; node = node.parentNode) {\n\t        if (hasListener(wrap(node), type)) return true;\n\t      }\n\t      return false;\n\t    }\n\t    if (OriginalEventTarget) registerWrapper(OriginalEventTarget, EventTarget);\n\t    function wrapEventTargetMethods(constructors) {\n\t      forwardMethodsToWrapper(constructors, methodNames);\n\t    }\n\t    var originalElementFromPoint = document.elementFromPoint;\n\t    function elementFromPoint(self, document, x, y) {\n\t      scope.renderAllPending();\n\t      var element = wrap(originalElementFromPoint.call(unsafeUnwrap(document), x, y));\n\t      if (!element) return null;\n\t      var path = getEventPath(element, null);\n\t      var idx = path.lastIndexOf(self);\n\t      if (idx == -1) return null; else path = path.slice(0, idx);\n\t      return eventRetargetting(path, self);\n\t    }\n\t    function getEventHandlerGetter(name) {\n\t      return function() {\n\t        var inlineEventHandlers = eventHandlersTable.get(this);\n\t        return inlineEventHandlers && inlineEventHandlers[name] && inlineEventHandlers[name].value || null;\n\t      };\n\t    }\n\t    function getEventHandlerSetter(name) {\n\t      var eventType = name.slice(2);\n\t      return function(value) {\n\t        var inlineEventHandlers = eventHandlersTable.get(this);\n\t        if (!inlineEventHandlers) {\n\t          inlineEventHandlers = Object.create(null);\n\t          eventHandlersTable.set(this, inlineEventHandlers);\n\t        }\n\t        var old = inlineEventHandlers[name];\n\t        if (old) this.removeEventListener(eventType, old.wrapped, false);\n\t        if (typeof value === \"function\") {\n\t          var wrapped = function(e) {\n\t            var rv = value.call(this, e);\n\t            if (rv === false) e.preventDefault(); else if (name === \"onbeforeunload\" && typeof rv === \"string\") e.returnValue = rv;\n\t          };\n\t          this.addEventListener(eventType, wrapped, false);\n\t          inlineEventHandlers[name] = {\n\t            value: value,\n\t            wrapped: wrapped\n\t          };\n\t        }\n\t      };\n\t    }\n\t    scope.elementFromPoint = elementFromPoint;\n\t    scope.getEventHandlerGetter = getEventHandlerGetter;\n\t    scope.getEventHandlerSetter = getEventHandlerSetter;\n\t    scope.wrapEventTargetMethods = wrapEventTargetMethods;\n\t    scope.wrappers.BeforeUnloadEvent = BeforeUnloadEvent;\n\t    scope.wrappers.CustomEvent = CustomEvent;\n\t    scope.wrappers.Event = Event;\n\t    scope.wrappers.EventTarget = EventTarget;\n\t    scope.wrappers.FocusEvent = FocusEvent;\n\t    scope.wrappers.MouseEvent = MouseEvent;\n\t    scope.wrappers.UIEvent = UIEvent;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var UIEvent = scope.wrappers.UIEvent;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var setWrapper = scope.setWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var wrap = scope.wrap;\n\t    var OriginalTouchEvent = window.TouchEvent;\n\t    if (!OriginalTouchEvent) return;\n\t    var nativeEvent;\n\t    try {\n\t      nativeEvent = document.createEvent(\"TouchEvent\");\n\t    } catch (ex) {\n\t      return;\n\t    }\n\t    var nonEnumDescriptor = {\n\t      enumerable: false\n\t    };\n\t    function nonEnum(obj, prop) {\n\t      Object.defineProperty(obj, prop, nonEnumDescriptor);\n\t    }\n\t    function Touch(impl) {\n\t      setWrapper(impl, this);\n\t    }\n\t    Touch.prototype = {\n\t      get target() {\n\t        return wrap(unsafeUnwrap(this).target);\n\t      }\n\t    };\n\t    var descr = {\n\t      configurable: true,\n\t      enumerable: true,\n\t      get: null\n\t    };\n\t    [ \"clientX\", \"clientY\", \"screenX\", \"screenY\", \"pageX\", \"pageY\", \"identifier\", \"webkitRadiusX\", \"webkitRadiusY\", \"webkitRotationAngle\", \"webkitForce\" ].forEach(function(name) {\n\t      descr.get = function() {\n\t        return unsafeUnwrap(this)[name];\n\t      };\n\t      Object.defineProperty(Touch.prototype, name, descr);\n\t    });\n\t    function TouchList() {\n\t      this.length = 0;\n\t      nonEnum(this, \"length\");\n\t    }\n\t    TouchList.prototype = {\n\t      item: function(index) {\n\t        return this[index];\n\t      }\n\t    };\n\t    function wrapTouchList(nativeTouchList) {\n\t      var list = new TouchList();\n\t      for (var i = 0; i < nativeTouchList.length; i++) {\n\t        list[i] = new Touch(nativeTouchList[i]);\n\t      }\n\t      list.length = i;\n\t      return list;\n\t    }\n\t    function TouchEvent(impl) {\n\t      UIEvent.call(this, impl);\n\t    }\n\t    TouchEvent.prototype = Object.create(UIEvent.prototype);\n\t    mixin(TouchEvent.prototype, {\n\t      get touches() {\n\t        return wrapTouchList(unsafeUnwrap(this).touches);\n\t      },\n\t      get targetTouches() {\n\t        return wrapTouchList(unsafeUnwrap(this).targetTouches);\n\t      },\n\t      get changedTouches() {\n\t        return wrapTouchList(unsafeUnwrap(this).changedTouches);\n\t      },\n\t      initTouchEvent: function() {\n\t        throw new Error(\"Not implemented\");\n\t      }\n\t    });\n\t    registerWrapper(OriginalTouchEvent, TouchEvent, nativeEvent);\n\t    scope.wrappers.Touch = Touch;\n\t    scope.wrappers.TouchEvent = TouchEvent;\n\t    scope.wrappers.TouchList = TouchList;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var wrap = scope.wrap;\n\t    var nonEnumDescriptor = {\n\t      enumerable: false\n\t    };\n\t    function nonEnum(obj, prop) {\n\t      Object.defineProperty(obj, prop, nonEnumDescriptor);\n\t    }\n\t    function NodeList() {\n\t      this.length = 0;\n\t      nonEnum(this, \"length\");\n\t    }\n\t    NodeList.prototype = {\n\t      item: function(index) {\n\t        return this[index];\n\t      }\n\t    };\n\t    nonEnum(NodeList.prototype, \"item\");\n\t    function wrapNodeList(list) {\n\t      if (list == null) return list;\n\t      var wrapperList = new NodeList();\n\t      for (var i = 0, length = list.length; i < length; i++) {\n\t        wrapperList[i] = wrap(list[i]);\n\t      }\n\t      wrapperList.length = length;\n\t      return wrapperList;\n\t    }\n\t    function addWrapNodeListMethod(wrapperConstructor, name) {\n\t      wrapperConstructor.prototype[name] = function() {\n\t        return wrapNodeList(unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments));\n\t      };\n\t    }\n\t    scope.wrappers.NodeList = NodeList;\n\t    scope.addWrapNodeListMethod = addWrapNodeListMethod;\n\t    scope.wrapNodeList = wrapNodeList;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    scope.wrapHTMLCollection = scope.wrapNodeList;\n\t    scope.wrappers.HTMLCollection = scope.wrappers.NodeList;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var EventTarget = scope.wrappers.EventTarget;\n\t    var NodeList = scope.wrappers.NodeList;\n\t    var TreeScope = scope.TreeScope;\n\t    var assert = scope.assert;\n\t    var defineWrapGetter = scope.defineWrapGetter;\n\t    var enqueueMutation = scope.enqueueMutation;\n\t    var getTreeScope = scope.getTreeScope;\n\t    var isWrapper = scope.isWrapper;\n\t    var mixin = scope.mixin;\n\t    var registerTransientObservers = scope.registerTransientObservers;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var setTreeScope = scope.setTreeScope;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrap = scope.unwrap;\n\t    var unwrapIfNeeded = scope.unwrapIfNeeded;\n\t    var wrap = scope.wrap;\n\t    var wrapIfNeeded = scope.wrapIfNeeded;\n\t    var wrappers = scope.wrappers;\n\t    function assertIsNodeWrapper(node) {\n\t      assert(node instanceof Node);\n\t    }\n\t    function createOneElementNodeList(node) {\n\t      var nodes = new NodeList();\n\t      nodes[0] = node;\n\t      nodes.length = 1;\n\t      return nodes;\n\t    }\n\t    var surpressMutations = false;\n\t    function enqueueRemovalForInsertedNodes(node, parent, nodes) {\n\t      enqueueMutation(parent, \"childList\", {\n\t        removedNodes: nodes,\n\t        previousSibling: node.previousSibling,\n\t        nextSibling: node.nextSibling\n\t      });\n\t    }\n\t    function enqueueRemovalForInsertedDocumentFragment(df, nodes) {\n\t      enqueueMutation(df, \"childList\", {\n\t        removedNodes: nodes\n\t      });\n\t    }\n\t    function collectNodes(node, parentNode, previousNode, nextNode) {\n\t      if (node instanceof DocumentFragment) {\n\t        var nodes = collectNodesForDocumentFragment(node);\n\t        surpressMutations = true;\n\t        for (var i = nodes.length - 1; i >= 0; i--) {\n\t          node.removeChild(nodes[i]);\n\t          nodes[i].parentNode_ = parentNode;\n\t        }\n\t        surpressMutations = false;\n\t        for (var i = 0; i < nodes.length; i++) {\n\t          nodes[i].previousSibling_ = nodes[i - 1] || previousNode;\n\t          nodes[i].nextSibling_ = nodes[i + 1] || nextNode;\n\t        }\n\t        if (previousNode) previousNode.nextSibling_ = nodes[0];\n\t        if (nextNode) nextNode.previousSibling_ = nodes[nodes.length - 1];\n\t        return nodes;\n\t      }\n\t      var nodes = createOneElementNodeList(node);\n\t      var oldParent = node.parentNode;\n\t      if (oldParent) {\n\t        oldParent.removeChild(node);\n\t      }\n\t      node.parentNode_ = parentNode;\n\t      node.previousSibling_ = previousNode;\n\t      node.nextSibling_ = nextNode;\n\t      if (previousNode) previousNode.nextSibling_ = node;\n\t      if (nextNode) nextNode.previousSibling_ = node;\n\t      return nodes;\n\t    }\n\t    function collectNodesNative(node) {\n\t      if (node instanceof DocumentFragment) return collectNodesForDocumentFragment(node);\n\t      var nodes = createOneElementNodeList(node);\n\t      var oldParent = node.parentNode;\n\t      if (oldParent) enqueueRemovalForInsertedNodes(node, oldParent, nodes);\n\t      return nodes;\n\t    }\n\t    function collectNodesForDocumentFragment(node) {\n\t      var nodes = new NodeList();\n\t      var i = 0;\n\t      for (var child = node.firstChild; child; child = child.nextSibling) {\n\t        nodes[i++] = child;\n\t      }\n\t      nodes.length = i;\n\t      enqueueRemovalForInsertedDocumentFragment(node, nodes);\n\t      return nodes;\n\t    }\n\t    function snapshotNodeList(nodeList) {\n\t      return nodeList;\n\t    }\n\t    function nodeWasAdded(node, treeScope) {\n\t      setTreeScope(node, treeScope);\n\t      node.nodeIsInserted_();\n\t    }\n\t    function nodesWereAdded(nodes, parent) {\n\t      var treeScope = getTreeScope(parent);\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        nodeWasAdded(nodes[i], treeScope);\n\t      }\n\t    }\n\t    function nodeWasRemoved(node) {\n\t      setTreeScope(node, new TreeScope(node, null));\n\t    }\n\t    function nodesWereRemoved(nodes) {\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        nodeWasRemoved(nodes[i]);\n\t      }\n\t    }\n\t    function ensureSameOwnerDocument(parent, child) {\n\t      var ownerDoc = parent.nodeType === Node.DOCUMENT_NODE ? parent : parent.ownerDocument;\n\t      if (ownerDoc !== child.ownerDocument) ownerDoc.adoptNode(child);\n\t    }\n\t    function adoptNodesIfNeeded(owner, nodes) {\n\t      if (!nodes.length) return;\n\t      var ownerDoc = owner.ownerDocument;\n\t      if (ownerDoc === nodes[0].ownerDocument) return;\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        scope.adoptNodeNoRemove(nodes[i], ownerDoc);\n\t      }\n\t    }\n\t    function unwrapNodesForInsertion(owner, nodes) {\n\t      adoptNodesIfNeeded(owner, nodes);\n\t      var length = nodes.length;\n\t      if (length === 1) return unwrap(nodes[0]);\n\t      var df = unwrap(owner.ownerDocument.createDocumentFragment());\n\t      for (var i = 0; i < length; i++) {\n\t        df.appendChild(unwrap(nodes[i]));\n\t      }\n\t      return df;\n\t    }\n\t    function clearChildNodes(wrapper) {\n\t      if (wrapper.firstChild_ !== undefined) {\n\t        var child = wrapper.firstChild_;\n\t        while (child) {\n\t          var tmp = child;\n\t          child = child.nextSibling_;\n\t          tmp.parentNode_ = tmp.previousSibling_ = tmp.nextSibling_ = undefined;\n\t        }\n\t      }\n\t      wrapper.firstChild_ = wrapper.lastChild_ = undefined;\n\t    }\n\t    function removeAllChildNodes(wrapper) {\n\t      if (wrapper.invalidateShadowRenderer()) {\n\t        var childWrapper = wrapper.firstChild;\n\t        while (childWrapper) {\n\t          assert(childWrapper.parentNode === wrapper);\n\t          var nextSibling = childWrapper.nextSibling;\n\t          var childNode = unwrap(childWrapper);\n\t          var parentNode = childNode.parentNode;\n\t          if (parentNode) originalRemoveChild.call(parentNode, childNode);\n\t          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;\n\t          childWrapper = nextSibling;\n\t        }\n\t        wrapper.firstChild_ = wrapper.lastChild_ = null;\n\t      } else {\n\t        var node = unwrap(wrapper);\n\t        var child = node.firstChild;\n\t        var nextSibling;\n\t        while (child) {\n\t          nextSibling = child.nextSibling;\n\t          originalRemoveChild.call(node, child);\n\t          child = nextSibling;\n\t        }\n\t      }\n\t    }\n\t    function invalidateParent(node) {\n\t      var p = node.parentNode;\n\t      return p && p.invalidateShadowRenderer();\n\t    }\n\t    function cleanupNodes(nodes) {\n\t      for (var i = 0, n; i < nodes.length; i++) {\n\t        n = nodes[i];\n\t        n.parentNode.removeChild(n);\n\t      }\n\t    }\n\t    var originalImportNode = document.importNode;\n\t    var originalCloneNode = window.Node.prototype.cloneNode;\n\t    function cloneNode(node, deep, opt_doc) {\n\t      var clone;\n\t      if (opt_doc) clone = wrap(originalImportNode.call(opt_doc, unsafeUnwrap(node), false)); else clone = wrap(originalCloneNode.call(unsafeUnwrap(node), false));\n\t      if (deep) {\n\t        for (var child = node.firstChild; child; child = child.nextSibling) {\n\t          clone.appendChild(cloneNode(child, true, opt_doc));\n\t        }\n\t        if (node instanceof wrappers.HTMLTemplateElement) {\n\t          var cloneContent = clone.content;\n\t          for (var child = node.content.firstChild; child; child = child.nextSibling) {\n\t            cloneContent.appendChild(cloneNode(child, true, opt_doc));\n\t          }\n\t        }\n\t      }\n\t      return clone;\n\t    }\n\t    function contains(self, child) {\n\t      if (!child || getTreeScope(self) !== getTreeScope(child)) return false;\n\t      for (var node = child; node; node = node.parentNode) {\n\t        if (node === self) return true;\n\t      }\n\t      return false;\n\t    }\n\t    var OriginalNode = window.Node;\n\t    function Node(original) {\n\t      assert(original instanceof OriginalNode);\n\t      EventTarget.call(this, original);\n\t      this.parentNode_ = undefined;\n\t      this.firstChild_ = undefined;\n\t      this.lastChild_ = undefined;\n\t      this.nextSibling_ = undefined;\n\t      this.previousSibling_ = undefined;\n\t      this.treeScope_ = undefined;\n\t    }\n\t    var OriginalDocumentFragment = window.DocumentFragment;\n\t    var originalAppendChild = OriginalNode.prototype.appendChild;\n\t    var originalCompareDocumentPosition = OriginalNode.prototype.compareDocumentPosition;\n\t    var originalIsEqualNode = OriginalNode.prototype.isEqualNode;\n\t    var originalInsertBefore = OriginalNode.prototype.insertBefore;\n\t    var originalRemoveChild = OriginalNode.prototype.removeChild;\n\t    var originalReplaceChild = OriginalNode.prototype.replaceChild;\n\t    var isIEOrEdge = /Trident|Edge/.test(navigator.userAgent);\n\t    var removeChildOriginalHelper = isIEOrEdge ? function(parent, child) {\n\t      try {\n\t        originalRemoveChild.call(parent, child);\n\t      } catch (ex) {\n\t        if (!(parent instanceof OriginalDocumentFragment)) throw ex;\n\t      }\n\t    } : function(parent, child) {\n\t      originalRemoveChild.call(parent, child);\n\t    };\n\t    Node.prototype = Object.create(EventTarget.prototype);\n\t    mixin(Node.prototype, {\n\t      appendChild: function(childWrapper) {\n\t        return this.insertBefore(childWrapper, null);\n\t      },\n\t      insertBefore: function(childWrapper, refWrapper) {\n\t        assertIsNodeWrapper(childWrapper);\n\t        var refNode;\n\t        if (refWrapper) {\n\t          if (isWrapper(refWrapper)) {\n\t            refNode = unwrap(refWrapper);\n\t          } else {\n\t            refNode = refWrapper;\n\t            refWrapper = wrap(refNode);\n\t          }\n\t        } else {\n\t          refWrapper = null;\n\t          refNode = null;\n\t        }\n\t        refWrapper && assert(refWrapper.parentNode === this);\n\t        var nodes;\n\t        var previousNode = refWrapper ? refWrapper.previousSibling : this.lastChild;\n\t        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(childWrapper);\n\t        if (useNative) nodes = collectNodesNative(childWrapper); else nodes = collectNodes(childWrapper, this, previousNode, refWrapper);\n\t        if (useNative) {\n\t          ensureSameOwnerDocument(this, childWrapper);\n\t          clearChildNodes(this);\n\t          originalInsertBefore.call(unsafeUnwrap(this), unwrap(childWrapper), refNode);\n\t        } else {\n\t          if (!previousNode) this.firstChild_ = nodes[0];\n\t          if (!refWrapper) {\n\t            this.lastChild_ = nodes[nodes.length - 1];\n\t            if (this.firstChild_ === undefined) this.firstChild_ = this.firstChild;\n\t          }\n\t          var parentNode = refNode ? refNode.parentNode : unsafeUnwrap(this);\n\t          if (parentNode) {\n\t            originalInsertBefore.call(parentNode, unwrapNodesForInsertion(this, nodes), refNode);\n\t          } else {\n\t            adoptNodesIfNeeded(this, nodes);\n\t          }\n\t        }\n\t        enqueueMutation(this, \"childList\", {\n\t          addedNodes: nodes,\n\t          nextSibling: refWrapper,\n\t          previousSibling: previousNode\n\t        });\n\t        nodesWereAdded(nodes, this);\n\t        return childWrapper;\n\t      },\n\t      removeChild: function(childWrapper) {\n\t        assertIsNodeWrapper(childWrapper);\n\t        if (childWrapper.parentNode !== this) {\n\t          var found = false;\n\t          var childNodes = this.childNodes;\n\t          for (var ieChild = this.firstChild; ieChild; ieChild = ieChild.nextSibling) {\n\t            if (ieChild === childWrapper) {\n\t              found = true;\n\t              break;\n\t            }\n\t          }\n\t          if (!found) {\n\t            throw new Error(\"NotFoundError\");\n\t          }\n\t        }\n\t        var childNode = unwrap(childWrapper);\n\t        var childWrapperNextSibling = childWrapper.nextSibling;\n\t        var childWrapperPreviousSibling = childWrapper.previousSibling;\n\t        if (this.invalidateShadowRenderer()) {\n\t          var thisFirstChild = this.firstChild;\n\t          var thisLastChild = this.lastChild;\n\t          var parentNode = childNode.parentNode;\n\t          if (parentNode) removeChildOriginalHelper(parentNode, childNode);\n\t          if (thisFirstChild === childWrapper) this.firstChild_ = childWrapperNextSibling;\n\t          if (thisLastChild === childWrapper) this.lastChild_ = childWrapperPreviousSibling;\n\t          if (childWrapperPreviousSibling) childWrapperPreviousSibling.nextSibling_ = childWrapperNextSibling;\n\t          if (childWrapperNextSibling) {\n\t            childWrapperNextSibling.previousSibling_ = childWrapperPreviousSibling;\n\t          }\n\t          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = undefined;\n\t        } else {\n\t          clearChildNodes(this);\n\t          removeChildOriginalHelper(unsafeUnwrap(this), childNode);\n\t        }\n\t        if (!surpressMutations) {\n\t          enqueueMutation(this, \"childList\", {\n\t            removedNodes: createOneElementNodeList(childWrapper),\n\t            nextSibling: childWrapperNextSibling,\n\t            previousSibling: childWrapperPreviousSibling\n\t          });\n\t        }\n\t        registerTransientObservers(this, childWrapper);\n\t        return childWrapper;\n\t      },\n\t      replaceChild: function(newChildWrapper, oldChildWrapper) {\n\t        assertIsNodeWrapper(newChildWrapper);\n\t        var oldChildNode;\n\t        if (isWrapper(oldChildWrapper)) {\n\t          oldChildNode = unwrap(oldChildWrapper);\n\t        } else {\n\t          oldChildNode = oldChildWrapper;\n\t          oldChildWrapper = wrap(oldChildNode);\n\t        }\n\t        if (oldChildWrapper.parentNode !== this) {\n\t          throw new Error(\"NotFoundError\");\n\t        }\n\t        var nextNode = oldChildWrapper.nextSibling;\n\t        var previousNode = oldChildWrapper.previousSibling;\n\t        var nodes;\n\t        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(newChildWrapper);\n\t        if (useNative) {\n\t          nodes = collectNodesNative(newChildWrapper);\n\t        } else {\n\t          if (nextNode === newChildWrapper) nextNode = newChildWrapper.nextSibling;\n\t          nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);\n\t        }\n\t        if (!useNative) {\n\t          if (this.firstChild === oldChildWrapper) this.firstChild_ = nodes[0];\n\t          if (this.lastChild === oldChildWrapper) this.lastChild_ = nodes[nodes.length - 1];\n\t          oldChildWrapper.previousSibling_ = oldChildWrapper.nextSibling_ = oldChildWrapper.parentNode_ = undefined;\n\t          if (oldChildNode.parentNode) {\n\t            originalReplaceChild.call(oldChildNode.parentNode, unwrapNodesForInsertion(this, nodes), oldChildNode);\n\t          }\n\t        } else {\n\t          ensureSameOwnerDocument(this, newChildWrapper);\n\t          clearChildNodes(this);\n\t          originalReplaceChild.call(unsafeUnwrap(this), unwrap(newChildWrapper), oldChildNode);\n\t        }\n\t        enqueueMutation(this, \"childList\", {\n\t          addedNodes: nodes,\n\t          removedNodes: createOneElementNodeList(oldChildWrapper),\n\t          nextSibling: nextNode,\n\t          previousSibling: previousNode\n\t        });\n\t        nodeWasRemoved(oldChildWrapper);\n\t        nodesWereAdded(nodes, this);\n\t        return oldChildWrapper;\n\t      },\n\t      nodeIsInserted_: function() {\n\t        for (var child = this.firstChild; child; child = child.nextSibling) {\n\t          child.nodeIsInserted_();\n\t        }\n\t      },\n\t      hasChildNodes: function() {\n\t        return this.firstChild !== null;\n\t      },\n\t      get parentNode() {\n\t        return this.parentNode_ !== undefined ? this.parentNode_ : wrap(unsafeUnwrap(this).parentNode);\n\t      },\n\t      get firstChild() {\n\t        return this.firstChild_ !== undefined ? this.firstChild_ : wrap(unsafeUnwrap(this).firstChild);\n\t      },\n\t      get lastChild() {\n\t        return this.lastChild_ !== undefined ? this.lastChild_ : wrap(unsafeUnwrap(this).lastChild);\n\t      },\n\t      get nextSibling() {\n\t        return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(unsafeUnwrap(this).nextSibling);\n\t      },\n\t      get previousSibling() {\n\t        return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(unsafeUnwrap(this).previousSibling);\n\t      },\n\t      get parentElement() {\n\t        var p = this.parentNode;\n\t        while (p && p.nodeType !== Node.ELEMENT_NODE) {\n\t          p = p.parentNode;\n\t        }\n\t        return p;\n\t      },\n\t      get textContent() {\n\t        var s = \"\";\n\t        for (var child = this.firstChild; child; child = child.nextSibling) {\n\t          if (child.nodeType != Node.COMMENT_NODE) {\n\t            s += child.textContent;\n\t          }\n\t        }\n\t        return s;\n\t      },\n\t      set textContent(textContent) {\n\t        if (textContent == null) textContent = \"\";\n\t        var removedNodes = snapshotNodeList(this.childNodes);\n\t        if (this.invalidateShadowRenderer()) {\n\t          removeAllChildNodes(this);\n\t          if (textContent !== \"\") {\n\t            var textNode = unsafeUnwrap(this).ownerDocument.createTextNode(textContent);\n\t            this.appendChild(textNode);\n\t          }\n\t        } else {\n\t          clearChildNodes(this);\n\t          unsafeUnwrap(this).textContent = textContent;\n\t        }\n\t        var addedNodes = snapshotNodeList(this.childNodes);\n\t        enqueueMutation(this, \"childList\", {\n\t          addedNodes: addedNodes,\n\t          removedNodes: removedNodes\n\t        });\n\t        nodesWereRemoved(removedNodes);\n\t        nodesWereAdded(addedNodes, this);\n\t      },\n\t      get childNodes() {\n\t        var wrapperList = new NodeList();\n\t        var i = 0;\n\t        for (var child = this.firstChild; child; child = child.nextSibling) {\n\t          wrapperList[i++] = child;\n\t        }\n\t        wrapperList.length = i;\n\t        return wrapperList;\n\t      },\n\t      cloneNode: function(deep) {\n\t        return cloneNode(this, deep);\n\t      },\n\t      contains: function(child) {\n\t        return contains(this, wrapIfNeeded(child));\n\t      },\n\t      compareDocumentPosition: function(otherNode) {\n\t        return originalCompareDocumentPosition.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\n\t      },\n\t      isEqualNode: function(otherNode) {\n\t        return originalIsEqualNode.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\n\t      },\n\t      normalize: function() {\n\t        var nodes = snapshotNodeList(this.childNodes);\n\t        var remNodes = [];\n\t        var s = \"\";\n\t        var modNode;\n\t        for (var i = 0, n; i < nodes.length; i++) {\n\t          n = nodes[i];\n\t          if (n.nodeType === Node.TEXT_NODE) {\n\t            if (!modNode && !n.data.length) this.removeChild(n); else if (!modNode) modNode = n; else {\n\t              s += n.data;\n\t              remNodes.push(n);\n\t            }\n\t          } else {\n\t            if (modNode && remNodes.length) {\n\t              modNode.data += s;\n\t              cleanupNodes(remNodes);\n\t            }\n\t            remNodes = [];\n\t            s = \"\";\n\t            modNode = null;\n\t            if (n.childNodes.length) n.normalize();\n\t          }\n\t        }\n\t        if (modNode && remNodes.length) {\n\t          modNode.data += s;\n\t          cleanupNodes(remNodes);\n\t        }\n\t      }\n\t    });\n\t    defineWrapGetter(Node, \"ownerDocument\");\n\t    registerWrapper(OriginalNode, Node, document.createDocumentFragment());\n\t    delete Node.prototype.querySelector;\n\t    delete Node.prototype.querySelectorAll;\n\t    Node.prototype = mixin(Object.create(EventTarget.prototype), Node.prototype);\n\t    scope.cloneNode = cloneNode;\n\t    scope.nodeWasAdded = nodeWasAdded;\n\t    scope.nodeWasRemoved = nodeWasRemoved;\n\t    scope.nodesWereAdded = nodesWereAdded;\n\t    scope.nodesWereRemoved = nodesWereRemoved;\n\t    scope.originalInsertBefore = originalInsertBefore;\n\t    scope.originalRemoveChild = originalRemoveChild;\n\t    scope.snapshotNodeList = snapshotNodeList;\n\t    scope.wrappers.Node = Node;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLCollection = scope.wrappers.HTMLCollection;\n\t    var NodeList = scope.wrappers.NodeList;\n\t    var getTreeScope = scope.getTreeScope;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var wrap = scope.wrap;\n\t    var originalDocumentQuerySelector = document.querySelector;\n\t    var originalElementQuerySelector = document.documentElement.querySelector;\n\t    var originalDocumentQuerySelectorAll = document.querySelectorAll;\n\t    var originalElementQuerySelectorAll = document.documentElement.querySelectorAll;\n\t    var originalDocumentGetElementsByTagName = document.getElementsByTagName;\n\t    var originalElementGetElementsByTagName = document.documentElement.getElementsByTagName;\n\t    var originalDocumentGetElementsByTagNameNS = document.getElementsByTagNameNS;\n\t    var originalElementGetElementsByTagNameNS = document.documentElement.getElementsByTagNameNS;\n\t    var OriginalElement = window.Element;\n\t    var OriginalDocument = window.HTMLDocument || window.Document;\n\t    function filterNodeList(list, index, result, deep) {\n\t      var wrappedItem = null;\n\t      var root = null;\n\t      for (var i = 0, length = list.length; i < length; i++) {\n\t        wrappedItem = wrap(list[i]);\n\t        if (!deep && (root = getTreeScope(wrappedItem).root)) {\n\t          if (root instanceof scope.wrappers.ShadowRoot) {\n\t            continue;\n\t          }\n\t        }\n\t        result[index++] = wrappedItem;\n\t      }\n\t      return index;\n\t    }\n\t    function shimSelector(selector) {\n\t      return String(selector).replace(/\\/deep\\/|::shadow|>>>/g, \" \");\n\t    }\n\t    function shimMatchesSelector(selector) {\n\t      return String(selector).replace(/:host\\(([^\\s]+)\\)/g, \"$1\").replace(/([^\\s]):host/g, \"$1\").replace(\":host\", \"*\").replace(/\\^|\\/shadow\\/|\\/shadow-deep\\/|::shadow|\\/deep\\/|::content|>>>/g, \" \");\n\t    }\n\t    function findOne(node, selector) {\n\t      var m, el = node.firstElementChild;\n\t      while (el) {\n\t        if (el.matches(selector)) return el;\n\t        m = findOne(el, selector);\n\t        if (m) return m;\n\t        el = el.nextElementSibling;\n\t      }\n\t      return null;\n\t    }\n\t    function matchesSelector(el, selector) {\n\t      return el.matches(selector);\n\t    }\n\t    var XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n\t    function matchesTagName(el, localName, localNameLowerCase) {\n\t      var ln = el.localName;\n\t      return ln === localName || ln === localNameLowerCase && el.namespaceURI === XHTML_NS;\n\t    }\n\t    function matchesEveryThing() {\n\t      return true;\n\t    }\n\t    function matchesLocalNameOnly(el, ns, localName) {\n\t      return el.localName === localName;\n\t    }\n\t    function matchesNameSpace(el, ns) {\n\t      return el.namespaceURI === ns;\n\t    }\n\t    function matchesLocalNameNS(el, ns, localName) {\n\t      return el.namespaceURI === ns && el.localName === localName;\n\t    }\n\t    function findElements(node, index, result, p, arg0, arg1) {\n\t      var el = node.firstElementChild;\n\t      while (el) {\n\t        if (p(el, arg0, arg1)) result[index++] = el;\n\t        index = findElements(el, index, result, p, arg0, arg1);\n\t        el = el.nextElementSibling;\n\t      }\n\t      return index;\n\t    }\n\t    function querySelectorAllFiltered(p, index, result, selector, deep) {\n\t      var target = unsafeUnwrap(this);\n\t      var list;\n\t      var root = getTreeScope(this).root;\n\t      if (root instanceof scope.wrappers.ShadowRoot) {\n\t        return findElements(this, index, result, p, selector, null);\n\t      } else if (target instanceof OriginalElement) {\n\t        list = originalElementQuerySelectorAll.call(target, selector);\n\t      } else if (target instanceof OriginalDocument) {\n\t        list = originalDocumentQuerySelectorAll.call(target, selector);\n\t      } else {\n\t        return findElements(this, index, result, p, selector, null);\n\t      }\n\t      return filterNodeList(list, index, result, deep);\n\t    }\n\t    var SelectorsInterface = {\n\t      querySelector: function(selector) {\n\t        var shimmed = shimSelector(selector);\n\t        var deep = shimmed !== selector;\n\t        selector = shimmed;\n\t        var target = unsafeUnwrap(this);\n\t        var wrappedItem;\n\t        var root = getTreeScope(this).root;\n\t        if (root instanceof scope.wrappers.ShadowRoot) {\n\t          return findOne(this, selector);\n\t        } else if (target instanceof OriginalElement) {\n\t          wrappedItem = wrap(originalElementQuerySelector.call(target, selector));\n\t        } else if (target instanceof OriginalDocument) {\n\t          wrappedItem = wrap(originalDocumentQuerySelector.call(target, selector));\n\t        } else {\n\t          return findOne(this, selector);\n\t        }\n\t        if (!wrappedItem) {\n\t          return wrappedItem;\n\t        } else if (!deep && (root = getTreeScope(wrappedItem).root)) {\n\t          if (root instanceof scope.wrappers.ShadowRoot) {\n\t            return findOne(this, selector);\n\t          }\n\t        }\n\t        return wrappedItem;\n\t      },\n\t      querySelectorAll: function(selector) {\n\t        var shimmed = shimSelector(selector);\n\t        var deep = shimmed !== selector;\n\t        selector = shimmed;\n\t        var result = new NodeList();\n\t        result.length = querySelectorAllFiltered.call(this, matchesSelector, 0, result, selector, deep);\n\t        return result;\n\t      }\n\t    };\n\t    var MatchesInterface = {\n\t      matches: function(selector) {\n\t        selector = shimMatchesSelector(selector);\n\t        return scope.originalMatches.call(unsafeUnwrap(this), selector);\n\t      }\n\t    };\n\t    function getElementsByTagNameFiltered(p, index, result, localName, lowercase) {\n\t      var target = unsafeUnwrap(this);\n\t      var list;\n\t      var root = getTreeScope(this).root;\n\t      if (root instanceof scope.wrappers.ShadowRoot) {\n\t        return findElements(this, index, result, p, localName, lowercase);\n\t      } else if (target instanceof OriginalElement) {\n\t        list = originalElementGetElementsByTagName.call(target, localName, lowercase);\n\t      } else if (target instanceof OriginalDocument) {\n\t        list = originalDocumentGetElementsByTagName.call(target, localName, lowercase);\n\t      } else {\n\t        return findElements(this, index, result, p, localName, lowercase);\n\t      }\n\t      return filterNodeList(list, index, result, false);\n\t    }\n\t    function getElementsByTagNameNSFiltered(p, index, result, ns, localName) {\n\t      var target = unsafeUnwrap(this);\n\t      var list;\n\t      var root = getTreeScope(this).root;\n\t      if (root instanceof scope.wrappers.ShadowRoot) {\n\t        return findElements(this, index, result, p, ns, localName);\n\t      } else if (target instanceof OriginalElement) {\n\t        list = originalElementGetElementsByTagNameNS.call(target, ns, localName);\n\t      } else if (target instanceof OriginalDocument) {\n\t        list = originalDocumentGetElementsByTagNameNS.call(target, ns, localName);\n\t      } else {\n\t        return findElements(this, index, result, p, ns, localName);\n\t      }\n\t      return filterNodeList(list, index, result, false);\n\t    }\n\t    var GetElementsByInterface = {\n\t      getElementsByTagName: function(localName) {\n\t        var result = new HTMLCollection();\n\t        var match = localName === \"*\" ? matchesEveryThing : matchesTagName;\n\t        result.length = getElementsByTagNameFiltered.call(this, match, 0, result, localName, localName.toLowerCase());\n\t        return result;\n\t      },\n\t      getElementsByClassName: function(className) {\n\t        return this.querySelectorAll(\".\" + className);\n\t      },\n\t      getElementsByTagNameNS: function(ns, localName) {\n\t        var result = new HTMLCollection();\n\t        var match = null;\n\t        if (ns === \"*\") {\n\t          match = localName === \"*\" ? matchesEveryThing : matchesLocalNameOnly;\n\t        } else {\n\t          match = localName === \"*\" ? matchesNameSpace : matchesLocalNameNS;\n\t        }\n\t        result.length = getElementsByTagNameNSFiltered.call(this, match, 0, result, ns || null, localName);\n\t        return result;\n\t      }\n\t    };\n\t    scope.GetElementsByInterface = GetElementsByInterface;\n\t    scope.SelectorsInterface = SelectorsInterface;\n\t    scope.MatchesInterface = MatchesInterface;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var NodeList = scope.wrappers.NodeList;\n\t    function forwardElement(node) {\n\t      while (node && node.nodeType !== Node.ELEMENT_NODE) {\n\t        node = node.nextSibling;\n\t      }\n\t      return node;\n\t    }\n\t    function backwardsElement(node) {\n\t      while (node && node.nodeType !== Node.ELEMENT_NODE) {\n\t        node = node.previousSibling;\n\t      }\n\t      return node;\n\t    }\n\t    var ParentNodeInterface = {\n\t      get firstElementChild() {\n\t        return forwardElement(this.firstChild);\n\t      },\n\t      get lastElementChild() {\n\t        return backwardsElement(this.lastChild);\n\t      },\n\t      get childElementCount() {\n\t        var count = 0;\n\t        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n\t          count++;\n\t        }\n\t        return count;\n\t      },\n\t      get children() {\n\t        var wrapperList = new NodeList();\n\t        var i = 0;\n\t        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n\t          wrapperList[i++] = child;\n\t        }\n\t        wrapperList.length = i;\n\t        return wrapperList;\n\t      },\n\t      remove: function() {\n\t        var p = this.parentNode;\n\t        if (p) p.removeChild(this);\n\t      }\n\t    };\n\t    var ChildNodeInterface = {\n\t      get nextElementSibling() {\n\t        return forwardElement(this.nextSibling);\n\t      },\n\t      get previousElementSibling() {\n\t        return backwardsElement(this.previousSibling);\n\t      }\n\t    };\n\t    var NonElementParentNodeInterface = {\n\t      getElementById: function(id) {\n\t        if (/[ \\t\\n\\r\\f]/.test(id)) return null;\n\t        return this.querySelector('[id=\"' + id + '\"]');\n\t      }\n\t    };\n\t    scope.ChildNodeInterface = ChildNodeInterface;\n\t    scope.NonElementParentNodeInterface = NonElementParentNodeInterface;\n\t    scope.ParentNodeInterface = ParentNodeInterface;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var ChildNodeInterface = scope.ChildNodeInterface;\n\t    var Node = scope.wrappers.Node;\n\t    var enqueueMutation = scope.enqueueMutation;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var OriginalCharacterData = window.CharacterData;\n\t    function CharacterData(node) {\n\t      Node.call(this, node);\n\t    }\n\t    CharacterData.prototype = Object.create(Node.prototype);\n\t    mixin(CharacterData.prototype, {\n\t      get nodeValue() {\n\t        return this.data;\n\t      },\n\t      set nodeValue(data) {\n\t        this.data = data;\n\t      },\n\t      get textContent() {\n\t        return this.data;\n\t      },\n\t      set textContent(value) {\n\t        this.data = value;\n\t      },\n\t      get data() {\n\t        return unsafeUnwrap(this).data;\n\t      },\n\t      set data(value) {\n\t        var oldValue = unsafeUnwrap(this).data;\n\t        enqueueMutation(this, \"characterData\", {\n\t          oldValue: oldValue\n\t        });\n\t        unsafeUnwrap(this).data = value;\n\t      }\n\t    });\n\t    mixin(CharacterData.prototype, ChildNodeInterface);\n\t    registerWrapper(OriginalCharacterData, CharacterData, document.createTextNode(\"\"));\n\t    scope.wrappers.CharacterData = CharacterData;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var CharacterData = scope.wrappers.CharacterData;\n\t    var enqueueMutation = scope.enqueueMutation;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    function toUInt32(x) {\n\t      return x >>> 0;\n\t    }\n\t    var OriginalText = window.Text;\n\t    function Text(node) {\n\t      CharacterData.call(this, node);\n\t    }\n\t    Text.prototype = Object.create(CharacterData.prototype);\n\t    mixin(Text.prototype, {\n\t      splitText: function(offset) {\n\t        offset = toUInt32(offset);\n\t        var s = this.data;\n\t        if (offset > s.length) throw new Error(\"IndexSizeError\");\n\t        var head = s.slice(0, offset);\n\t        var tail = s.slice(offset);\n\t        this.data = head;\n\t        var newTextNode = this.ownerDocument.createTextNode(tail);\n\t        if (this.parentNode) this.parentNode.insertBefore(newTextNode, this.nextSibling);\n\t        return newTextNode;\n\t      }\n\t    });\n\t    registerWrapper(OriginalText, Text, document.createTextNode(\"\"));\n\t    scope.wrappers.Text = Text;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    if (!window.DOMTokenList) {\n\t      console.warn(\"Missing DOMTokenList prototype, please include a \" + \"compatible classList polyfill such as http://goo.gl/uTcepH.\");\n\t      return;\n\t    }\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var enqueueMutation = scope.enqueueMutation;\n\t    function getClass(el) {\n\t      return unsafeUnwrap(el).getAttribute(\"class\");\n\t    }\n\t    function enqueueClassAttributeChange(el, oldValue) {\n\t      enqueueMutation(el, \"attributes\", {\n\t        name: \"class\",\n\t        namespace: null,\n\t        oldValue: oldValue\n\t      });\n\t    }\n\t    function invalidateClass(el) {\n\t      scope.invalidateRendererBasedOnAttribute(el, \"class\");\n\t    }\n\t    function changeClass(tokenList, method, args) {\n\t      var ownerElement = tokenList.ownerElement_;\n\t      if (ownerElement == null) {\n\t        return method.apply(tokenList, args);\n\t      }\n\t      var oldValue = getClass(ownerElement);\n\t      var retv = method.apply(tokenList, args);\n\t      if (getClass(ownerElement) !== oldValue) {\n\t        enqueueClassAttributeChange(ownerElement, oldValue);\n\t        invalidateClass(ownerElement);\n\t      }\n\t      return retv;\n\t    }\n\t    var oldAdd = DOMTokenList.prototype.add;\n\t    DOMTokenList.prototype.add = function() {\n\t      changeClass(this, oldAdd, arguments);\n\t    };\n\t    var oldRemove = DOMTokenList.prototype.remove;\n\t    DOMTokenList.prototype.remove = function() {\n\t      changeClass(this, oldRemove, arguments);\n\t    };\n\t    var oldToggle = DOMTokenList.prototype.toggle;\n\t    DOMTokenList.prototype.toggle = function() {\n\t      return changeClass(this, oldToggle, arguments);\n\t    };\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var ChildNodeInterface = scope.ChildNodeInterface;\n\t    var GetElementsByInterface = scope.GetElementsByInterface;\n\t    var Node = scope.wrappers.Node;\n\t    var ParentNodeInterface = scope.ParentNodeInterface;\n\t    var SelectorsInterface = scope.SelectorsInterface;\n\t    var MatchesInterface = scope.MatchesInterface;\n\t    var addWrapNodeListMethod = scope.addWrapNodeListMethod;\n\t    var enqueueMutation = scope.enqueueMutation;\n\t    var mixin = scope.mixin;\n\t    var oneOf = scope.oneOf;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var wrappers = scope.wrappers;\n\t    var OriginalElement = window.Element;\n\t    var matchesNames = [ \"matches\", \"mozMatchesSelector\", \"msMatchesSelector\", \"webkitMatchesSelector\" ].filter(function(name) {\n\t      return OriginalElement.prototype[name];\n\t    });\n\t    var matchesName = matchesNames[0];\n\t    var originalMatches = OriginalElement.prototype[matchesName];\n\t    function invalidateRendererBasedOnAttribute(element, name) {\n\t      var p = element.parentNode;\n\t      if (!p || !p.shadowRoot) return;\n\t      var renderer = scope.getRendererForHost(p);\n\t      if (renderer.dependsOnAttribute(name)) renderer.invalidate();\n\t    }\n\t    function enqueAttributeChange(element, name, oldValue) {\n\t      enqueueMutation(element, \"attributes\", {\n\t        name: name,\n\t        namespace: null,\n\t        oldValue: oldValue\n\t      });\n\t    }\n\t    var classListTable = new WeakMap();\n\t    function Element(node) {\n\t      Node.call(this, node);\n\t    }\n\t    Element.prototype = Object.create(Node.prototype);\n\t    mixin(Element.prototype, {\n\t      createShadowRoot: function() {\n\t        var newShadowRoot = new wrappers.ShadowRoot(this);\n\t        unsafeUnwrap(this).polymerShadowRoot_ = newShadowRoot;\n\t        var renderer = scope.getRendererForHost(this);\n\t        renderer.invalidate();\n\t        return newShadowRoot;\n\t      },\n\t      get shadowRoot() {\n\t        return unsafeUnwrap(this).polymerShadowRoot_ || null;\n\t      },\n\t      setAttribute: function(name, value) {\n\t        var oldValue = unsafeUnwrap(this).getAttribute(name);\n\t        unsafeUnwrap(this).setAttribute(name, value);\n\t        enqueAttributeChange(this, name, oldValue);\n\t        invalidateRendererBasedOnAttribute(this, name);\n\t      },\n\t      removeAttribute: function(name) {\n\t        var oldValue = unsafeUnwrap(this).getAttribute(name);\n\t        unsafeUnwrap(this).removeAttribute(name);\n\t        enqueAttributeChange(this, name, oldValue);\n\t        invalidateRendererBasedOnAttribute(this, name);\n\t      },\n\t      get classList() {\n\t        var list = classListTable.get(this);\n\t        if (!list) {\n\t          list = unsafeUnwrap(this).classList;\n\t          if (!list) return;\n\t          list.ownerElement_ = this;\n\t          classListTable.set(this, list);\n\t        }\n\t        return list;\n\t      },\n\t      get className() {\n\t        return unsafeUnwrap(this).className;\n\t      },\n\t      set className(v) {\n\t        this.setAttribute(\"class\", v);\n\t      },\n\t      get id() {\n\t        return unsafeUnwrap(this).id;\n\t      },\n\t      set id(v) {\n\t        this.setAttribute(\"id\", v);\n\t      }\n\t    });\n\t    matchesNames.forEach(function(name) {\n\t      if (name !== \"matches\") {\n\t        Element.prototype[name] = function(selector) {\n\t          return this.matches(selector);\n\t        };\n\t      }\n\t    });\n\t    if (OriginalElement.prototype.webkitCreateShadowRoot) {\n\t      Element.prototype.webkitCreateShadowRoot = Element.prototype.createShadowRoot;\n\t    }\n\t    mixin(Element.prototype, ChildNodeInterface);\n\t    mixin(Element.prototype, GetElementsByInterface);\n\t    mixin(Element.prototype, ParentNodeInterface);\n\t    mixin(Element.prototype, SelectorsInterface);\n\t    mixin(Element.prototype, MatchesInterface);\n\t    registerWrapper(OriginalElement, Element, document.createElementNS(null, \"x\"));\n\t    scope.invalidateRendererBasedOnAttribute = invalidateRendererBasedOnAttribute;\n\t    scope.matchesNames = matchesNames;\n\t    scope.originalMatches = originalMatches;\n\t    scope.wrappers.Element = Element;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var Element = scope.wrappers.Element;\n\t    var defineGetter = scope.defineGetter;\n\t    var enqueueMutation = scope.enqueueMutation;\n\t    var mixin = scope.mixin;\n\t    var nodesWereAdded = scope.nodesWereAdded;\n\t    var nodesWereRemoved = scope.nodesWereRemoved;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var snapshotNodeList = scope.snapshotNodeList;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var wrappers = scope.wrappers;\n\t    var escapeAttrRegExp = /[&\\u00A0\"]/g;\n\t    var escapeDataRegExp = /[&\\u00A0<>]/g;\n\t    function escapeReplace(c) {\n\t      switch (c) {\n\t       case \"&\":\n\t        return \"&amp;\";\n\t\n\t       case \"<\":\n\t        return \"&lt;\";\n\t\n\t       case \">\":\n\t        return \"&gt;\";\n\t\n\t       case '\"':\n\t        return \"&quot;\";\n\t\n\t       case \"\":\n\t        return \"&nbsp;\";\n\t      }\n\t    }\n\t    function escapeAttr(s) {\n\t      return s.replace(escapeAttrRegExp, escapeReplace);\n\t    }\n\t    function escapeData(s) {\n\t      return s.replace(escapeDataRegExp, escapeReplace);\n\t    }\n\t    function makeSet(arr) {\n\t      var set = {};\n\t      for (var i = 0; i < arr.length; i++) {\n\t        set[arr[i]] = true;\n\t      }\n\t      return set;\n\t    }\n\t    var voidElements = makeSet([ \"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\" ]);\n\t    var plaintextParents = makeSet([ \"style\", \"script\", \"xmp\", \"iframe\", \"noembed\", \"noframes\", \"plaintext\", \"noscript\" ]);\n\t    var XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n\t    function needsSelfClosingSlash(node) {\n\t      if (node.namespaceURI !== XHTML_NS) return true;\n\t      var doctype = node.ownerDocument.doctype;\n\t      return doctype && doctype.publicId && doctype.systemId;\n\t    }\n\t    function getOuterHTML(node, parentNode) {\n\t      switch (node.nodeType) {\n\t       case Node.ELEMENT_NODE:\n\t        var tagName = node.tagName.toLowerCase();\n\t        var s = \"<\" + tagName;\n\t        var attrs = node.attributes;\n\t        for (var i = 0, attr; attr = attrs[i]; i++) {\n\t          s += \" \" + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n\t        }\n\t        if (voidElements[tagName]) {\n\t          if (needsSelfClosingSlash(node)) s += \"/\";\n\t          return s + \">\";\n\t        }\n\t        return s + \">\" + getInnerHTML(node) + \"</\" + tagName + \">\";\n\t\n\t       case Node.TEXT_NODE:\n\t        var data = node.data;\n\t        if (parentNode && plaintextParents[parentNode.localName]) return data;\n\t        return escapeData(data);\n\t\n\t       case Node.COMMENT_NODE:\n\t        return \"<!--\" + node.data + \"-->\";\n\t\n\t       default:\n\t        console.error(node);\n\t        throw new Error(\"not implemented\");\n\t      }\n\t    }\n\t    function getInnerHTML(node) {\n\t      if (node instanceof wrappers.HTMLTemplateElement) node = node.content;\n\t      var s = \"\";\n\t      for (var child = node.firstChild; child; child = child.nextSibling) {\n\t        s += getOuterHTML(child, node);\n\t      }\n\t      return s;\n\t    }\n\t    function setInnerHTML(node, value, opt_tagName) {\n\t      var tagName = opt_tagName || \"div\";\n\t      node.textContent = \"\";\n\t      var tempElement = unwrap(node.ownerDocument.createElement(tagName));\n\t      tempElement.innerHTML = value;\n\t      var firstChild;\n\t      while (firstChild = tempElement.firstChild) {\n\t        node.appendChild(wrap(firstChild));\n\t      }\n\t    }\n\t    var oldIe = /MSIE/.test(navigator.userAgent);\n\t    var OriginalHTMLElement = window.HTMLElement;\n\t    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n\t    function HTMLElement(node) {\n\t      Element.call(this, node);\n\t    }\n\t    HTMLElement.prototype = Object.create(Element.prototype);\n\t    mixin(HTMLElement.prototype, {\n\t      get innerHTML() {\n\t        return getInnerHTML(this);\n\t      },\n\t      set innerHTML(value) {\n\t        if (oldIe && plaintextParents[this.localName]) {\n\t          this.textContent = value;\n\t          return;\n\t        }\n\t        var removedNodes = snapshotNodeList(this.childNodes);\n\t        if (this.invalidateShadowRenderer()) {\n\t          if (this instanceof wrappers.HTMLTemplateElement) setInnerHTML(this.content, value); else setInnerHTML(this, value, this.tagName);\n\t        } else if (!OriginalHTMLTemplateElement && this instanceof wrappers.HTMLTemplateElement) {\n\t          setInnerHTML(this.content, value);\n\t        } else {\n\t          unsafeUnwrap(this).innerHTML = value;\n\t        }\n\t        var addedNodes = snapshotNodeList(this.childNodes);\n\t        enqueueMutation(this, \"childList\", {\n\t          addedNodes: addedNodes,\n\t          removedNodes: removedNodes\n\t        });\n\t        nodesWereRemoved(removedNodes);\n\t        nodesWereAdded(addedNodes, this);\n\t      },\n\t      get outerHTML() {\n\t        return getOuterHTML(this, this.parentNode);\n\t      },\n\t      set outerHTML(value) {\n\t        var p = this.parentNode;\n\t        if (p) {\n\t          p.invalidateShadowRenderer();\n\t          var df = frag(p, value);\n\t          p.replaceChild(df, this);\n\t        }\n\t      },\n\t      insertAdjacentHTML: function(position, text) {\n\t        var contextElement, refNode;\n\t        switch (String(position).toLowerCase()) {\n\t         case \"beforebegin\":\n\t          contextElement = this.parentNode;\n\t          refNode = this;\n\t          break;\n\t\n\t         case \"afterend\":\n\t          contextElement = this.parentNode;\n\t          refNode = this.nextSibling;\n\t          break;\n\t\n\t         case \"afterbegin\":\n\t          contextElement = this;\n\t          refNode = this.firstChild;\n\t          break;\n\t\n\t         case \"beforeend\":\n\t          contextElement = this;\n\t          refNode = null;\n\t          break;\n\t\n\t         default:\n\t          return;\n\t        }\n\t        var df = frag(contextElement, text);\n\t        contextElement.insertBefore(df, refNode);\n\t      },\n\t      get hidden() {\n\t        return this.hasAttribute(\"hidden\");\n\t      },\n\t      set hidden(v) {\n\t        if (v) {\n\t          this.setAttribute(\"hidden\", \"\");\n\t        } else {\n\t          this.removeAttribute(\"hidden\");\n\t        }\n\t      }\n\t    });\n\t    function frag(contextElement, html) {\n\t      var p = unwrap(contextElement.cloneNode(false));\n\t      p.innerHTML = html;\n\t      var df = unwrap(document.createDocumentFragment());\n\t      var c;\n\t      while (c = p.firstChild) {\n\t        df.appendChild(c);\n\t      }\n\t      return wrap(df);\n\t    }\n\t    function getter(name) {\n\t      return function() {\n\t        scope.renderAllPending();\n\t        return unsafeUnwrap(this)[name];\n\t      };\n\t    }\n\t    function getterRequiresRendering(name) {\n\t      defineGetter(HTMLElement, name, getter(name));\n\t    }\n\t    [ \"clientHeight\", \"clientLeft\", \"clientTop\", \"clientWidth\", \"offsetHeight\", \"offsetLeft\", \"offsetTop\", \"offsetWidth\", \"scrollHeight\", \"scrollWidth\" ].forEach(getterRequiresRendering);\n\t    function getterAndSetterRequiresRendering(name) {\n\t      Object.defineProperty(HTMLElement.prototype, name, {\n\t        get: getter(name),\n\t        set: function(v) {\n\t          scope.renderAllPending();\n\t          unsafeUnwrap(this)[name] = v;\n\t        },\n\t        configurable: true,\n\t        enumerable: true\n\t      });\n\t    }\n\t    [ \"scrollLeft\", \"scrollTop\" ].forEach(getterAndSetterRequiresRendering);\n\t    function methodRequiresRendering(name) {\n\t      Object.defineProperty(HTMLElement.prototype, name, {\n\t        value: function() {\n\t          scope.renderAllPending();\n\t          return unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments);\n\t        },\n\t        configurable: true,\n\t        enumerable: true\n\t      });\n\t    }\n\t    [ \"focus\", \"getBoundingClientRect\", \"getClientRects\", \"scrollIntoView\" ].forEach(methodRequiresRendering);\n\t    registerWrapper(OriginalHTMLElement, HTMLElement, document.createElement(\"b\"));\n\t    scope.wrappers.HTMLElement = HTMLElement;\n\t    scope.getInnerHTML = getInnerHTML;\n\t    scope.setInnerHTML = setInnerHTML;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var wrap = scope.wrap;\n\t    var OriginalHTMLCanvasElement = window.HTMLCanvasElement;\n\t    function HTMLCanvasElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLCanvasElement.prototype = Object.create(HTMLElement.prototype);\n\t    mixin(HTMLCanvasElement.prototype, {\n\t      getContext: function() {\n\t        var context = unsafeUnwrap(this).getContext.apply(unsafeUnwrap(this), arguments);\n\t        return context && wrap(context);\n\t      }\n\t    });\n\t    registerWrapper(OriginalHTMLCanvasElement, HTMLCanvasElement, document.createElement(\"canvas\"));\n\t    scope.wrappers.HTMLCanvasElement = HTMLCanvasElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var OriginalHTMLContentElement = window.HTMLContentElement;\n\t    function HTMLContentElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLContentElement.prototype = Object.create(HTMLElement.prototype);\n\t    mixin(HTMLContentElement.prototype, {\n\t      constructor: HTMLContentElement,\n\t      get select() {\n\t        return this.getAttribute(\"select\");\n\t      },\n\t      set select(value) {\n\t        this.setAttribute(\"select\", value);\n\t      },\n\t      setAttribute: function(n, v) {\n\t        HTMLElement.prototype.setAttribute.call(this, n, v);\n\t        if (String(n).toLowerCase() === \"select\") this.invalidateShadowRenderer(true);\n\t      }\n\t    });\n\t    if (OriginalHTMLContentElement) registerWrapper(OriginalHTMLContentElement, HTMLContentElement);\n\t    scope.wrappers.HTMLContentElement = HTMLContentElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var wrapHTMLCollection = scope.wrapHTMLCollection;\n\t    var unwrap = scope.unwrap;\n\t    var OriginalHTMLFormElement = window.HTMLFormElement;\n\t    function HTMLFormElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLFormElement.prototype = Object.create(HTMLElement.prototype);\n\t    mixin(HTMLFormElement.prototype, {\n\t      get elements() {\n\t        return wrapHTMLCollection(unwrap(this).elements);\n\t      }\n\t    });\n\t    registerWrapper(OriginalHTMLFormElement, HTMLFormElement, document.createElement(\"form\"));\n\t    scope.wrappers.HTMLFormElement = HTMLFormElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unwrap = scope.unwrap;\n\t    var rewrap = scope.rewrap;\n\t    var OriginalHTMLImageElement = window.HTMLImageElement;\n\t    function HTMLImageElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLImageElement.prototype = Object.create(HTMLElement.prototype);\n\t    registerWrapper(OriginalHTMLImageElement, HTMLImageElement, document.createElement(\"img\"));\n\t    function Image(width, height) {\n\t      if (!(this instanceof Image)) {\n\t        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n\t      }\n\t      var node = unwrap(document.createElement(\"img\"));\n\t      HTMLElement.call(this, node);\n\t      rewrap(node, this);\n\t      if (width !== undefined) node.width = width;\n\t      if (height !== undefined) node.height = height;\n\t    }\n\t    Image.prototype = HTMLImageElement.prototype;\n\t    scope.wrappers.HTMLImageElement = HTMLImageElement;\n\t    scope.wrappers.Image = Image;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var mixin = scope.mixin;\n\t    var NodeList = scope.wrappers.NodeList;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var OriginalHTMLShadowElement = window.HTMLShadowElement;\n\t    function HTMLShadowElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLShadowElement.prototype = Object.create(HTMLElement.prototype);\n\t    HTMLShadowElement.prototype.constructor = HTMLShadowElement;\n\t    if (OriginalHTMLShadowElement) registerWrapper(OriginalHTMLShadowElement, HTMLShadowElement);\n\t    scope.wrappers.HTMLShadowElement = HTMLShadowElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var contentTable = new WeakMap();\n\t    var templateContentsOwnerTable = new WeakMap();\n\t    function getTemplateContentsOwner(doc) {\n\t      if (!doc.defaultView) return doc;\n\t      var d = templateContentsOwnerTable.get(doc);\n\t      if (!d) {\n\t        d = doc.implementation.createHTMLDocument(\"\");\n\t        while (d.lastChild) {\n\t          d.removeChild(d.lastChild);\n\t        }\n\t        templateContentsOwnerTable.set(doc, d);\n\t      }\n\t      return d;\n\t    }\n\t    function extractContent(templateElement) {\n\t      var doc = getTemplateContentsOwner(templateElement.ownerDocument);\n\t      var df = unwrap(doc.createDocumentFragment());\n\t      var child;\n\t      while (child = templateElement.firstChild) {\n\t        df.appendChild(child);\n\t      }\n\t      return df;\n\t    }\n\t    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n\t    function HTMLTemplateElement(node) {\n\t      HTMLElement.call(this, node);\n\t      if (!OriginalHTMLTemplateElement) {\n\t        var content = extractContent(node);\n\t        contentTable.set(this, wrap(content));\n\t      }\n\t    }\n\t    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);\n\t    mixin(HTMLTemplateElement.prototype, {\n\t      constructor: HTMLTemplateElement,\n\t      get content() {\n\t        if (OriginalHTMLTemplateElement) return wrap(unsafeUnwrap(this).content);\n\t        return contentTable.get(this);\n\t      }\n\t    });\n\t    if (OriginalHTMLTemplateElement) registerWrapper(OriginalHTMLTemplateElement, HTMLTemplateElement);\n\t    scope.wrappers.HTMLTemplateElement = HTMLTemplateElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var OriginalHTMLMediaElement = window.HTMLMediaElement;\n\t    if (!OriginalHTMLMediaElement) return;\n\t    function HTMLMediaElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLMediaElement.prototype = Object.create(HTMLElement.prototype);\n\t    registerWrapper(OriginalHTMLMediaElement, HTMLMediaElement, document.createElement(\"audio\"));\n\t    scope.wrappers.HTMLMediaElement = HTMLMediaElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLMediaElement = scope.wrappers.HTMLMediaElement;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unwrap = scope.unwrap;\n\t    var rewrap = scope.rewrap;\n\t    var OriginalHTMLAudioElement = window.HTMLAudioElement;\n\t    if (!OriginalHTMLAudioElement) return;\n\t    function HTMLAudioElement(node) {\n\t      HTMLMediaElement.call(this, node);\n\t    }\n\t    HTMLAudioElement.prototype = Object.create(HTMLMediaElement.prototype);\n\t    registerWrapper(OriginalHTMLAudioElement, HTMLAudioElement, document.createElement(\"audio\"));\n\t    function Audio(src) {\n\t      if (!(this instanceof Audio)) {\n\t        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n\t      }\n\t      var node = unwrap(document.createElement(\"audio\"));\n\t      HTMLMediaElement.call(this, node);\n\t      rewrap(node, this);\n\t      node.setAttribute(\"preload\", \"auto\");\n\t      if (src !== undefined) node.setAttribute(\"src\", src);\n\t    }\n\t    Audio.prototype = HTMLAudioElement.prototype;\n\t    scope.wrappers.HTMLAudioElement = HTMLAudioElement;\n\t    scope.wrappers.Audio = Audio;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var rewrap = scope.rewrap;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var OriginalHTMLOptionElement = window.HTMLOptionElement;\n\t    function trimText(s) {\n\t      return s.replace(/\\s+/g, \" \").trim();\n\t    }\n\t    function HTMLOptionElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLOptionElement.prototype = Object.create(HTMLElement.prototype);\n\t    mixin(HTMLOptionElement.prototype, {\n\t      get text() {\n\t        return trimText(this.textContent);\n\t      },\n\t      set text(value) {\n\t        this.textContent = trimText(String(value));\n\t      },\n\t      get form() {\n\t        return wrap(unwrap(this).form);\n\t      }\n\t    });\n\t    registerWrapper(OriginalHTMLOptionElement, HTMLOptionElement, document.createElement(\"option\"));\n\t    function Option(text, value, defaultSelected, selected) {\n\t      if (!(this instanceof Option)) {\n\t        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n\t      }\n\t      var node = unwrap(document.createElement(\"option\"));\n\t      HTMLElement.call(this, node);\n\t      rewrap(node, this);\n\t      if (text !== undefined) node.text = text;\n\t      if (value !== undefined) node.setAttribute(\"value\", value);\n\t      if (defaultSelected === true) node.setAttribute(\"selected\", \"\");\n\t      node.selected = selected === true;\n\t    }\n\t    Option.prototype = HTMLOptionElement.prototype;\n\t    scope.wrappers.HTMLOptionElement = HTMLOptionElement;\n\t    scope.wrappers.Option = Option;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var OriginalHTMLSelectElement = window.HTMLSelectElement;\n\t    function HTMLSelectElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLSelectElement.prototype = Object.create(HTMLElement.prototype);\n\t    mixin(HTMLSelectElement.prototype, {\n\t      add: function(element, before) {\n\t        if (typeof before === \"object\") before = unwrap(before);\n\t        unwrap(this).add(unwrap(element), before);\n\t      },\n\t      remove: function(indexOrNode) {\n\t        if (indexOrNode === undefined) {\n\t          HTMLElement.prototype.remove.call(this);\n\t          return;\n\t        }\n\t        if (typeof indexOrNode === \"object\") indexOrNode = unwrap(indexOrNode);\n\t        unwrap(this).remove(indexOrNode);\n\t      },\n\t      get form() {\n\t        return wrap(unwrap(this).form);\n\t      }\n\t    });\n\t    registerWrapper(OriginalHTMLSelectElement, HTMLSelectElement, document.createElement(\"select\"));\n\t    scope.wrappers.HTMLSelectElement = HTMLSelectElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var wrapHTMLCollection = scope.wrapHTMLCollection;\n\t    var OriginalHTMLTableElement = window.HTMLTableElement;\n\t    function HTMLTableElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLTableElement.prototype = Object.create(HTMLElement.prototype);\n\t    mixin(HTMLTableElement.prototype, {\n\t      get caption() {\n\t        return wrap(unwrap(this).caption);\n\t      },\n\t      createCaption: function() {\n\t        return wrap(unwrap(this).createCaption());\n\t      },\n\t      get tHead() {\n\t        return wrap(unwrap(this).tHead);\n\t      },\n\t      createTHead: function() {\n\t        return wrap(unwrap(this).createTHead());\n\t      },\n\t      createTFoot: function() {\n\t        return wrap(unwrap(this).createTFoot());\n\t      },\n\t      get tFoot() {\n\t        return wrap(unwrap(this).tFoot);\n\t      },\n\t      get tBodies() {\n\t        return wrapHTMLCollection(unwrap(this).tBodies);\n\t      },\n\t      createTBody: function() {\n\t        return wrap(unwrap(this).createTBody());\n\t      },\n\t      get rows() {\n\t        return wrapHTMLCollection(unwrap(this).rows);\n\t      },\n\t      insertRow: function(index) {\n\t        return wrap(unwrap(this).insertRow(index));\n\t      }\n\t    });\n\t    registerWrapper(OriginalHTMLTableElement, HTMLTableElement, document.createElement(\"table\"));\n\t    scope.wrappers.HTMLTableElement = HTMLTableElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var wrapHTMLCollection = scope.wrapHTMLCollection;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var OriginalHTMLTableSectionElement = window.HTMLTableSectionElement;\n\t    function HTMLTableSectionElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLTableSectionElement.prototype = Object.create(HTMLElement.prototype);\n\t    mixin(HTMLTableSectionElement.prototype, {\n\t      constructor: HTMLTableSectionElement,\n\t      get rows() {\n\t        return wrapHTMLCollection(unwrap(this).rows);\n\t      },\n\t      insertRow: function(index) {\n\t        return wrap(unwrap(this).insertRow(index));\n\t      }\n\t    });\n\t    registerWrapper(OriginalHTMLTableSectionElement, HTMLTableSectionElement, document.createElement(\"thead\"));\n\t    scope.wrappers.HTMLTableSectionElement = HTMLTableSectionElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var wrapHTMLCollection = scope.wrapHTMLCollection;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var OriginalHTMLTableRowElement = window.HTMLTableRowElement;\n\t    function HTMLTableRowElement(node) {\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLTableRowElement.prototype = Object.create(HTMLElement.prototype);\n\t    mixin(HTMLTableRowElement.prototype, {\n\t      get cells() {\n\t        return wrapHTMLCollection(unwrap(this).cells);\n\t      },\n\t      insertCell: function(index) {\n\t        return wrap(unwrap(this).insertCell(index));\n\t      }\n\t    });\n\t    registerWrapper(OriginalHTMLTableRowElement, HTMLTableRowElement, document.createElement(\"tr\"));\n\t    scope.wrappers.HTMLTableRowElement = HTMLTableRowElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLContentElement = scope.wrappers.HTMLContentElement;\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n\t    var HTMLTemplateElement = scope.wrappers.HTMLTemplateElement;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var OriginalHTMLUnknownElement = window.HTMLUnknownElement;\n\t    function HTMLUnknownElement(node) {\n\t      switch (node.localName) {\n\t       case \"content\":\n\t        return new HTMLContentElement(node);\n\t\n\t       case \"shadow\":\n\t        return new HTMLShadowElement(node);\n\t\n\t       case \"template\":\n\t        return new HTMLTemplateElement(node);\n\t      }\n\t      HTMLElement.call(this, node);\n\t    }\n\t    HTMLUnknownElement.prototype = Object.create(HTMLElement.prototype);\n\t    registerWrapper(OriginalHTMLUnknownElement, HTMLUnknownElement);\n\t    scope.wrappers.HTMLUnknownElement = HTMLUnknownElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var Element = scope.wrappers.Element;\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var defineWrapGetter = scope.defineWrapGetter;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var wrap = scope.wrap;\n\t    var mixin = scope.mixin;\n\t    var SVG_NS = \"http://www.w3.org/2000/svg\";\n\t    var OriginalSVGElement = window.SVGElement;\n\t    var svgTitleElement = document.createElementNS(SVG_NS, \"title\");\n\t    if (!(\"classList\" in svgTitleElement)) {\n\t      var descr = Object.getOwnPropertyDescriptor(Element.prototype, \"classList\");\n\t      Object.defineProperty(HTMLElement.prototype, \"classList\", descr);\n\t      delete Element.prototype.classList;\n\t    }\n\t    function SVGElement(node) {\n\t      Element.call(this, node);\n\t    }\n\t    SVGElement.prototype = Object.create(Element.prototype);\n\t    mixin(SVGElement.prototype, {\n\t      get ownerSVGElement() {\n\t        return wrap(unsafeUnwrap(this).ownerSVGElement);\n\t      }\n\t    });\n\t    registerWrapper(OriginalSVGElement, SVGElement, document.createElementNS(SVG_NS, \"title\"));\n\t    scope.wrappers.SVGElement = SVGElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var OriginalSVGUseElement = window.SVGUseElement;\n\t    var SVG_NS = \"http://www.w3.org/2000/svg\";\n\t    var gWrapper = wrap(document.createElementNS(SVG_NS, \"g\"));\n\t    var useElement = document.createElementNS(SVG_NS, \"use\");\n\t    var SVGGElement = gWrapper.constructor;\n\t    var parentInterfacePrototype = Object.getPrototypeOf(SVGGElement.prototype);\n\t    var parentInterface = parentInterfacePrototype.constructor;\n\t    function SVGUseElement(impl) {\n\t      parentInterface.call(this, impl);\n\t    }\n\t    SVGUseElement.prototype = Object.create(parentInterfacePrototype);\n\t    if (\"instanceRoot\" in useElement) {\n\t      mixin(SVGUseElement.prototype, {\n\t        get instanceRoot() {\n\t          return wrap(unwrap(this).instanceRoot);\n\t        },\n\t        get animatedInstanceRoot() {\n\t          return wrap(unwrap(this).animatedInstanceRoot);\n\t        }\n\t      });\n\t    }\n\t    registerWrapper(OriginalSVGUseElement, SVGUseElement, useElement);\n\t    scope.wrappers.SVGUseElement = SVGUseElement;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var EventTarget = scope.wrappers.EventTarget;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var wrap = scope.wrap;\n\t    var OriginalSVGElementInstance = window.SVGElementInstance;\n\t    if (!OriginalSVGElementInstance) return;\n\t    function SVGElementInstance(impl) {\n\t      EventTarget.call(this, impl);\n\t    }\n\t    SVGElementInstance.prototype = Object.create(EventTarget.prototype);\n\t    mixin(SVGElementInstance.prototype, {\n\t      get correspondingElement() {\n\t        return wrap(unsafeUnwrap(this).correspondingElement);\n\t      },\n\t      get correspondingUseElement() {\n\t        return wrap(unsafeUnwrap(this).correspondingUseElement);\n\t      },\n\t      get parentNode() {\n\t        return wrap(unsafeUnwrap(this).parentNode);\n\t      },\n\t      get childNodes() {\n\t        throw new Error(\"Not implemented\");\n\t      },\n\t      get firstChild() {\n\t        return wrap(unsafeUnwrap(this).firstChild);\n\t      },\n\t      get lastChild() {\n\t        return wrap(unsafeUnwrap(this).lastChild);\n\t      },\n\t      get previousSibling() {\n\t        return wrap(unsafeUnwrap(this).previousSibling);\n\t      },\n\t      get nextSibling() {\n\t        return wrap(unsafeUnwrap(this).nextSibling);\n\t      }\n\t    });\n\t    registerWrapper(OriginalSVGElementInstance, SVGElementInstance);\n\t    scope.wrappers.SVGElementInstance = SVGElementInstance;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var setWrapper = scope.setWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrap = scope.unwrap;\n\t    var unwrapIfNeeded = scope.unwrapIfNeeded;\n\t    var wrap = scope.wrap;\n\t    var OriginalCanvasRenderingContext2D = window.CanvasRenderingContext2D;\n\t    function CanvasRenderingContext2D(impl) {\n\t      setWrapper(impl, this);\n\t    }\n\t    mixin(CanvasRenderingContext2D.prototype, {\n\t      get canvas() {\n\t        return wrap(unsafeUnwrap(this).canvas);\n\t      },\n\t      drawImage: function() {\n\t        arguments[0] = unwrapIfNeeded(arguments[0]);\n\t        unsafeUnwrap(this).drawImage.apply(unsafeUnwrap(this), arguments);\n\t      },\n\t      createPattern: function() {\n\t        arguments[0] = unwrap(arguments[0]);\n\t        return unsafeUnwrap(this).createPattern.apply(unsafeUnwrap(this), arguments);\n\t      }\n\t    });\n\t    registerWrapper(OriginalCanvasRenderingContext2D, CanvasRenderingContext2D, document.createElement(\"canvas\").getContext(\"2d\"));\n\t    scope.wrappers.CanvasRenderingContext2D = CanvasRenderingContext2D;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var addForwardingProperties = scope.addForwardingProperties;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var setWrapper = scope.setWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrapIfNeeded = scope.unwrapIfNeeded;\n\t    var wrap = scope.wrap;\n\t    var OriginalWebGLRenderingContext = window.WebGLRenderingContext;\n\t    if (!OriginalWebGLRenderingContext) return;\n\t    function WebGLRenderingContext(impl) {\n\t      setWrapper(impl, this);\n\t    }\n\t    mixin(WebGLRenderingContext.prototype, {\n\t      get canvas() {\n\t        return wrap(unsafeUnwrap(this).canvas);\n\t      },\n\t      texImage2D: function() {\n\t        arguments[5] = unwrapIfNeeded(arguments[5]);\n\t        unsafeUnwrap(this).texImage2D.apply(unsafeUnwrap(this), arguments);\n\t      },\n\t      texSubImage2D: function() {\n\t        arguments[6] = unwrapIfNeeded(arguments[6]);\n\t        unsafeUnwrap(this).texSubImage2D.apply(unsafeUnwrap(this), arguments);\n\t      }\n\t    });\n\t    var OriginalWebGLRenderingContextBase = Object.getPrototypeOf(OriginalWebGLRenderingContext.prototype);\n\t    if (OriginalWebGLRenderingContextBase !== Object.prototype) {\n\t      addForwardingProperties(OriginalWebGLRenderingContextBase, WebGLRenderingContext.prototype);\n\t    }\n\t    var instanceProperties = /WebKit/.test(navigator.userAgent) ? {\n\t      drawingBufferHeight: null,\n\t      drawingBufferWidth: null\n\t    } : {};\n\t    registerWrapper(OriginalWebGLRenderingContext, WebGLRenderingContext, instanceProperties);\n\t    scope.wrappers.WebGLRenderingContext = WebGLRenderingContext;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var Node = scope.wrappers.Node;\n\t    var GetElementsByInterface = scope.GetElementsByInterface;\n\t    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\n\t    var ParentNodeInterface = scope.ParentNodeInterface;\n\t    var SelectorsInterface = scope.SelectorsInterface;\n\t    var mixin = scope.mixin;\n\t    var registerObject = scope.registerObject;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var OriginalDocumentFragment = window.DocumentFragment;\n\t    function DocumentFragment(node) {\n\t      Node.call(this, node);\n\t    }\n\t    DocumentFragment.prototype = Object.create(Node.prototype);\n\t    mixin(DocumentFragment.prototype, ParentNodeInterface);\n\t    mixin(DocumentFragment.prototype, SelectorsInterface);\n\t    mixin(DocumentFragment.prototype, GetElementsByInterface);\n\t    mixin(DocumentFragment.prototype, NonElementParentNodeInterface);\n\t    registerWrapper(OriginalDocumentFragment, DocumentFragment, document.createDocumentFragment());\n\t    scope.wrappers.DocumentFragment = DocumentFragment;\n\t    var Comment = registerObject(document.createComment(\"\"));\n\t    scope.wrappers.Comment = Comment;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var DocumentFragment = scope.wrappers.DocumentFragment;\n\t    var TreeScope = scope.TreeScope;\n\t    var elementFromPoint = scope.elementFromPoint;\n\t    var getInnerHTML = scope.getInnerHTML;\n\t    var getTreeScope = scope.getTreeScope;\n\t    var mixin = scope.mixin;\n\t    var rewrap = scope.rewrap;\n\t    var setInnerHTML = scope.setInnerHTML;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var shadowHostTable = new WeakMap();\n\t    var nextOlderShadowTreeTable = new WeakMap();\n\t    function ShadowRoot(hostWrapper) {\n\t      var node = unwrap(unsafeUnwrap(hostWrapper).ownerDocument.createDocumentFragment());\n\t      DocumentFragment.call(this, node);\n\t      rewrap(node, this);\n\t      var oldShadowRoot = hostWrapper.shadowRoot;\n\t      nextOlderShadowTreeTable.set(this, oldShadowRoot);\n\t      this.treeScope_ = new TreeScope(this, getTreeScope(oldShadowRoot || hostWrapper));\n\t      shadowHostTable.set(this, hostWrapper);\n\t    }\n\t    ShadowRoot.prototype = Object.create(DocumentFragment.prototype);\n\t    mixin(ShadowRoot.prototype, {\n\t      constructor: ShadowRoot,\n\t      get innerHTML() {\n\t        return getInnerHTML(this);\n\t      },\n\t      set innerHTML(value) {\n\t        setInnerHTML(this, value);\n\t        this.invalidateShadowRenderer();\n\t      },\n\t      get olderShadowRoot() {\n\t        return nextOlderShadowTreeTable.get(this) || null;\n\t      },\n\t      get host() {\n\t        return shadowHostTable.get(this) || null;\n\t      },\n\t      invalidateShadowRenderer: function() {\n\t        return shadowHostTable.get(this).invalidateShadowRenderer();\n\t      },\n\t      elementFromPoint: function(x, y) {\n\t        return elementFromPoint(this, this.ownerDocument, x, y);\n\t      },\n\t      getSelection: function() {\n\t        return document.getSelection();\n\t      },\n\t      get activeElement() {\n\t        var unwrappedActiveElement = unwrap(this).ownerDocument.activeElement;\n\t        if (!unwrappedActiveElement || !unwrappedActiveElement.nodeType) return null;\n\t        var activeElement = wrap(unwrappedActiveElement);\n\t        if (activeElement === this.host) {\n\t          return null;\n\t        }\n\t        while (!this.contains(activeElement) && !this.host.contains(activeElement)) {\n\t          while (activeElement.parentNode) {\n\t            activeElement = activeElement.parentNode;\n\t          }\n\t          if (activeElement.host) {\n\t            activeElement = activeElement.host;\n\t          } else {\n\t            return null;\n\t          }\n\t        }\n\t        return activeElement;\n\t      }\n\t    });\n\t    scope.wrappers.ShadowRoot = ShadowRoot;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var registerWrapper = scope.registerWrapper;\n\t    var setWrapper = scope.setWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrap = scope.unwrap;\n\t    var unwrapIfNeeded = scope.unwrapIfNeeded;\n\t    var wrap = scope.wrap;\n\t    var getTreeScope = scope.getTreeScope;\n\t    var OriginalRange = window.Range;\n\t    var ShadowRoot = scope.wrappers.ShadowRoot;\n\t    function getHost(node) {\n\t      var root = getTreeScope(node).root;\n\t      if (root instanceof ShadowRoot) {\n\t        return root.host;\n\t      }\n\t      return null;\n\t    }\n\t    function hostNodeToShadowNode(refNode, offset) {\n\t      if (refNode.shadowRoot) {\n\t        offset = Math.min(refNode.childNodes.length - 1, offset);\n\t        var child = refNode.childNodes[offset];\n\t        if (child) {\n\t          var insertionPoint = scope.getDestinationInsertionPoints(child);\n\t          if (insertionPoint.length > 0) {\n\t            var parentNode = insertionPoint[0].parentNode;\n\t            if (parentNode.nodeType == Node.ELEMENT_NODE) {\n\t              refNode = parentNode;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      return refNode;\n\t    }\n\t    function shadowNodeToHostNode(node) {\n\t      node = wrap(node);\n\t      return getHost(node) || node;\n\t    }\n\t    function Range(impl) {\n\t      setWrapper(impl, this);\n\t    }\n\t    Range.prototype = {\n\t      get startContainer() {\n\t        return shadowNodeToHostNode(unsafeUnwrap(this).startContainer);\n\t      },\n\t      get endContainer() {\n\t        return shadowNodeToHostNode(unsafeUnwrap(this).endContainer);\n\t      },\n\t      get commonAncestorContainer() {\n\t        return shadowNodeToHostNode(unsafeUnwrap(this).commonAncestorContainer);\n\t      },\n\t      setStart: function(refNode, offset) {\n\t        refNode = hostNodeToShadowNode(refNode, offset);\n\t        unsafeUnwrap(this).setStart(unwrapIfNeeded(refNode), offset);\n\t      },\n\t      setEnd: function(refNode, offset) {\n\t        refNode = hostNodeToShadowNode(refNode, offset);\n\t        unsafeUnwrap(this).setEnd(unwrapIfNeeded(refNode), offset);\n\t      },\n\t      setStartBefore: function(refNode) {\n\t        unsafeUnwrap(this).setStartBefore(unwrapIfNeeded(refNode));\n\t      },\n\t      setStartAfter: function(refNode) {\n\t        unsafeUnwrap(this).setStartAfter(unwrapIfNeeded(refNode));\n\t      },\n\t      setEndBefore: function(refNode) {\n\t        unsafeUnwrap(this).setEndBefore(unwrapIfNeeded(refNode));\n\t      },\n\t      setEndAfter: function(refNode) {\n\t        unsafeUnwrap(this).setEndAfter(unwrapIfNeeded(refNode));\n\t      },\n\t      selectNode: function(refNode) {\n\t        unsafeUnwrap(this).selectNode(unwrapIfNeeded(refNode));\n\t      },\n\t      selectNodeContents: function(refNode) {\n\t        unsafeUnwrap(this).selectNodeContents(unwrapIfNeeded(refNode));\n\t      },\n\t      compareBoundaryPoints: function(how, sourceRange) {\n\t        return unsafeUnwrap(this).compareBoundaryPoints(how, unwrap(sourceRange));\n\t      },\n\t      extractContents: function() {\n\t        return wrap(unsafeUnwrap(this).extractContents());\n\t      },\n\t      cloneContents: function() {\n\t        return wrap(unsafeUnwrap(this).cloneContents());\n\t      },\n\t      insertNode: function(node) {\n\t        unsafeUnwrap(this).insertNode(unwrapIfNeeded(node));\n\t      },\n\t      surroundContents: function(newParent) {\n\t        unsafeUnwrap(this).surroundContents(unwrapIfNeeded(newParent));\n\t      },\n\t      cloneRange: function() {\n\t        return wrap(unsafeUnwrap(this).cloneRange());\n\t      },\n\t      isPointInRange: function(node, offset) {\n\t        return unsafeUnwrap(this).isPointInRange(unwrapIfNeeded(node), offset);\n\t      },\n\t      comparePoint: function(node, offset) {\n\t        return unsafeUnwrap(this).comparePoint(unwrapIfNeeded(node), offset);\n\t      },\n\t      intersectsNode: function(node) {\n\t        return unsafeUnwrap(this).intersectsNode(unwrapIfNeeded(node));\n\t      },\n\t      toString: function() {\n\t        return unsafeUnwrap(this).toString();\n\t      }\n\t    };\n\t    if (OriginalRange.prototype.createContextualFragment) {\n\t      Range.prototype.createContextualFragment = function(html) {\n\t        return wrap(unsafeUnwrap(this).createContextualFragment(html));\n\t      };\n\t    }\n\t    registerWrapper(window.Range, Range, document.createRange());\n\t    scope.wrappers.Range = Range;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var Element = scope.wrappers.Element;\n\t    var HTMLContentElement = scope.wrappers.HTMLContentElement;\n\t    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n\t    var Node = scope.wrappers.Node;\n\t    var ShadowRoot = scope.wrappers.ShadowRoot;\n\t    var assert = scope.assert;\n\t    var getTreeScope = scope.getTreeScope;\n\t    var mixin = scope.mixin;\n\t    var oneOf = scope.oneOf;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var ArraySplice = scope.ArraySplice;\n\t    function updateWrapperUpAndSideways(wrapper) {\n\t      wrapper.previousSibling_ = wrapper.previousSibling;\n\t      wrapper.nextSibling_ = wrapper.nextSibling;\n\t      wrapper.parentNode_ = wrapper.parentNode;\n\t    }\n\t    function updateWrapperDown(wrapper) {\n\t      wrapper.firstChild_ = wrapper.firstChild;\n\t      wrapper.lastChild_ = wrapper.lastChild;\n\t    }\n\t    function updateAllChildNodes(parentNodeWrapper) {\n\t      assert(parentNodeWrapper instanceof Node);\n\t      for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {\n\t        updateWrapperUpAndSideways(childWrapper);\n\t      }\n\t      updateWrapperDown(parentNodeWrapper);\n\t    }\n\t    function insertBefore(parentNodeWrapper, newChildWrapper, refChildWrapper) {\n\t      var parentNode = unwrap(parentNodeWrapper);\n\t      var newChild = unwrap(newChildWrapper);\n\t      var refChild = refChildWrapper ? unwrap(refChildWrapper) : null;\n\t      remove(newChildWrapper);\n\t      updateWrapperUpAndSideways(newChildWrapper);\n\t      if (!refChildWrapper) {\n\t        parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;\n\t        if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild) parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;\n\t        var lastChildWrapper = wrap(parentNode.lastChild);\n\t        if (lastChildWrapper) lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;\n\t      } else {\n\t        if (parentNodeWrapper.firstChild === refChildWrapper) parentNodeWrapper.firstChild_ = refChildWrapper;\n\t        refChildWrapper.previousSibling_ = refChildWrapper.previousSibling;\n\t      }\n\t      scope.originalInsertBefore.call(parentNode, newChild, refChild);\n\t    }\n\t    function remove(nodeWrapper) {\n\t      var node = unwrap(nodeWrapper);\n\t      var parentNode = node.parentNode;\n\t      if (!parentNode) return;\n\t      var parentNodeWrapper = wrap(parentNode);\n\t      updateWrapperUpAndSideways(nodeWrapper);\n\t      if (nodeWrapper.previousSibling) nodeWrapper.previousSibling.nextSibling_ = nodeWrapper;\n\t      if (nodeWrapper.nextSibling) nodeWrapper.nextSibling.previousSibling_ = nodeWrapper;\n\t      if (parentNodeWrapper.lastChild === nodeWrapper) parentNodeWrapper.lastChild_ = nodeWrapper;\n\t      if (parentNodeWrapper.firstChild === nodeWrapper) parentNodeWrapper.firstChild_ = nodeWrapper;\n\t      scope.originalRemoveChild.call(parentNode, node);\n\t    }\n\t    var distributedNodesTable = new WeakMap();\n\t    var destinationInsertionPointsTable = new WeakMap();\n\t    var rendererForHostTable = new WeakMap();\n\t    function resetDistributedNodes(insertionPoint) {\n\t      distributedNodesTable.set(insertionPoint, []);\n\t    }\n\t    function getDistributedNodes(insertionPoint) {\n\t      var rv = distributedNodesTable.get(insertionPoint);\n\t      if (!rv) distributedNodesTable.set(insertionPoint, rv = []);\n\t      return rv;\n\t    }\n\t    function getChildNodesSnapshot(node) {\n\t      var result = [], i = 0;\n\t      for (var child = node.firstChild; child; child = child.nextSibling) {\n\t        result[i++] = child;\n\t      }\n\t      return result;\n\t    }\n\t    var request = oneOf(window, [ \"requestAnimationFrame\", \"mozRequestAnimationFrame\", \"webkitRequestAnimationFrame\", \"setTimeout\" ]);\n\t    var pendingDirtyRenderers = [];\n\t    var renderTimer;\n\t    function renderAllPending() {\n\t      for (var i = 0; i < pendingDirtyRenderers.length; i++) {\n\t        var renderer = pendingDirtyRenderers[i];\n\t        var parentRenderer = renderer.parentRenderer;\n\t        if (parentRenderer && parentRenderer.dirty) continue;\n\t        renderer.render();\n\t      }\n\t      pendingDirtyRenderers = [];\n\t    }\n\t    function handleRequestAnimationFrame() {\n\t      renderTimer = null;\n\t      renderAllPending();\n\t    }\n\t    function getRendererForHost(host) {\n\t      var renderer = rendererForHostTable.get(host);\n\t      if (!renderer) {\n\t        renderer = new ShadowRenderer(host);\n\t        rendererForHostTable.set(host, renderer);\n\t      }\n\t      return renderer;\n\t    }\n\t    function getShadowRootAncestor(node) {\n\t      var root = getTreeScope(node).root;\n\t      if (root instanceof ShadowRoot) return root;\n\t      return null;\n\t    }\n\t    function getRendererForShadowRoot(shadowRoot) {\n\t      return getRendererForHost(shadowRoot.host);\n\t    }\n\t    var spliceDiff = new ArraySplice();\n\t    spliceDiff.equals = function(renderNode, rawNode) {\n\t      return unwrap(renderNode.node) === rawNode;\n\t    };\n\t    function RenderNode(node) {\n\t      this.skip = false;\n\t      this.node = node;\n\t      this.childNodes = [];\n\t    }\n\t    RenderNode.prototype = {\n\t      append: function(node) {\n\t        var rv = new RenderNode(node);\n\t        this.childNodes.push(rv);\n\t        return rv;\n\t      },\n\t      sync: function(opt_added) {\n\t        if (this.skip) return;\n\t        var nodeWrapper = this.node;\n\t        var newChildren = this.childNodes;\n\t        var oldChildren = getChildNodesSnapshot(unwrap(nodeWrapper));\n\t        var added = opt_added || new WeakMap();\n\t        var splices = spliceDiff.calculateSplices(newChildren, oldChildren);\n\t        var newIndex = 0, oldIndex = 0;\n\t        var lastIndex = 0;\n\t        for (var i = 0; i < splices.length; i++) {\n\t          var splice = splices[i];\n\t          for (;lastIndex < splice.index; lastIndex++) {\n\t            oldIndex++;\n\t            newChildren[newIndex++].sync(added);\n\t          }\n\t          var removedCount = splice.removed.length;\n\t          for (var j = 0; j < removedCount; j++) {\n\t            var wrapper = wrap(oldChildren[oldIndex++]);\n\t            if (!added.get(wrapper)) remove(wrapper);\n\t          }\n\t          var addedCount = splice.addedCount;\n\t          var refNode = oldChildren[oldIndex] && wrap(oldChildren[oldIndex]);\n\t          for (var j = 0; j < addedCount; j++) {\n\t            var newChildRenderNode = newChildren[newIndex++];\n\t            var newChildWrapper = newChildRenderNode.node;\n\t            insertBefore(nodeWrapper, newChildWrapper, refNode);\n\t            added.set(newChildWrapper, true);\n\t            newChildRenderNode.sync(added);\n\t          }\n\t          lastIndex += addedCount;\n\t        }\n\t        for (var i = lastIndex; i < newChildren.length; i++) {\n\t          newChildren[i].sync(added);\n\t        }\n\t      }\n\t    };\n\t    function ShadowRenderer(host) {\n\t      this.host = host;\n\t      this.dirty = false;\n\t      this.invalidateAttributes();\n\t      this.associateNode(host);\n\t    }\n\t    ShadowRenderer.prototype = {\n\t      render: function(opt_renderNode) {\n\t        if (!this.dirty) return;\n\t        this.invalidateAttributes();\n\t        var host = this.host;\n\t        this.distribution(host);\n\t        var renderNode = opt_renderNode || new RenderNode(host);\n\t        this.buildRenderTree(renderNode, host);\n\t        var topMostRenderer = !opt_renderNode;\n\t        if (topMostRenderer) renderNode.sync();\n\t        this.dirty = false;\n\t      },\n\t      get parentRenderer() {\n\t        return getTreeScope(this.host).renderer;\n\t      },\n\t      invalidate: function() {\n\t        if (!this.dirty) {\n\t          this.dirty = true;\n\t          var parentRenderer = this.parentRenderer;\n\t          if (parentRenderer) parentRenderer.invalidate();\n\t          pendingDirtyRenderers.push(this);\n\t          if (renderTimer) return;\n\t          renderTimer = window[request](handleRequestAnimationFrame, 0);\n\t        }\n\t      },\n\t      distribution: function(root) {\n\t        this.resetAllSubtrees(root);\n\t        this.distributionResolution(root);\n\t      },\n\t      resetAll: function(node) {\n\t        if (isInsertionPoint(node)) resetDistributedNodes(node); else resetDestinationInsertionPoints(node);\n\t        this.resetAllSubtrees(node);\n\t      },\n\t      resetAllSubtrees: function(node) {\n\t        for (var child = node.firstChild; child; child = child.nextSibling) {\n\t          this.resetAll(child);\n\t        }\n\t        if (node.shadowRoot) this.resetAll(node.shadowRoot);\n\t        if (node.olderShadowRoot) this.resetAll(node.olderShadowRoot);\n\t      },\n\t      distributionResolution: function(node) {\n\t        if (isShadowHost(node)) {\n\t          var shadowHost = node;\n\t          var pool = poolPopulation(shadowHost);\n\t          var shadowTrees = getShadowTrees(shadowHost);\n\t          for (var i = 0; i < shadowTrees.length; i++) {\n\t            this.poolDistribution(shadowTrees[i], pool);\n\t          }\n\t          for (var i = shadowTrees.length - 1; i >= 0; i--) {\n\t            var shadowTree = shadowTrees[i];\n\t            var shadow = getShadowInsertionPoint(shadowTree);\n\t            if (shadow) {\n\t              var olderShadowRoot = shadowTree.olderShadowRoot;\n\t              if (olderShadowRoot) {\n\t                pool = poolPopulation(olderShadowRoot);\n\t              }\n\t              for (var j = 0; j < pool.length; j++) {\n\t                destributeNodeInto(pool[j], shadow);\n\t              }\n\t            }\n\t            this.distributionResolution(shadowTree);\n\t          }\n\t        }\n\t        for (var child = node.firstChild; child; child = child.nextSibling) {\n\t          this.distributionResolution(child);\n\t        }\n\t      },\n\t      poolDistribution: function(node, pool) {\n\t        if (node instanceof HTMLShadowElement) return;\n\t        if (node instanceof HTMLContentElement) {\n\t          var content = node;\n\t          this.updateDependentAttributes(content.getAttribute(\"select\"));\n\t          var anyDistributed = false;\n\t          for (var i = 0; i < pool.length; i++) {\n\t            var node = pool[i];\n\t            if (!node) continue;\n\t            if (matches(node, content)) {\n\t              destributeNodeInto(node, content);\n\t              pool[i] = undefined;\n\t              anyDistributed = true;\n\t            }\n\t          }\n\t          if (!anyDistributed) {\n\t            for (var child = content.firstChild; child; child = child.nextSibling) {\n\t              destributeNodeInto(child, content);\n\t            }\n\t          }\n\t          return;\n\t        }\n\t        for (var child = node.firstChild; child; child = child.nextSibling) {\n\t          this.poolDistribution(child, pool);\n\t        }\n\t      },\n\t      buildRenderTree: function(renderNode, node) {\n\t        var children = this.compose(node);\n\t        for (var i = 0; i < children.length; i++) {\n\t          var child = children[i];\n\t          var childRenderNode = renderNode.append(child);\n\t          this.buildRenderTree(childRenderNode, child);\n\t        }\n\t        if (isShadowHost(node)) {\n\t          var renderer = getRendererForHost(node);\n\t          renderer.dirty = false;\n\t        }\n\t      },\n\t      compose: function(node) {\n\t        var children = [];\n\t        var p = node.shadowRoot || node;\n\t        for (var child = p.firstChild; child; child = child.nextSibling) {\n\t          if (isInsertionPoint(child)) {\n\t            this.associateNode(p);\n\t            var distributedNodes = getDistributedNodes(child);\n\t            for (var j = 0; j < distributedNodes.length; j++) {\n\t              var distributedNode = distributedNodes[j];\n\t              if (isFinalDestination(child, distributedNode)) children.push(distributedNode);\n\t            }\n\t          } else {\n\t            children.push(child);\n\t          }\n\t        }\n\t        return children;\n\t      },\n\t      invalidateAttributes: function() {\n\t        this.attributes = Object.create(null);\n\t      },\n\t      updateDependentAttributes: function(selector) {\n\t        if (!selector) return;\n\t        var attributes = this.attributes;\n\t        if (/\\.\\w+/.test(selector)) attributes[\"class\"] = true;\n\t        if (/#\\w+/.test(selector)) attributes[\"id\"] = true;\n\t        selector.replace(/\\[\\s*([^\\s=\\|~\\]]+)/g, function(_, name) {\n\t          attributes[name] = true;\n\t        });\n\t      },\n\t      dependsOnAttribute: function(name) {\n\t        return this.attributes[name];\n\t      },\n\t      associateNode: function(node) {\n\t        unsafeUnwrap(node).polymerShadowRenderer_ = this;\n\t      }\n\t    };\n\t    function poolPopulation(node) {\n\t      var pool = [];\n\t      for (var child = node.firstChild; child; child = child.nextSibling) {\n\t        if (isInsertionPoint(child)) {\n\t          pool.push.apply(pool, getDistributedNodes(child));\n\t        } else {\n\t          pool.push(child);\n\t        }\n\t      }\n\t      return pool;\n\t    }\n\t    function getShadowInsertionPoint(node) {\n\t      if (node instanceof HTMLShadowElement) return node;\n\t      if (node instanceof HTMLContentElement) return null;\n\t      for (var child = node.firstChild; child; child = child.nextSibling) {\n\t        var res = getShadowInsertionPoint(child);\n\t        if (res) return res;\n\t      }\n\t      return null;\n\t    }\n\t    function destributeNodeInto(child, insertionPoint) {\n\t      getDistributedNodes(insertionPoint).push(child);\n\t      var points = destinationInsertionPointsTable.get(child);\n\t      if (!points) destinationInsertionPointsTable.set(child, [ insertionPoint ]); else points.push(insertionPoint);\n\t    }\n\t    function getDestinationInsertionPoints(node) {\n\t      return destinationInsertionPointsTable.get(node);\n\t    }\n\t    function resetDestinationInsertionPoints(node) {\n\t      destinationInsertionPointsTable.set(node, undefined);\n\t    }\n\t    var selectorStartCharRe = /^(:not\\()?[*.#[a-zA-Z_|]/;\n\t    function matches(node, contentElement) {\n\t      var select = contentElement.getAttribute(\"select\");\n\t      if (!select) return true;\n\t      select = select.trim();\n\t      if (!select) return true;\n\t      if (!(node instanceof Element)) return false;\n\t      if (!selectorStartCharRe.test(select)) return false;\n\t      try {\n\t        return node.matches(select);\n\t      } catch (ex) {\n\t        return false;\n\t      }\n\t    }\n\t    function isFinalDestination(insertionPoint, node) {\n\t      var points = getDestinationInsertionPoints(node);\n\t      return points && points[points.length - 1] === insertionPoint;\n\t    }\n\t    function isInsertionPoint(node) {\n\t      return node instanceof HTMLContentElement || node instanceof HTMLShadowElement;\n\t    }\n\t    function isShadowHost(shadowHost) {\n\t      return shadowHost.shadowRoot;\n\t    }\n\t    function getShadowTrees(host) {\n\t      var trees = [];\n\t      for (var tree = host.shadowRoot; tree; tree = tree.olderShadowRoot) {\n\t        trees.push(tree);\n\t      }\n\t      return trees;\n\t    }\n\t    function render(host) {\n\t      new ShadowRenderer(host).render();\n\t    }\n\t    Node.prototype.invalidateShadowRenderer = function(force) {\n\t      var renderer = unsafeUnwrap(this).polymerShadowRenderer_;\n\t      if (renderer) {\n\t        renderer.invalidate();\n\t        return true;\n\t      }\n\t      return false;\n\t    };\n\t    HTMLContentElement.prototype.getDistributedNodes = HTMLShadowElement.prototype.getDistributedNodes = function() {\n\t      renderAllPending();\n\t      return getDistributedNodes(this);\n\t    };\n\t    Element.prototype.getDestinationInsertionPoints = function() {\n\t      renderAllPending();\n\t      return getDestinationInsertionPoints(this) || [];\n\t    };\n\t    HTMLContentElement.prototype.nodeIsInserted_ = HTMLShadowElement.prototype.nodeIsInserted_ = function() {\n\t      this.invalidateShadowRenderer();\n\t      var shadowRoot = getShadowRootAncestor(this);\n\t      var renderer;\n\t      if (shadowRoot) renderer = getRendererForShadowRoot(shadowRoot);\n\t      unsafeUnwrap(this).polymerShadowRenderer_ = renderer;\n\t      if (renderer) renderer.invalidate();\n\t    };\n\t    scope.getRendererForHost = getRendererForHost;\n\t    scope.getShadowTrees = getShadowTrees;\n\t    scope.renderAllPending = renderAllPending;\n\t    scope.getDestinationInsertionPoints = getDestinationInsertionPoints;\n\t    scope.visual = {\n\t      insertBefore: insertBefore,\n\t      remove: remove\n\t    };\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var HTMLElement = scope.wrappers.HTMLElement;\n\t    var assert = scope.assert;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var elementsWithFormProperty = [ \"HTMLButtonElement\", \"HTMLFieldSetElement\", \"HTMLInputElement\", \"HTMLKeygenElement\", \"HTMLLabelElement\", \"HTMLLegendElement\", \"HTMLObjectElement\", \"HTMLOutputElement\", \"HTMLTextAreaElement\" ];\n\t    function createWrapperConstructor(name) {\n\t      if (!window[name]) return;\n\t      assert(!scope.wrappers[name]);\n\t      var GeneratedWrapper = function(node) {\n\t        HTMLElement.call(this, node);\n\t      };\n\t      GeneratedWrapper.prototype = Object.create(HTMLElement.prototype);\n\t      mixin(GeneratedWrapper.prototype, {\n\t        get form() {\n\t          return wrap(unwrap(this).form);\n\t        }\n\t      });\n\t      registerWrapper(window[name], GeneratedWrapper, document.createElement(name.slice(4, -7)));\n\t      scope.wrappers[name] = GeneratedWrapper;\n\t    }\n\t    elementsWithFormProperty.forEach(createWrapperConstructor);\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var registerWrapper = scope.registerWrapper;\n\t    var setWrapper = scope.setWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrap = scope.unwrap;\n\t    var unwrapIfNeeded = scope.unwrapIfNeeded;\n\t    var wrap = scope.wrap;\n\t    var OriginalSelection = window.Selection;\n\t    function Selection(impl) {\n\t      setWrapper(impl, this);\n\t    }\n\t    Selection.prototype = {\n\t      get anchorNode() {\n\t        return wrap(unsafeUnwrap(this).anchorNode);\n\t      },\n\t      get focusNode() {\n\t        return wrap(unsafeUnwrap(this).focusNode);\n\t      },\n\t      addRange: function(range) {\n\t        unsafeUnwrap(this).addRange(unwrapIfNeeded(range));\n\t      },\n\t      collapse: function(node, index) {\n\t        unsafeUnwrap(this).collapse(unwrapIfNeeded(node), index);\n\t      },\n\t      containsNode: function(node, allowPartial) {\n\t        return unsafeUnwrap(this).containsNode(unwrapIfNeeded(node), allowPartial);\n\t      },\n\t      getRangeAt: function(index) {\n\t        return wrap(unsafeUnwrap(this).getRangeAt(index));\n\t      },\n\t      removeRange: function(range) {\n\t        unsafeUnwrap(this).removeRange(unwrap(range));\n\t      },\n\t      selectAllChildren: function(node) {\n\t        unsafeUnwrap(this).selectAllChildren(node instanceof ShadowRoot ? unsafeUnwrap(node.host) : unwrapIfNeeded(node));\n\t      },\n\t      toString: function() {\n\t        return unsafeUnwrap(this).toString();\n\t      }\n\t    };\n\t    if (OriginalSelection.prototype.extend) {\n\t      Selection.prototype.extend = function(node, offset) {\n\t        unsafeUnwrap(this).extend(unwrapIfNeeded(node), offset);\n\t      };\n\t    }\n\t    registerWrapper(window.Selection, Selection, window.getSelection());\n\t    scope.wrappers.Selection = Selection;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var registerWrapper = scope.registerWrapper;\n\t    var setWrapper = scope.setWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrapIfNeeded = scope.unwrapIfNeeded;\n\t    var wrap = scope.wrap;\n\t    var OriginalTreeWalker = window.TreeWalker;\n\t    function TreeWalker(impl) {\n\t      setWrapper(impl, this);\n\t    }\n\t    TreeWalker.prototype = {\n\t      get root() {\n\t        return wrap(unsafeUnwrap(this).root);\n\t      },\n\t      get currentNode() {\n\t        return wrap(unsafeUnwrap(this).currentNode);\n\t      },\n\t      set currentNode(node) {\n\t        unsafeUnwrap(this).currentNode = unwrapIfNeeded(node);\n\t      },\n\t      get filter() {\n\t        return unsafeUnwrap(this).filter;\n\t      },\n\t      parentNode: function() {\n\t        return wrap(unsafeUnwrap(this).parentNode());\n\t      },\n\t      firstChild: function() {\n\t        return wrap(unsafeUnwrap(this).firstChild());\n\t      },\n\t      lastChild: function() {\n\t        return wrap(unsafeUnwrap(this).lastChild());\n\t      },\n\t      previousSibling: function() {\n\t        return wrap(unsafeUnwrap(this).previousSibling());\n\t      },\n\t      previousNode: function() {\n\t        return wrap(unsafeUnwrap(this).previousNode());\n\t      },\n\t      nextNode: function() {\n\t        return wrap(unsafeUnwrap(this).nextNode());\n\t      }\n\t    };\n\t    registerWrapper(OriginalTreeWalker, TreeWalker);\n\t    scope.wrappers.TreeWalker = TreeWalker;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var GetElementsByInterface = scope.GetElementsByInterface;\n\t    var Node = scope.wrappers.Node;\n\t    var ParentNodeInterface = scope.ParentNodeInterface;\n\t    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\n\t    var Selection = scope.wrappers.Selection;\n\t    var SelectorsInterface = scope.SelectorsInterface;\n\t    var ShadowRoot = scope.wrappers.ShadowRoot;\n\t    var TreeScope = scope.TreeScope;\n\t    var cloneNode = scope.cloneNode;\n\t    var defineGetter = scope.defineGetter;\n\t    var defineWrapGetter = scope.defineWrapGetter;\n\t    var elementFromPoint = scope.elementFromPoint;\n\t    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n\t    var matchesNames = scope.matchesNames;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var renderAllPending = scope.renderAllPending;\n\t    var rewrap = scope.rewrap;\n\t    var setWrapper = scope.setWrapper;\n\t    var unsafeUnwrap = scope.unsafeUnwrap;\n\t    var unwrap = scope.unwrap;\n\t    var wrap = scope.wrap;\n\t    var wrapEventTargetMethods = scope.wrapEventTargetMethods;\n\t    var wrapNodeList = scope.wrapNodeList;\n\t    var implementationTable = new WeakMap();\n\t    function Document(node) {\n\t      Node.call(this, node);\n\t      this.treeScope_ = new TreeScope(this, null);\n\t    }\n\t    Document.prototype = Object.create(Node.prototype);\n\t    defineWrapGetter(Document, \"documentElement\");\n\t    defineWrapGetter(Document, \"body\");\n\t    defineWrapGetter(Document, \"head\");\n\t    defineGetter(Document, \"activeElement\", function() {\n\t      var unwrappedActiveElement = unwrap(this).activeElement;\n\t      if (!unwrappedActiveElement || !unwrappedActiveElement.nodeType) return null;\n\t      var activeElement = wrap(unwrappedActiveElement);\n\t      while (!this.contains(activeElement)) {\n\t        while (activeElement.parentNode) {\n\t          activeElement = activeElement.parentNode;\n\t        }\n\t        if (activeElement.host) {\n\t          activeElement = activeElement.host;\n\t        } else {\n\t          return null;\n\t        }\n\t      }\n\t      return activeElement;\n\t    });\n\t    function wrapMethod(name) {\n\t      var original = document[name];\n\t      Document.prototype[name] = function() {\n\t        return wrap(original.apply(unsafeUnwrap(this), arguments));\n\t      };\n\t    }\n\t    [ \"createComment\", \"createDocumentFragment\", \"createElement\", \"createElementNS\", \"createEvent\", \"createEventNS\", \"createRange\", \"createTextNode\" ].forEach(wrapMethod);\n\t    var originalAdoptNode = document.adoptNode;\n\t    function adoptNodeNoRemove(node, doc) {\n\t      originalAdoptNode.call(unsafeUnwrap(doc), unwrap(node));\n\t      adoptSubtree(node, doc);\n\t    }\n\t    function adoptSubtree(node, doc) {\n\t      if (node.shadowRoot) doc.adoptNode(node.shadowRoot);\n\t      if (node instanceof ShadowRoot) adoptOlderShadowRoots(node, doc);\n\t      for (var child = node.firstChild; child; child = child.nextSibling) {\n\t        adoptSubtree(child, doc);\n\t      }\n\t    }\n\t    function adoptOlderShadowRoots(shadowRoot, doc) {\n\t      var oldShadowRoot = shadowRoot.olderShadowRoot;\n\t      if (oldShadowRoot) doc.adoptNode(oldShadowRoot);\n\t    }\n\t    var originalGetSelection = document.getSelection;\n\t    mixin(Document.prototype, {\n\t      adoptNode: function(node) {\n\t        if (node.parentNode) node.parentNode.removeChild(node);\n\t        adoptNodeNoRemove(node, this);\n\t        return node;\n\t      },\n\t      elementFromPoint: function(x, y) {\n\t        return elementFromPoint(this, this, x, y);\n\t      },\n\t      importNode: function(node, deep) {\n\t        return cloneNode(node, deep, unsafeUnwrap(this));\n\t      },\n\t      getSelection: function() {\n\t        renderAllPending();\n\t        return new Selection(originalGetSelection.call(unwrap(this)));\n\t      },\n\t      getElementsByName: function(name) {\n\t        return SelectorsInterface.querySelectorAll.call(this, \"[name=\" + JSON.stringify(String(name)) + \"]\");\n\t      }\n\t    });\n\t    var originalCreateTreeWalker = document.createTreeWalker;\n\t    var TreeWalkerWrapper = scope.wrappers.TreeWalker;\n\t    Document.prototype.createTreeWalker = function(root, whatToShow, filter, expandEntityReferences) {\n\t      var newFilter = null;\n\t      if (filter) {\n\t        if (filter.acceptNode && typeof filter.acceptNode === \"function\") {\n\t          newFilter = {\n\t            acceptNode: function(node) {\n\t              return filter.acceptNode(wrap(node));\n\t            }\n\t          };\n\t        } else if (typeof filter === \"function\") {\n\t          newFilter = function(node) {\n\t            return filter(wrap(node));\n\t          };\n\t        }\n\t      }\n\t      return new TreeWalkerWrapper(originalCreateTreeWalker.call(unwrap(this), unwrap(root), whatToShow, newFilter, expandEntityReferences));\n\t    };\n\t    if (document.registerElement) {\n\t      var originalRegisterElement = document.registerElement;\n\t      Document.prototype.registerElement = function(tagName, object) {\n\t        var prototype, extendsOption;\n\t        if (object !== undefined) {\n\t          prototype = object.prototype;\n\t          extendsOption = object.extends;\n\t        }\n\t        if (!prototype) prototype = Object.create(HTMLElement.prototype);\n\t        if (scope.nativePrototypeTable.get(prototype)) {\n\t          throw new Error(\"NotSupportedError\");\n\t        }\n\t        var proto = Object.getPrototypeOf(prototype);\n\t        var nativePrototype;\n\t        var prototypes = [];\n\t        while (proto) {\n\t          nativePrototype = scope.nativePrototypeTable.get(proto);\n\t          if (nativePrototype) break;\n\t          prototypes.push(proto);\n\t          proto = Object.getPrototypeOf(proto);\n\t        }\n\t        if (!nativePrototype) {\n\t          throw new Error(\"NotSupportedError\");\n\t        }\n\t        var newPrototype = Object.create(nativePrototype);\n\t        for (var i = prototypes.length - 1; i >= 0; i--) {\n\t          newPrototype = Object.create(newPrototype);\n\t        }\n\t        [ \"createdCallback\", \"attachedCallback\", \"detachedCallback\", \"attributeChangedCallback\" ].forEach(function(name) {\n\t          var f = prototype[name];\n\t          if (!f) return;\n\t          newPrototype[name] = function() {\n\t            if (!(wrap(this) instanceof CustomElementConstructor)) {\n\t              rewrap(this);\n\t            }\n\t            f.apply(wrap(this), arguments);\n\t          };\n\t        });\n\t        var p = {\n\t          prototype: newPrototype\n\t        };\n\t        if (extendsOption) p.extends = extendsOption;\n\t        function CustomElementConstructor(node) {\n\t          if (!node) {\n\t            if (extendsOption) {\n\t              return document.createElement(extendsOption, tagName);\n\t            } else {\n\t              return document.createElement(tagName);\n\t            }\n\t          }\n\t          setWrapper(node, this);\n\t        }\n\t        CustomElementConstructor.prototype = prototype;\n\t        CustomElementConstructor.prototype.constructor = CustomElementConstructor;\n\t        scope.constructorTable.set(newPrototype, CustomElementConstructor);\n\t        scope.nativePrototypeTable.set(prototype, newPrototype);\n\t        var nativeConstructor = originalRegisterElement.call(unwrap(this), tagName, p);\n\t        return CustomElementConstructor;\n\t      };\n\t      forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ \"registerElement\" ]);\n\t    }\n\t    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement, window.HTMLHtmlElement ], [ \"appendChild\", \"compareDocumentPosition\", \"contains\", \"getElementsByClassName\", \"getElementsByTagName\", \"getElementsByTagNameNS\", \"insertBefore\", \"querySelector\", \"querySelectorAll\", \"removeChild\", \"replaceChild\" ]);\n\t    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLHeadElement, window.HTMLHtmlElement ], matchesNames);\n\t    forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ \"adoptNode\", \"importNode\", \"contains\", \"createComment\", \"createDocumentFragment\", \"createElement\", \"createElementNS\", \"createEvent\", \"createEventNS\", \"createRange\", \"createTextNode\", \"createTreeWalker\", \"elementFromPoint\", \"getElementById\", \"getElementsByName\", \"getSelection\" ]);\n\t    mixin(Document.prototype, GetElementsByInterface);\n\t    mixin(Document.prototype, ParentNodeInterface);\n\t    mixin(Document.prototype, SelectorsInterface);\n\t    mixin(Document.prototype, NonElementParentNodeInterface);\n\t    mixin(Document.prototype, {\n\t      get implementation() {\n\t        var implementation = implementationTable.get(this);\n\t        if (implementation) return implementation;\n\t        implementation = new DOMImplementation(unwrap(this).implementation);\n\t        implementationTable.set(this, implementation);\n\t        return implementation;\n\t      },\n\t      get defaultView() {\n\t        return wrap(unwrap(this).defaultView);\n\t      }\n\t    });\n\t    registerWrapper(window.Document, Document, document.implementation.createHTMLDocument(\"\"));\n\t    if (window.HTMLDocument) registerWrapper(window.HTMLDocument, Document);\n\t    wrapEventTargetMethods([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement ]);\n\t    function DOMImplementation(impl) {\n\t      setWrapper(impl, this);\n\t    }\n\t    var originalCreateDocument = document.implementation.createDocument;\n\t    DOMImplementation.prototype.createDocument = function() {\n\t      arguments[2] = unwrap(arguments[2]);\n\t      return wrap(originalCreateDocument.apply(unsafeUnwrap(this), arguments));\n\t    };\n\t    function wrapImplMethod(constructor, name) {\n\t      var original = document.implementation[name];\n\t      constructor.prototype[name] = function() {\n\t        return wrap(original.apply(unsafeUnwrap(this), arguments));\n\t      };\n\t    }\n\t    function forwardImplMethod(constructor, name) {\n\t      var original = document.implementation[name];\n\t      constructor.prototype[name] = function() {\n\t        return original.apply(unsafeUnwrap(this), arguments);\n\t      };\n\t    }\n\t    wrapImplMethod(DOMImplementation, \"createDocumentType\");\n\t    wrapImplMethod(DOMImplementation, \"createHTMLDocument\");\n\t    forwardImplMethod(DOMImplementation, \"hasFeature\");\n\t    registerWrapper(window.DOMImplementation, DOMImplementation);\n\t    forwardMethodsToWrapper([ window.DOMImplementation ], [ \"createDocument\", \"createDocumentType\", \"createHTMLDocument\", \"hasFeature\" ]);\n\t    scope.adoptNodeNoRemove = adoptNodeNoRemove;\n\t    scope.wrappers.DOMImplementation = DOMImplementation;\n\t    scope.wrappers.Document = Document;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var EventTarget = scope.wrappers.EventTarget;\n\t    var Selection = scope.wrappers.Selection;\n\t    var mixin = scope.mixin;\n\t    var registerWrapper = scope.registerWrapper;\n\t    var renderAllPending = scope.renderAllPending;\n\t    var unwrap = scope.unwrap;\n\t    var unwrapIfNeeded = scope.unwrapIfNeeded;\n\t    var wrap = scope.wrap;\n\t    var OriginalWindow = window.Window;\n\t    var originalGetComputedStyle = window.getComputedStyle;\n\t    var originalGetDefaultComputedStyle = window.getDefaultComputedStyle;\n\t    var originalGetSelection = window.getSelection;\n\t    function Window(impl) {\n\t      EventTarget.call(this, impl);\n\t    }\n\t    Window.prototype = Object.create(EventTarget.prototype);\n\t    OriginalWindow.prototype.getComputedStyle = function(el, pseudo) {\n\t      return wrap(this || window).getComputedStyle(unwrapIfNeeded(el), pseudo);\n\t    };\n\t    if (originalGetDefaultComputedStyle) {\n\t      OriginalWindow.prototype.getDefaultComputedStyle = function(el, pseudo) {\n\t        return wrap(this || window).getDefaultComputedStyle(unwrapIfNeeded(el), pseudo);\n\t      };\n\t    }\n\t    OriginalWindow.prototype.getSelection = function() {\n\t      return wrap(this || window).getSelection();\n\t    };\n\t    delete window.getComputedStyle;\n\t    delete window.getDefaultComputedStyle;\n\t    delete window.getSelection;\n\t    [ \"addEventListener\", \"removeEventListener\", \"dispatchEvent\" ].forEach(function(name) {\n\t      OriginalWindow.prototype[name] = function() {\n\t        var w = wrap(this || window);\n\t        return w[name].apply(w, arguments);\n\t      };\n\t      delete window[name];\n\t    });\n\t    mixin(Window.prototype, {\n\t      getComputedStyle: function(el, pseudo) {\n\t        renderAllPending();\n\t        return originalGetComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\n\t      },\n\t      getSelection: function() {\n\t        renderAllPending();\n\t        return new Selection(originalGetSelection.call(unwrap(this)));\n\t      },\n\t      get document() {\n\t        return wrap(unwrap(this).document);\n\t      }\n\t    });\n\t    if (originalGetDefaultComputedStyle) {\n\t      Window.prototype.getDefaultComputedStyle = function(el, pseudo) {\n\t        renderAllPending();\n\t        return originalGetDefaultComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\n\t      };\n\t    }\n\t    registerWrapper(OriginalWindow, Window, window);\n\t    scope.wrappers.Window = Window;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var unwrap = scope.unwrap;\n\t    var OriginalDataTransfer = window.DataTransfer || window.Clipboard;\n\t    var OriginalDataTransferSetDragImage = OriginalDataTransfer.prototype.setDragImage;\n\t    if (OriginalDataTransferSetDragImage) {\n\t      OriginalDataTransfer.prototype.setDragImage = function(image, x, y) {\n\t        OriginalDataTransferSetDragImage.call(this, unwrap(image), x, y);\n\t      };\n\t    }\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var registerWrapper = scope.registerWrapper;\n\t    var setWrapper = scope.setWrapper;\n\t    var unwrap = scope.unwrap;\n\t    var OriginalFormData = window.FormData;\n\t    if (!OriginalFormData) return;\n\t    function FormData(formElement) {\n\t      var impl;\n\t      if (formElement instanceof OriginalFormData) {\n\t        impl = formElement;\n\t      } else {\n\t        impl = new OriginalFormData(formElement && unwrap(formElement));\n\t      }\n\t      setWrapper(impl, this);\n\t    }\n\t    registerWrapper(OriginalFormData, FormData, new OriginalFormData());\n\t    scope.wrappers.FormData = FormData;\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var unwrapIfNeeded = scope.unwrapIfNeeded;\n\t    var originalSend = XMLHttpRequest.prototype.send;\n\t    XMLHttpRequest.prototype.send = function(obj) {\n\t      return originalSend.call(this, unwrapIfNeeded(obj));\n\t    };\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    \"use strict\";\n\t    var isWrapperFor = scope.isWrapperFor;\n\t    var elements = {\n\t      a: \"HTMLAnchorElement\",\n\t      area: \"HTMLAreaElement\",\n\t      audio: \"HTMLAudioElement\",\n\t      base: \"HTMLBaseElement\",\n\t      body: \"HTMLBodyElement\",\n\t      br: \"HTMLBRElement\",\n\t      button: \"HTMLButtonElement\",\n\t      canvas: \"HTMLCanvasElement\",\n\t      caption: \"HTMLTableCaptionElement\",\n\t      col: \"HTMLTableColElement\",\n\t      content: \"HTMLContentElement\",\n\t      data: \"HTMLDataElement\",\n\t      datalist: \"HTMLDataListElement\",\n\t      del: \"HTMLModElement\",\n\t      dir: \"HTMLDirectoryElement\",\n\t      div: \"HTMLDivElement\",\n\t      dl: \"HTMLDListElement\",\n\t      embed: \"HTMLEmbedElement\",\n\t      fieldset: \"HTMLFieldSetElement\",\n\t      font: \"HTMLFontElement\",\n\t      form: \"HTMLFormElement\",\n\t      frame: \"HTMLFrameElement\",\n\t      frameset: \"HTMLFrameSetElement\",\n\t      h1: \"HTMLHeadingElement\",\n\t      head: \"HTMLHeadElement\",\n\t      hr: \"HTMLHRElement\",\n\t      html: \"HTMLHtmlElement\",\n\t      iframe: \"HTMLIFrameElement\",\n\t      img: \"HTMLImageElement\",\n\t      input: \"HTMLInputElement\",\n\t      keygen: \"HTMLKeygenElement\",\n\t      label: \"HTMLLabelElement\",\n\t      legend: \"HTMLLegendElement\",\n\t      li: \"HTMLLIElement\",\n\t      link: \"HTMLLinkElement\",\n\t      map: \"HTMLMapElement\",\n\t      marquee: \"HTMLMarqueeElement\",\n\t      menu: \"HTMLMenuElement\",\n\t      menuitem: \"HTMLMenuItemElement\",\n\t      meta: \"HTMLMetaElement\",\n\t      meter: \"HTMLMeterElement\",\n\t      object: \"HTMLObjectElement\",\n\t      ol: \"HTMLOListElement\",\n\t      optgroup: \"HTMLOptGroupElement\",\n\t      option: \"HTMLOptionElement\",\n\t      output: \"HTMLOutputElement\",\n\t      p: \"HTMLParagraphElement\",\n\t      param: \"HTMLParamElement\",\n\t      pre: \"HTMLPreElement\",\n\t      progress: \"HTMLProgressElement\",\n\t      q: \"HTMLQuoteElement\",\n\t      script: \"HTMLScriptElement\",\n\t      select: \"HTMLSelectElement\",\n\t      shadow: \"HTMLShadowElement\",\n\t      source: \"HTMLSourceElement\",\n\t      span: \"HTMLSpanElement\",\n\t      style: \"HTMLStyleElement\",\n\t      table: \"HTMLTableElement\",\n\t      tbody: \"HTMLTableSectionElement\",\n\t      template: \"HTMLTemplateElement\",\n\t      textarea: \"HTMLTextAreaElement\",\n\t      thead: \"HTMLTableSectionElement\",\n\t      time: \"HTMLTimeElement\",\n\t      title: \"HTMLTitleElement\",\n\t      tr: \"HTMLTableRowElement\",\n\t      track: \"HTMLTrackElement\",\n\t      ul: \"HTMLUListElement\",\n\t      video: \"HTMLVideoElement\"\n\t    };\n\t    function overrideConstructor(tagName) {\n\t      var nativeConstructorName = elements[tagName];\n\t      var nativeConstructor = window[nativeConstructorName];\n\t      if (!nativeConstructor) return;\n\t      var element = document.createElement(tagName);\n\t      var wrapperConstructor = element.constructor;\n\t      window[nativeConstructorName] = wrapperConstructor;\n\t    }\n\t    Object.keys(elements).forEach(overrideConstructor);\n\t    Object.getOwnPropertyNames(scope.wrappers).forEach(function(name) {\n\t      window[name] = scope.wrappers[name];\n\t    });\n\t  })(window.ShadowDOMPolyfill);\n\t  (function(scope) {\n\t    var ShadowCSS = {\n\t      strictStyling: false,\n\t      registry: {},\n\t      shimStyling: function(root, name, extendsName) {\n\t        var scopeStyles = this.prepareRoot(root, name, extendsName);\n\t        var typeExtension = this.isTypeExtension(extendsName);\n\t        var scopeSelector = this.makeScopeSelector(name, typeExtension);\n\t        var cssText = stylesToCssText(scopeStyles, true);\n\t        cssText = this.scopeCssText(cssText, scopeSelector);\n\t        if (root) {\n\t          root.shimmedStyle = cssText;\n\t        }\n\t        this.addCssToDocument(cssText, name);\n\t      },\n\t      shimStyle: function(style, selector) {\n\t        return this.shimCssText(style.textContent, selector);\n\t      },\n\t      shimCssText: function(cssText, selector) {\n\t        cssText = this.insertDirectives(cssText);\n\t        return this.scopeCssText(cssText, selector);\n\t      },\n\t      makeScopeSelector: function(name, typeExtension) {\n\t        if (name) {\n\t          return typeExtension ? \"[is=\" + name + \"]\" : name;\n\t        }\n\t        return \"\";\n\t      },\n\t      isTypeExtension: function(extendsName) {\n\t        return extendsName && extendsName.indexOf(\"-\") < 0;\n\t      },\n\t      prepareRoot: function(root, name, extendsName) {\n\t        var def = this.registerRoot(root, name, extendsName);\n\t        this.replaceTextInStyles(def.rootStyles, this.insertDirectives);\n\t        this.removeStyles(root, def.rootStyles);\n\t        if (this.strictStyling) {\n\t          this.applyScopeToContent(root, name);\n\t        }\n\t        return def.scopeStyles;\n\t      },\n\t      removeStyles: function(root, styles) {\n\t        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {\n\t          s.parentNode.removeChild(s);\n\t        }\n\t      },\n\t      registerRoot: function(root, name, extendsName) {\n\t        var def = this.registry[name] = {\n\t          root: root,\n\t          name: name,\n\t          extendsName: extendsName\n\t        };\n\t        var styles = this.findStyles(root);\n\t        def.rootStyles = styles;\n\t        def.scopeStyles = def.rootStyles;\n\t        var extendee = this.registry[def.extendsName];\n\t        if (extendee) {\n\t          def.scopeStyles = extendee.scopeStyles.concat(def.scopeStyles);\n\t        }\n\t        return def;\n\t      },\n\t      findStyles: function(root) {\n\t        if (!root) {\n\t          return [];\n\t        }\n\t        var styles = root.querySelectorAll(\"style\");\n\t        return Array.prototype.filter.call(styles, function(s) {\n\t          return !s.hasAttribute(NO_SHIM_ATTRIBUTE);\n\t        });\n\t      },\n\t      applyScopeToContent: function(root, name) {\n\t        if (root) {\n\t          Array.prototype.forEach.call(root.querySelectorAll(\"*\"), function(node) {\n\t            node.setAttribute(name, \"\");\n\t          });\n\t          Array.prototype.forEach.call(root.querySelectorAll(\"template\"), function(template) {\n\t            this.applyScopeToContent(template.content, name);\n\t          }, this);\n\t        }\n\t      },\n\t      insertDirectives: function(cssText) {\n\t        cssText = this.insertPolyfillDirectivesInCssText(cssText);\n\t        return this.insertPolyfillRulesInCssText(cssText);\n\t      },\n\t      insertPolyfillDirectivesInCssText: function(cssText) {\n\t        cssText = cssText.replace(cssCommentNextSelectorRe, function(match, p1) {\n\t          return p1.slice(0, -2) + \"{\";\n\t        });\n\t        return cssText.replace(cssContentNextSelectorRe, function(match, p1) {\n\t          return p1 + \" {\";\n\t        });\n\t      },\n\t      insertPolyfillRulesInCssText: function(cssText) {\n\t        cssText = cssText.replace(cssCommentRuleRe, function(match, p1) {\n\t          return p1.slice(0, -1);\n\t        });\n\t        return cssText.replace(cssContentRuleRe, function(match, p1, p2, p3) {\n\t          var rule = match.replace(p1, \"\").replace(p2, \"\");\n\t          return p3 + rule;\n\t        });\n\t      },\n\t      scopeCssText: function(cssText, scopeSelector) {\n\t        var unscoped = this.extractUnscopedRulesFromCssText(cssText);\n\t        cssText = this.insertPolyfillHostInCssText(cssText);\n\t        cssText = this.convertColonHost(cssText);\n\t        cssText = this.convertColonHostContext(cssText);\n\t        cssText = this.convertShadowDOMSelectors(cssText);\n\t        if (scopeSelector) {\n\t          var self = this, cssText;\n\t          withCssRules(cssText, function(rules) {\n\t            cssText = self.scopeRules(rules, scopeSelector);\n\t          });\n\t        }\n\t        cssText = cssText + \"\\n\" + unscoped;\n\t        return cssText.trim();\n\t      },\n\t      extractUnscopedRulesFromCssText: function(cssText) {\n\t        var r = \"\", m;\n\t        while (m = cssCommentUnscopedRuleRe.exec(cssText)) {\n\t          r += m[1].slice(0, -1) + \"\\n\\n\";\n\t        }\n\t        while (m = cssContentUnscopedRuleRe.exec(cssText)) {\n\t          r += m[0].replace(m[2], \"\").replace(m[1], m[3]) + \"\\n\\n\";\n\t        }\n\t        return r;\n\t      },\n\t      convertColonHost: function(cssText) {\n\t        return this.convertColonRule(cssText, cssColonHostRe, this.colonHostPartReplacer);\n\t      },\n\t      convertColonHostContext: function(cssText) {\n\t        return this.convertColonRule(cssText, cssColonHostContextRe, this.colonHostContextPartReplacer);\n\t      },\n\t      convertColonRule: function(cssText, regExp, partReplacer) {\n\t        return cssText.replace(regExp, function(m, p1, p2, p3) {\n\t          p1 = polyfillHostNoCombinator;\n\t          if (p2) {\n\t            var parts = p2.split(\",\"), r = [];\n\t            for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {\n\t              p = p.trim();\n\t              r.push(partReplacer(p1, p, p3));\n\t            }\n\t            return r.join(\",\");\n\t          } else {\n\t            return p1 + p3;\n\t          }\n\t        });\n\t      },\n\t      colonHostContextPartReplacer: function(host, part, suffix) {\n\t        if (part.match(polyfillHost)) {\n\t          return this.colonHostPartReplacer(host, part, suffix);\n\t        } else {\n\t          return host + part + suffix + \", \" + part + \" \" + host + suffix;\n\t        }\n\t      },\n\t      colonHostPartReplacer: function(host, part, suffix) {\n\t        return host + part.replace(polyfillHost, \"\") + suffix;\n\t      },\n\t      convertShadowDOMSelectors: function(cssText) {\n\t        for (var i = 0; i < shadowDOMSelectorsRe.length; i++) {\n\t          cssText = cssText.replace(shadowDOMSelectorsRe[i], \" \");\n\t        }\n\t        return cssText;\n\t      },\n\t      scopeRules: function(cssRules, scopeSelector) {\n\t        var cssText = \"\";\n\t        if (cssRules) {\n\t          Array.prototype.forEach.call(cssRules, function(rule) {\n\t            if (rule.selectorText && (rule.style && rule.style.cssText !== undefined)) {\n\t              cssText += this.scopeSelector(rule.selectorText, scopeSelector, this.strictStyling) + \" {\\n\t\";\n\t              cssText += this.propertiesFromRule(rule) + \"\\n}\\n\\n\";\n\t            } else if (rule.type === CSSRule.MEDIA_RULE) {\n\t              cssText += \"@media \" + rule.media.mediaText + \" {\\n\";\n\t              cssText += this.scopeRules(rule.cssRules, scopeSelector);\n\t              cssText += \"\\n}\\n\\n\";\n\t            } else {\n\t              try {\n\t                if (rule.cssText) {\n\t                  cssText += rule.cssText + \"\\n\\n\";\n\t                }\n\t              } catch (x) {\n\t                if (rule.type === CSSRule.KEYFRAMES_RULE && rule.cssRules) {\n\t                  cssText += this.ieSafeCssTextFromKeyFrameRule(rule);\n\t                }\n\t              }\n\t            }\n\t          }, this);\n\t        }\n\t        return cssText;\n\t      },\n\t      ieSafeCssTextFromKeyFrameRule: function(rule) {\n\t        var cssText = \"@keyframes \" + rule.name + \" {\";\n\t        Array.prototype.forEach.call(rule.cssRules, function(rule) {\n\t          cssText += \" \" + rule.keyText + \" {\" + rule.style.cssText + \"}\";\n\t        });\n\t        cssText += \" }\";\n\t        return cssText;\n\t      },\n\t      scopeSelector: function(selector, scopeSelector, strict) {\n\t        var r = [], parts = selector.split(\",\");\n\t        parts.forEach(function(p) {\n\t          p = p.trim();\n\t          if (this.selectorNeedsScoping(p, scopeSelector)) {\n\t            p = strict && !p.match(polyfillHostNoCombinator) ? this.applyStrictSelectorScope(p, scopeSelector) : this.applySelectorScope(p, scopeSelector);\n\t          }\n\t          r.push(p);\n\t        }, this);\n\t        return r.join(\", \");\n\t      },\n\t      selectorNeedsScoping: function(selector, scopeSelector) {\n\t        if (Array.isArray(scopeSelector)) {\n\t          return true;\n\t        }\n\t        var re = this.makeScopeMatcher(scopeSelector);\n\t        return !selector.match(re);\n\t      },\n\t      makeScopeMatcher: function(scopeSelector) {\n\t        scopeSelector = scopeSelector.replace(/\\[/g, \"\\\\[\").replace(/\\]/g, \"\\\\]\");\n\t        return new RegExp(\"^(\" + scopeSelector + \")\" + selectorReSuffix, \"m\");\n\t      },\n\t      applySelectorScope: function(selector, selectorScope) {\n\t        return Array.isArray(selectorScope) ? this.applySelectorScopeList(selector, selectorScope) : this.applySimpleSelectorScope(selector, selectorScope);\n\t      },\n\t      applySelectorScopeList: function(selector, scopeSelectorList) {\n\t        var r = [];\n\t        for (var i = 0, s; s = scopeSelectorList[i]; i++) {\n\t          r.push(this.applySimpleSelectorScope(selector, s));\n\t        }\n\t        return r.join(\", \");\n\t      },\n\t      applySimpleSelectorScope: function(selector, scopeSelector) {\n\t        if (selector.match(polyfillHostRe)) {\n\t          selector = selector.replace(polyfillHostNoCombinator, scopeSelector);\n\t          return selector.replace(polyfillHostRe, scopeSelector + \" \");\n\t        } else {\n\t          return scopeSelector + \" \" + selector;\n\t        }\n\t      },\n\t      applyStrictSelectorScope: function(selector, scopeSelector) {\n\t        scopeSelector = scopeSelector.replace(/\\[is=([^\\]]*)\\]/g, \"$1\");\n\t        var splits = [ \" \", \">\", \"+\", \"~\" ], scoped = selector, attrName = \"[\" + scopeSelector + \"]\";\n\t        splits.forEach(function(sep) {\n\t          var parts = scoped.split(sep);\n\t          scoped = parts.map(function(p) {\n\t            var t = p.trim().replace(polyfillHostRe, \"\");\n\t            if (t && splits.indexOf(t) < 0 && t.indexOf(attrName) < 0) {\n\t              p = t.replace(/([^:]*)(:*)(.*)/, \"$1\" + attrName + \"$2$3\");\n\t            }\n\t            return p;\n\t          }).join(sep);\n\t        });\n\t        return scoped;\n\t      },\n\t      insertPolyfillHostInCssText: function(selector) {\n\t        return selector.replace(colonHostContextRe, polyfillHostContext).replace(colonHostRe, polyfillHost);\n\t      },\n\t      propertiesFromRule: function(rule) {\n\t        var cssText = rule.style.cssText;\n\t        if (rule.style.content && !rule.style.content.match(/['\"]+|attr/)) {\n\t          cssText = cssText.replace(/content:[^;]*;/g, \"content: '\" + rule.style.content + \"';\");\n\t        }\n\t        var style = rule.style;\n\t        for (var i in style) {\n\t          if (style[i] === \"initial\") {\n\t            cssText += i + \": initial; \";\n\t          }\n\t        }\n\t        return cssText;\n\t      },\n\t      replaceTextInStyles: function(styles, action) {\n\t        if (styles && action) {\n\t          if (!(styles instanceof Array)) {\n\t            styles = [ styles ];\n\t          }\n\t          Array.prototype.forEach.call(styles, function(s) {\n\t            s.textContent = action.call(this, s.textContent);\n\t          }, this);\n\t        }\n\t      },\n\t      addCssToDocument: function(cssText, name) {\n\t        if (cssText.match(\"@import\")) {\n\t          addOwnSheet(cssText, name);\n\t        } else {\n\t          addCssToDocument(cssText);\n\t        }\n\t      }\n\t    };\n\t    var selectorRe = /([^{]*)({[\\s\\S]*?})/gim, cssCommentRe = /\\/\\*[^*]*\\*+([^\\/*][^*]*\\*+)*\\//gim, cssCommentNextSelectorRe = /\\/\\*\\s*@polyfill ([^*]*\\*+([^\\/*][^*]*\\*+)*\\/)([^{]*?){/gim, cssContentNextSelectorRe = /polyfill-next-selector[^}]*content\\:[\\s]*?['\"](.*?)['\"][;\\s]*}([^{]*?){/gim, cssCommentRuleRe = /\\/\\*\\s@polyfill-rule([^*]*\\*+([^\\/*][^*]*\\*+)*)\\//gim, cssContentRuleRe = /(polyfill-rule)[^}]*(content\\:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim, cssCommentUnscopedRuleRe = /\\/\\*\\s@polyfill-unscoped-rule([^*]*\\*+([^\\/*][^*]*\\*+)*)\\//gim, cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content\\:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim, cssPseudoRe = /::(x-[^\\s{,(]*)/gim, cssPartRe = /::part\\(([^)]*)\\)/gim, polyfillHost = \"-shadowcsshost\", polyfillHostContext = \"-shadowcsscontext\", parenSuffix = \")(?:\\\\((\" + \"(?:\\\\([^)(]*\\\\)|[^)(]*)+?\" + \")\\\\))?([^,{]*)\";\n\t    var cssColonHostRe = new RegExp(\"(\" + polyfillHost + parenSuffix, \"gim\"), cssColonHostContextRe = new RegExp(\"(\" + polyfillHostContext + parenSuffix, \"gim\"), selectorReSuffix = \"([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$\", colonHostRe = /\\:host/gim, colonHostContextRe = /\\:host-context/gim, polyfillHostNoCombinator = polyfillHost + \"-no-combinator\", polyfillHostRe = new RegExp(polyfillHost, \"gim\"), polyfillHostContextRe = new RegExp(polyfillHostContext, \"gim\"), shadowDOMSelectorsRe = [ />>>/g, /::shadow/g, /::content/g, /\\/deep\\//g, /\\/shadow\\//g, /\\/shadow-deep\\//g, /\\^\\^/g, /\\^/g ];\n\t    function stylesToCssText(styles, preserveComments) {\n\t      var cssText = \"\";\n\t      Array.prototype.forEach.call(styles, function(s) {\n\t        cssText += s.textContent + \"\\n\\n\";\n\t      });\n\t      if (!preserveComments) {\n\t        cssText = cssText.replace(cssCommentRe, \"\");\n\t      }\n\t      return cssText;\n\t    }\n\t    function cssTextToStyle(cssText) {\n\t      var style = document.createElement(\"style\");\n\t      style.textContent = cssText;\n\t      return style;\n\t    }\n\t    function cssToRules(cssText) {\n\t      var style = cssTextToStyle(cssText);\n\t      document.head.appendChild(style);\n\t      var rules = [];\n\t      if (style.sheet) {\n\t        try {\n\t          rules = style.sheet.cssRules;\n\t        } catch (e) {}\n\t      } else {\n\t        console.warn(\"sheet not found\", style);\n\t      }\n\t      style.parentNode.removeChild(style);\n\t      return rules;\n\t    }\n\t    var frame = document.createElement(\"iframe\");\n\t    frame.style.display = \"none\";\n\t    function initFrame() {\n\t      frame.initialized = true;\n\t      document.body.appendChild(frame);\n\t      var doc = frame.contentDocument;\n\t      var base = doc.createElement(\"base\");\n\t      base.href = document.baseURI;\n\t      doc.head.appendChild(base);\n\t    }\n\t    function inFrame(fn) {\n\t      if (!frame.initialized) {\n\t        initFrame();\n\t      }\n\t      document.body.appendChild(frame);\n\t      fn(frame.contentDocument);\n\t      document.body.removeChild(frame);\n\t    }\n\t    var isChrome = navigator.userAgent.match(\"Chrome\");\n\t    function withCssRules(cssText, callback) {\n\t      if (!callback) {\n\t        return;\n\t      }\n\t      var rules;\n\t      if (cssText.match(\"@import\") && isChrome) {\n\t        var style = cssTextToStyle(cssText);\n\t        inFrame(function(doc) {\n\t          doc.head.appendChild(style.impl);\n\t          rules = Array.prototype.slice.call(style.sheet.cssRules, 0);\n\t          callback(rules);\n\t        });\n\t      } else {\n\t        rules = cssToRules(cssText);\n\t        callback(rules);\n\t      }\n\t    }\n\t    function rulesToCss(cssRules) {\n\t      for (var i = 0, css = []; i < cssRules.length; i++) {\n\t        css.push(cssRules[i].cssText);\n\t      }\n\t      return css.join(\"\\n\\n\");\n\t    }\n\t    function addCssToDocument(cssText) {\n\t      if (cssText) {\n\t        getSheet().appendChild(document.createTextNode(cssText));\n\t      }\n\t    }\n\t    function addOwnSheet(cssText, name) {\n\t      var style = cssTextToStyle(cssText);\n\t      style.setAttribute(name, \"\");\n\t      style.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n\t      document.head.appendChild(style);\n\t    }\n\t    var SHIM_ATTRIBUTE = \"shim-shadowdom\";\n\t    var SHIMMED_ATTRIBUTE = \"shim-shadowdom-css\";\n\t    var NO_SHIM_ATTRIBUTE = \"no-shim\";\n\t    var sheet;\n\t    function getSheet() {\n\t      if (!sheet) {\n\t        sheet = document.createElement(\"style\");\n\t        sheet.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n\t        sheet[SHIMMED_ATTRIBUTE] = true;\n\t      }\n\t      return sheet;\n\t    }\n\t    if (window.ShadowDOMPolyfill) {\n\t      addCssToDocument(\"style { display: none !important; }\\n\");\n\t      var doc = ShadowDOMPolyfill.wrap(document);\n\t      var head = doc.querySelector(\"head\");\n\t      head.insertBefore(getSheet(), head.childNodes[0]);\n\t      document.addEventListener(\"DOMContentLoaded\", function() {\n\t        var urlResolver = scope.urlResolver;\n\t        if (window.HTMLImports && !HTMLImports.useNative) {\n\t          var SHIM_SHEET_SELECTOR = \"link[rel=stylesheet]\" + \"[\" + SHIM_ATTRIBUTE + \"]\";\n\t          var SHIM_STYLE_SELECTOR = \"style[\" + SHIM_ATTRIBUTE + \"]\";\n\t          HTMLImports.importer.documentPreloadSelectors += \",\" + SHIM_SHEET_SELECTOR;\n\t          HTMLImports.importer.importsPreloadSelectors += \",\" + SHIM_SHEET_SELECTOR;\n\t          HTMLImports.parser.documentSelectors = [ HTMLImports.parser.documentSelectors, SHIM_SHEET_SELECTOR, SHIM_STYLE_SELECTOR ].join(\",\");\n\t          var originalParseGeneric = HTMLImports.parser.parseGeneric;\n\t          HTMLImports.parser.parseGeneric = function(elt) {\n\t            if (elt[SHIMMED_ATTRIBUTE]) {\n\t              return;\n\t            }\n\t            var style = elt.__importElement || elt;\n\t            if (!style.hasAttribute(SHIM_ATTRIBUTE)) {\n\t              originalParseGeneric.call(this, elt);\n\t              return;\n\t            }\n\t            if (elt.__resource) {\n\t              style = elt.ownerDocument.createElement(\"style\");\n\t              style.textContent = elt.__resource;\n\t            }\n\t            HTMLImports.path.resolveUrlsInStyle(style, elt.href);\n\t            style.textContent = ShadowCSS.shimStyle(style);\n\t            style.removeAttribute(SHIM_ATTRIBUTE, \"\");\n\t            style.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n\t            style[SHIMMED_ATTRIBUTE] = true;\n\t            if (style.parentNode !== head) {\n\t              if (elt.parentNode === head) {\n\t                head.replaceChild(style, elt);\n\t              } else {\n\t                this.addElementToDocument(style);\n\t              }\n\t            }\n\t            style.__importParsed = true;\n\t            this.markParsingComplete(elt);\n\t            this.parseNext();\n\t          };\n\t          var hasResource = HTMLImports.parser.hasResource;\n\t          HTMLImports.parser.hasResource = function(node) {\n\t            if (node.localName === \"link\" && node.rel === \"stylesheet\" && node.hasAttribute(SHIM_ATTRIBUTE)) {\n\t              return node.__resource;\n\t            } else {\n\t              return hasResource.call(this, node);\n\t            }\n\t          };\n\t        }\n\t      });\n\t    }\n\t    scope.ShadowCSS = ShadowCSS;\n\t  })(window.WebComponents);\n\t}\n\t\n\t(function(scope) {\n\t  if (window.ShadowDOMPolyfill) {\n\t    window.wrap = ShadowDOMPolyfill.wrapIfNeeded;\n\t    window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;\n\t  } else {\n\t    window.wrap = window.unwrap = function(n) {\n\t      return n;\n\t    };\n\t  }\n\t})(window.WebComponents);\n\t\n\t(function(scope) {\n\t  \"use strict\";\n\t  var hasWorkingUrl = false;\n\t  if (!scope.forceJURL) {\n\t    try {\n\t      var u = new URL(\"b\", \"http://a\");\n\t      u.pathname = \"c%20d\";\n\t      hasWorkingUrl = u.href === \"http://a/c%20d\";\n\t    } catch (e) {}\n\t  }\n\t  if (hasWorkingUrl) return;\n\t  var relative = Object.create(null);\n\t  relative[\"ftp\"] = 21;\n\t  relative[\"file\"] = 0;\n\t  relative[\"gopher\"] = 70;\n\t  relative[\"http\"] = 80;\n\t  relative[\"https\"] = 443;\n\t  relative[\"ws\"] = 80;\n\t  relative[\"wss\"] = 443;\n\t  var relativePathDotMapping = Object.create(null);\n\t  relativePathDotMapping[\"%2e\"] = \".\";\n\t  relativePathDotMapping[\".%2e\"] = \"..\";\n\t  relativePathDotMapping[\"%2e.\"] = \"..\";\n\t  relativePathDotMapping[\"%2e%2e\"] = \"..\";\n\t  function isRelativeScheme(scheme) {\n\t    return relative[scheme] !== undefined;\n\t  }\n\t  function invalid() {\n\t    clear.call(this);\n\t    this._isInvalid = true;\n\t  }\n\t  function IDNAToASCII(h) {\n\t    if (\"\" == h) {\n\t      invalid.call(this);\n\t    }\n\t    return h.toLowerCase();\n\t  }\n\t  function percentEscape(c) {\n\t    var unicode = c.charCodeAt(0);\n\t    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) == -1) {\n\t      return c;\n\t    }\n\t    return encodeURIComponent(c);\n\t  }\n\t  function percentEscapeQuery(c) {\n\t    var unicode = c.charCodeAt(0);\n\t    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 96 ].indexOf(unicode) == -1) {\n\t      return c;\n\t    }\n\t    return encodeURIComponent(c);\n\t  }\n\t  var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\\+\\-\\.]/;\n\t  function parse(input, stateOverride, base) {\n\t    function err(message) {\n\t      errors.push(message);\n\t    }\n\t    var state = stateOverride || \"scheme start\", cursor = 0, buffer = \"\", seenAt = false, seenBracket = false, errors = [];\n\t    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {\n\t      var c = input[cursor];\n\t      switch (state) {\n\t       case \"scheme start\":\n\t        if (c && ALPHA.test(c)) {\n\t          buffer += c.toLowerCase();\n\t          state = \"scheme\";\n\t        } else if (!stateOverride) {\n\t          buffer = \"\";\n\t          state = \"no scheme\";\n\t          continue;\n\t        } else {\n\t          err(\"Invalid scheme.\");\n\t          break loop;\n\t        }\n\t        break;\n\t\n\t       case \"scheme\":\n\t        if (c && ALPHANUMERIC.test(c)) {\n\t          buffer += c.toLowerCase();\n\t        } else if (\":\" == c) {\n\t          this._scheme = buffer;\n\t          buffer = \"\";\n\t          if (stateOverride) {\n\t            break loop;\n\t          }\n\t          if (isRelativeScheme(this._scheme)) {\n\t            this._isRelative = true;\n\t          }\n\t          if (\"file\" == this._scheme) {\n\t            state = \"relative\";\n\t          } else if (this._isRelative && base && base._scheme == this._scheme) {\n\t            state = \"relative or authority\";\n\t          } else if (this._isRelative) {\n\t            state = \"authority first slash\";\n\t          } else {\n\t            state = \"scheme data\";\n\t          }\n\t        } else if (!stateOverride) {\n\t          buffer = \"\";\n\t          cursor = 0;\n\t          state = \"no scheme\";\n\t          continue;\n\t        } else if (EOF == c) {\n\t          break loop;\n\t        } else {\n\t          err(\"Code point not allowed in scheme: \" + c);\n\t          break loop;\n\t        }\n\t        break;\n\t\n\t       case \"scheme data\":\n\t        if (\"?\" == c) {\n\t          this._query = \"?\";\n\t          state = \"query\";\n\t        } else if (\"#\" == c) {\n\t          this._fragment = \"#\";\n\t          state = \"fragment\";\n\t        } else {\n\t          if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n\t            this._schemeData += percentEscape(c);\n\t          }\n\t        }\n\t        break;\n\t\n\t       case \"no scheme\":\n\t        if (!base || !isRelativeScheme(base._scheme)) {\n\t          err(\"Missing scheme.\");\n\t          invalid.call(this);\n\t        } else {\n\t          state = \"relative\";\n\t          continue;\n\t        }\n\t        break;\n\t\n\t       case \"relative or authority\":\n\t        if (\"/\" == c && \"/\" == input[cursor + 1]) {\n\t          state = \"authority ignore slashes\";\n\t        } else {\n\t          err(\"Expected /, got: \" + c);\n\t          state = \"relative\";\n\t          continue;\n\t        }\n\t        break;\n\t\n\t       case \"relative\":\n\t        this._isRelative = true;\n\t        if (\"file\" != this._scheme) this._scheme = base._scheme;\n\t        if (EOF == c) {\n\t          this._host = base._host;\n\t          this._port = base._port;\n\t          this._path = base._path.slice();\n\t          this._query = base._query;\n\t          this._username = base._username;\n\t          this._password = base._password;\n\t          break loop;\n\t        } else if (\"/\" == c || \"\\\\\" == c) {\n\t          if (\"\\\\\" == c) err(\"\\\\ is an invalid code point.\");\n\t          state = \"relative slash\";\n\t        } else if (\"?\" == c) {\n\t          this._host = base._host;\n\t          this._port = base._port;\n\t          this._path = base._path.slice();\n\t          this._query = \"?\";\n\t          this._username = base._username;\n\t          this._password = base._password;\n\t          state = \"query\";\n\t        } else if (\"#\" == c) {\n\t          this._host = base._host;\n\t          this._port = base._port;\n\t          this._path = base._path.slice();\n\t          this._query = base._query;\n\t          this._fragment = \"#\";\n\t          this._username = base._username;\n\t          this._password = base._password;\n\t          state = \"fragment\";\n\t        } else {\n\t          var nextC = input[cursor + 1];\n\t          var nextNextC = input[cursor + 2];\n\t          if (\"file\" != this._scheme || !ALPHA.test(c) || nextC != \":\" && nextC != \"|\" || EOF != nextNextC && \"/\" != nextNextC && \"\\\\\" != nextNextC && \"?\" != nextNextC && \"#\" != nextNextC) {\n\t            this._host = base._host;\n\t            this._port = base._port;\n\t            this._username = base._username;\n\t            this._password = base._password;\n\t            this._path = base._path.slice();\n\t            this._path.pop();\n\t          }\n\t          state = \"relative path\";\n\t          continue;\n\t        }\n\t        break;\n\t\n\t       case \"relative slash\":\n\t        if (\"/\" == c || \"\\\\\" == c) {\n\t          if (\"\\\\\" == c) {\n\t            err(\"\\\\ is an invalid code point.\");\n\t          }\n\t          if (\"file\" == this._scheme) {\n\t            state = \"file host\";\n\t          } else {\n\t            state = \"authority ignore slashes\";\n\t          }\n\t        } else {\n\t          if (\"file\" != this._scheme) {\n\t            this._host = base._host;\n\t            this._port = base._port;\n\t            this._username = base._username;\n\t            this._password = base._password;\n\t          }\n\t          state = \"relative path\";\n\t          continue;\n\t        }\n\t        break;\n\t\n\t       case \"authority first slash\":\n\t        if (\"/\" == c) {\n\t          state = \"authority second slash\";\n\t        } else {\n\t          err(\"Expected '/', got: \" + c);\n\t          state = \"authority ignore slashes\";\n\t          continue;\n\t        }\n\t        break;\n\t\n\t       case \"authority second slash\":\n\t        state = \"authority ignore slashes\";\n\t        if (\"/\" != c) {\n\t          err(\"Expected '/', got: \" + c);\n\t          continue;\n\t        }\n\t        break;\n\t\n\t       case \"authority ignore slashes\":\n\t        if (\"/\" != c && \"\\\\\" != c) {\n\t          state = \"authority\";\n\t          continue;\n\t        } else {\n\t          err(\"Expected authority, got: \" + c);\n\t        }\n\t        break;\n\t\n\t       case \"authority\":\n\t        if (\"@\" == c) {\n\t          if (seenAt) {\n\t            err(\"@ already seen.\");\n\t            buffer += \"%40\";\n\t          }\n\t          seenAt = true;\n\t          for (var i = 0; i < buffer.length; i++) {\n\t            var cp = buffer[i];\n\t            if (\"\t\" == cp || \"\\n\" == cp || \"\\r\" == cp) {\n\t              err(\"Invalid whitespace in authority.\");\n\t              continue;\n\t            }\n\t            if (\":\" == cp && null === this._password) {\n\t              this._password = \"\";\n\t              continue;\n\t            }\n\t            var tempC = percentEscape(cp);\n\t            null !== this._password ? this._password += tempC : this._username += tempC;\n\t          }\n\t          buffer = \"\";\n\t        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n\t          cursor -= buffer.length;\n\t          buffer = \"\";\n\t          state = \"host\";\n\t          continue;\n\t        } else {\n\t          buffer += c;\n\t        }\n\t        break;\n\t\n\t       case \"file host\":\n\t        if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n\t          if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == \":\" || buffer[1] == \"|\")) {\n\t            state = \"relative path\";\n\t          } else if (buffer.length == 0) {\n\t            state = \"relative path start\";\n\t          } else {\n\t            this._host = IDNAToASCII.call(this, buffer);\n\t            buffer = \"\";\n\t            state = \"relative path start\";\n\t          }\n\t          continue;\n\t        } else if (\"\t\" == c || \"\\n\" == c || \"\\r\" == c) {\n\t          err(\"Invalid whitespace in file host.\");\n\t        } else {\n\t          buffer += c;\n\t        }\n\t        break;\n\t\n\t       case \"host\":\n\t       case \"hostname\":\n\t        if (\":\" == c && !seenBracket) {\n\t          this._host = IDNAToASCII.call(this, buffer);\n\t          buffer = \"\";\n\t          state = \"port\";\n\t          if (\"hostname\" == stateOverride) {\n\t            break loop;\n\t          }\n\t        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n\t          this._host = IDNAToASCII.call(this, buffer);\n\t          buffer = \"\";\n\t          state = \"relative path start\";\n\t          if (stateOverride) {\n\t            break loop;\n\t          }\n\t          continue;\n\t        } else if (\"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n\t          if (\"[\" == c) {\n\t            seenBracket = true;\n\t          } else if (\"]\" == c) {\n\t            seenBracket = false;\n\t          }\n\t          buffer += c;\n\t        } else {\n\t          err(\"Invalid code point in host/hostname: \" + c);\n\t        }\n\t        break;\n\t\n\t       case \"port\":\n\t        if (/[0-9]/.test(c)) {\n\t          buffer += c;\n\t        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c || stateOverride) {\n\t          if (\"\" != buffer) {\n\t            var temp = parseInt(buffer, 10);\n\t            if (temp != relative[this._scheme]) {\n\t              this._port = temp + \"\";\n\t            }\n\t            buffer = \"\";\n\t          }\n\t          if (stateOverride) {\n\t            break loop;\n\t          }\n\t          state = \"relative path start\";\n\t          continue;\n\t        } else if (\"\t\" == c || \"\\n\" == c || \"\\r\" == c) {\n\t          err(\"Invalid code point in port: \" + c);\n\t        } else {\n\t          invalid.call(this);\n\t        }\n\t        break;\n\t\n\t       case \"relative path start\":\n\t        if (\"\\\\\" == c) err(\"'\\\\' not allowed in path.\");\n\t        state = \"relative path\";\n\t        if (\"/\" != c && \"\\\\\" != c) {\n\t          continue;\n\t        }\n\t        break;\n\t\n\t       case \"relative path\":\n\t        if (EOF == c || \"/\" == c || \"\\\\\" == c || !stateOverride && (\"?\" == c || \"#\" == c)) {\n\t          if (\"\\\\\" == c) {\n\t            err(\"\\\\ not allowed in relative path.\");\n\t          }\n\t          var tmp;\n\t          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {\n\t            buffer = tmp;\n\t          }\n\t          if (\"..\" == buffer) {\n\t            this._path.pop();\n\t            if (\"/\" != c && \"\\\\\" != c) {\n\t              this._path.push(\"\");\n\t            }\n\t          } else if (\".\" == buffer && \"/\" != c && \"\\\\\" != c) {\n\t            this._path.push(\"\");\n\t          } else if (\".\" != buffer) {\n\t            if (\"file\" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == \"|\") {\n\t              buffer = buffer[0] + \":\";\n\t            }\n\t            this._path.push(buffer);\n\t          }\n\t          buffer = \"\";\n\t          if (\"?\" == c) {\n\t            this._query = \"?\";\n\t            state = \"query\";\n\t          } else if (\"#\" == c) {\n\t            this._fragment = \"#\";\n\t            state = \"fragment\";\n\t          }\n\t        } else if (\"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n\t          buffer += percentEscape(c);\n\t        }\n\t        break;\n\t\n\t       case \"query\":\n\t        if (!stateOverride && \"#\" == c) {\n\t          this._fragment = \"#\";\n\t          state = \"fragment\";\n\t        } else if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n\t          this._query += percentEscapeQuery(c);\n\t        }\n\t        break;\n\t\n\t       case \"fragment\":\n\t        if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n\t          this._fragment += c;\n\t        }\n\t        break;\n\t      }\n\t      cursor++;\n\t    }\n\t  }\n\t  function clear() {\n\t    this._scheme = \"\";\n\t    this._schemeData = \"\";\n\t    this._username = \"\";\n\t    this._password = null;\n\t    this._host = \"\";\n\t    this._port = \"\";\n\t    this._path = [];\n\t    this._query = \"\";\n\t    this._fragment = \"\";\n\t    this._isInvalid = false;\n\t    this._isRelative = false;\n\t  }\n\t  function jURL(url, base) {\n\t    if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));\n\t    this._url = url;\n\t    clear.call(this);\n\t    var input = url.replace(/^[ \\t\\r\\n\\f]+|[ \\t\\r\\n\\f]+$/g, \"\");\n\t    parse.call(this, input, null, base);\n\t  }\n\t  jURL.prototype = {\n\t    toString: function() {\n\t      return this.href;\n\t    },\n\t    get href() {\n\t      if (this._isInvalid) return this._url;\n\t      var authority = \"\";\n\t      if (\"\" != this._username || null != this._password) {\n\t        authority = this._username + (null != this._password ? \":\" + this._password : \"\") + \"@\";\n\t      }\n\t      return this.protocol + (this._isRelative ? \"//\" + authority + this.host : \"\") + this.pathname + this._query + this._fragment;\n\t    },\n\t    set href(href) {\n\t      clear.call(this);\n\t      parse.call(this, href);\n\t    },\n\t    get protocol() {\n\t      return this._scheme + \":\";\n\t    },\n\t    set protocol(protocol) {\n\t      if (this._isInvalid) return;\n\t      parse.call(this, protocol + \":\", \"scheme start\");\n\t    },\n\t    get host() {\n\t      return this._isInvalid ? \"\" : this._port ? this._host + \":\" + this._port : this._host;\n\t    },\n\t    set host(host) {\n\t      if (this._isInvalid || !this._isRelative) return;\n\t      parse.call(this, host, \"host\");\n\t    },\n\t    get hostname() {\n\t      return this._host;\n\t    },\n\t    set hostname(hostname) {\n\t      if (this._isInvalid || !this._isRelative) return;\n\t      parse.call(this, hostname, \"hostname\");\n\t    },\n\t    get port() {\n\t      return this._port;\n\t    },\n\t    set port(port) {\n\t      if (this._isInvalid || !this._isRelative) return;\n\t      parse.call(this, port, \"port\");\n\t    },\n\t    get pathname() {\n\t      return this._isInvalid ? \"\" : this._isRelative ? \"/\" + this._path.join(\"/\") : this._schemeData;\n\t    },\n\t    set pathname(pathname) {\n\t      if (this._isInvalid || !this._isRelative) return;\n\t      this._path = [];\n\t      parse.call(this, pathname, \"relative path start\");\n\t    },\n\t    get search() {\n\t      return this._isInvalid || !this._query || \"?\" == this._query ? \"\" : this._query;\n\t    },\n\t    set search(search) {\n\t      if (this._isInvalid || !this._isRelative) return;\n\t      this._query = \"?\";\n\t      if (\"?\" == search[0]) search = search.slice(1);\n\t      parse.call(this, search, \"query\");\n\t    },\n\t    get hash() {\n\t      return this._isInvalid || !this._fragment || \"#\" == this._fragment ? \"\" : this._fragment;\n\t    },\n\t    set hash(hash) {\n\t      if (this._isInvalid) return;\n\t      this._fragment = \"#\";\n\t      if (\"#\" == hash[0]) hash = hash.slice(1);\n\t      parse.call(this, hash, \"fragment\");\n\t    },\n\t    get origin() {\n\t      var host;\n\t      if (this._isInvalid || !this._scheme) {\n\t        return \"\";\n\t      }\n\t      switch (this._scheme) {\n\t       case \"data\":\n\t       case \"file\":\n\t       case \"javascript\":\n\t       case \"mailto\":\n\t        return \"null\";\n\t      }\n\t      host = this.host;\n\t      if (!host) {\n\t        return \"\";\n\t      }\n\t      return this._scheme + \"://\" + host;\n\t    }\n\t  };\n\t  var OriginalURL = scope.URL;\n\t  if (OriginalURL) {\n\t    jURL.createObjectURL = function(blob) {\n\t      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);\n\t    };\n\t    jURL.revokeObjectURL = function(url) {\n\t      OriginalURL.revokeObjectURL(url);\n\t    };\n\t  }\n\t  scope.URL = jURL;\n\t})(self);\n\t\n\t(function(global) {\n\t  if (global.JsMutationObserver) {\n\t    return;\n\t  }\n\t  var registrationsTable = new WeakMap();\n\t  var setImmediate;\n\t  if (/Trident|Edge/.test(navigator.userAgent)) {\n\t    setImmediate = setTimeout;\n\t  } else if (window.setImmediate) {\n\t    setImmediate = window.setImmediate;\n\t  } else {\n\t    var setImmediateQueue = [];\n\t    var sentinel = String(Math.random());\n\t    window.addEventListener(\"message\", function(e) {\n\t      if (e.data === sentinel) {\n\t        var queue = setImmediateQueue;\n\t        setImmediateQueue = [];\n\t        queue.forEach(function(func) {\n\t          func();\n\t        });\n\t      }\n\t    });\n\t    setImmediate = function(func) {\n\t      setImmediateQueue.push(func);\n\t      window.postMessage(sentinel, \"*\");\n\t    };\n\t  }\n\t  var isScheduled = false;\n\t  var scheduledObservers = [];\n\t  function scheduleCallback(observer) {\n\t    scheduledObservers.push(observer);\n\t    if (!isScheduled) {\n\t      isScheduled = true;\n\t      setImmediate(dispatchCallbacks);\n\t    }\n\t  }\n\t  function wrapIfNeeded(node) {\n\t    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;\n\t  }\n\t  function dispatchCallbacks() {\n\t    isScheduled = false;\n\t    var observers = scheduledObservers;\n\t    scheduledObservers = [];\n\t    observers.sort(function(o1, o2) {\n\t      return o1.uid_ - o2.uid_;\n\t    });\n\t    var anyNonEmpty = false;\n\t    observers.forEach(function(observer) {\n\t      var queue = observer.takeRecords();\n\t      removeTransientObserversFor(observer);\n\t      if (queue.length) {\n\t        observer.callback_(queue, observer);\n\t        anyNonEmpty = true;\n\t      }\n\t    });\n\t    if (anyNonEmpty) dispatchCallbacks();\n\t  }\n\t  function removeTransientObserversFor(observer) {\n\t    observer.nodes_.forEach(function(node) {\n\t      var registrations = registrationsTable.get(node);\n\t      if (!registrations) return;\n\t      registrations.forEach(function(registration) {\n\t        if (registration.observer === observer) registration.removeTransientObservers();\n\t      });\n\t    });\n\t  }\n\t  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\n\t    for (var node = target; node; node = node.parentNode) {\n\t      var registrations = registrationsTable.get(node);\n\t      if (registrations) {\n\t        for (var j = 0; j < registrations.length; j++) {\n\t          var registration = registrations[j];\n\t          var options = registration.options;\n\t          if (node !== target && !options.subtree) continue;\n\t          var record = callback(options);\n\t          if (record) registration.enqueue(record);\n\t        }\n\t      }\n\t    }\n\t  }\n\t  var uidCounter = 0;\n\t  function JsMutationObserver(callback) {\n\t    this.callback_ = callback;\n\t    this.nodes_ = [];\n\t    this.records_ = [];\n\t    this.uid_ = ++uidCounter;\n\t  }\n\t  JsMutationObserver.prototype = {\n\t    observe: function(target, options) {\n\t      target = wrapIfNeeded(target);\n\t      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {\n\t        throw new SyntaxError();\n\t      }\n\t      var registrations = registrationsTable.get(target);\n\t      if (!registrations) registrationsTable.set(target, registrations = []);\n\t      var registration;\n\t      for (var i = 0; i < registrations.length; i++) {\n\t        if (registrations[i].observer === this) {\n\t          registration = registrations[i];\n\t          registration.removeListeners();\n\t          registration.options = options;\n\t          break;\n\t        }\n\t      }\n\t      if (!registration) {\n\t        registration = new Registration(this, target, options);\n\t        registrations.push(registration);\n\t        this.nodes_.push(target);\n\t      }\n\t      registration.addListeners();\n\t    },\n\t    disconnect: function() {\n\t      this.nodes_.forEach(function(node) {\n\t        var registrations = registrationsTable.get(node);\n\t        for (var i = 0; i < registrations.length; i++) {\n\t          var registration = registrations[i];\n\t          if (registration.observer === this) {\n\t            registration.removeListeners();\n\t            registrations.splice(i, 1);\n\t            break;\n\t          }\n\t        }\n\t      }, this);\n\t      this.records_ = [];\n\t    },\n\t    takeRecords: function() {\n\t      var copyOfRecords = this.records_;\n\t      this.records_ = [];\n\t      return copyOfRecords;\n\t    }\n\t  };\n\t  function MutationRecord(type, target) {\n\t    this.type = type;\n\t    this.target = target;\n\t    this.addedNodes = [];\n\t    this.removedNodes = [];\n\t    this.previousSibling = null;\n\t    this.nextSibling = null;\n\t    this.attributeName = null;\n\t    this.attributeNamespace = null;\n\t    this.oldValue = null;\n\t  }\n\t  function copyMutationRecord(original) {\n\t    var record = new MutationRecord(original.type, original.target);\n\t    record.addedNodes = original.addedNodes.slice();\n\t    record.removedNodes = original.removedNodes.slice();\n\t    record.previousSibling = original.previousSibling;\n\t    record.nextSibling = original.nextSibling;\n\t    record.attributeName = original.attributeName;\n\t    record.attributeNamespace = original.attributeNamespace;\n\t    record.oldValue = original.oldValue;\n\t    return record;\n\t  }\n\t  var currentRecord, recordWithOldValue;\n\t  function getRecord(type, target) {\n\t    return currentRecord = new MutationRecord(type, target);\n\t  }\n\t  function getRecordWithOldValue(oldValue) {\n\t    if (recordWithOldValue) return recordWithOldValue;\n\t    recordWithOldValue = copyMutationRecord(currentRecord);\n\t    recordWithOldValue.oldValue = oldValue;\n\t    return recordWithOldValue;\n\t  }\n\t  function clearRecords() {\n\t    currentRecord = recordWithOldValue = undefined;\n\t  }\n\t  function recordRepresentsCurrentMutation(record) {\n\t    return record === recordWithOldValue || record === currentRecord;\n\t  }\n\t  function selectRecord(lastRecord, newRecord) {\n\t    if (lastRecord === newRecord) return lastRecord;\n\t    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n\t    return null;\n\t  }\n\t  function Registration(observer, target, options) {\n\t    this.observer = observer;\n\t    this.target = target;\n\t    this.options = options;\n\t    this.transientObservedNodes = [];\n\t  }\n\t  Registration.prototype = {\n\t    enqueue: function(record) {\n\t      var records = this.observer.records_;\n\t      var length = records.length;\n\t      if (records.length > 0) {\n\t        var lastRecord = records[length - 1];\n\t        var recordToReplaceLast = selectRecord(lastRecord, record);\n\t        if (recordToReplaceLast) {\n\t          records[length - 1] = recordToReplaceLast;\n\t          return;\n\t        }\n\t      } else {\n\t        scheduleCallback(this.observer);\n\t      }\n\t      records[length] = record;\n\t    },\n\t    addListeners: function() {\n\t      this.addListeners_(this.target);\n\t    },\n\t    addListeners_: function(node) {\n\t      var options = this.options;\n\t      if (options.attributes) node.addEventListener(\"DOMAttrModified\", this, true);\n\t      if (options.characterData) node.addEventListener(\"DOMCharacterDataModified\", this, true);\n\t      if (options.childList) node.addEventListener(\"DOMNodeInserted\", this, true);\n\t      if (options.childList || options.subtree) node.addEventListener(\"DOMNodeRemoved\", this, true);\n\t    },\n\t    removeListeners: function() {\n\t      this.removeListeners_(this.target);\n\t    },\n\t    removeListeners_: function(node) {\n\t      var options = this.options;\n\t      if (options.attributes) node.removeEventListener(\"DOMAttrModified\", this, true);\n\t      if (options.characterData) node.removeEventListener(\"DOMCharacterDataModified\", this, true);\n\t      if (options.childList) node.removeEventListener(\"DOMNodeInserted\", this, true);\n\t      if (options.childList || options.subtree) node.removeEventListener(\"DOMNodeRemoved\", this, true);\n\t    },\n\t    addTransientObserver: function(node) {\n\t      if (node === this.target) return;\n\t      this.addListeners_(node);\n\t      this.transientObservedNodes.push(node);\n\t      var registrations = registrationsTable.get(node);\n\t      if (!registrations) registrationsTable.set(node, registrations = []);\n\t      registrations.push(this);\n\t    },\n\t    removeTransientObservers: function() {\n\t      var transientObservedNodes = this.transientObservedNodes;\n\t      this.transientObservedNodes = [];\n\t      transientObservedNodes.forEach(function(node) {\n\t        this.removeListeners_(node);\n\t        var registrations = registrationsTable.get(node);\n\t        for (var i = 0; i < registrations.length; i++) {\n\t          if (registrations[i] === this) {\n\t            registrations.splice(i, 1);\n\t            break;\n\t          }\n\t        }\n\t      }, this);\n\t    },\n\t    handleEvent: function(e) {\n\t      e.stopImmediatePropagation();\n\t      switch (e.type) {\n\t       case \"DOMAttrModified\":\n\t        var name = e.attrName;\n\t        var namespace = e.relatedNode.namespaceURI;\n\t        var target = e.target;\n\t        var record = new getRecord(\"attributes\", target);\n\t        record.attributeName = name;\n\t        record.attributeNamespace = namespace;\n\t        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n\t        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n\t          if (!options.attributes) return;\n\t          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {\n\t            return;\n\t          }\n\t          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\n\t          return record;\n\t        });\n\t        break;\n\t\n\t       case \"DOMCharacterDataModified\":\n\t        var target = e.target;\n\t        var record = getRecord(\"characterData\", target);\n\t        var oldValue = e.prevValue;\n\t        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n\t          if (!options.characterData) return;\n\t          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);\n\t          return record;\n\t        });\n\t        break;\n\t\n\t       case \"DOMNodeRemoved\":\n\t        this.addTransientObserver(e.target);\n\t\n\t       case \"DOMNodeInserted\":\n\t        var changedNode = e.target;\n\t        var addedNodes, removedNodes;\n\t        if (e.type === \"DOMNodeInserted\") {\n\t          addedNodes = [ changedNode ];\n\t          removedNodes = [];\n\t        } else {\n\t          addedNodes = [];\n\t          removedNodes = [ changedNode ];\n\t        }\n\t        var previousSibling = changedNode.previousSibling;\n\t        var nextSibling = changedNode.nextSibling;\n\t        var record = getRecord(\"childList\", e.target.parentNode);\n\t        record.addedNodes = addedNodes;\n\t        record.removedNodes = removedNodes;\n\t        record.previousSibling = previousSibling;\n\t        record.nextSibling = nextSibling;\n\t        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {\n\t          if (!options.childList) return;\n\t          return record;\n\t        });\n\t      }\n\t      clearRecords();\n\t    }\n\t  };\n\t  global.JsMutationObserver = JsMutationObserver;\n\t  if (!global.MutationObserver) {\n\t    global.MutationObserver = JsMutationObserver;\n\t    JsMutationObserver._isPolyfilled = true;\n\t  }\n\t})(self);\n\t\n\t(function(scope) {\n\t  \"use strict\";\n\t  if (!window.performance) {\n\t    var start = Date.now();\n\t    window.performance = {\n\t      now: function() {\n\t        return Date.now() - start;\n\t      }\n\t    };\n\t  }\n\t  if (!window.requestAnimationFrame) {\n\t    window.requestAnimationFrame = function() {\n\t      var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n\t      return nativeRaf ? function(callback) {\n\t        return nativeRaf(function() {\n\t          callback(performance.now());\n\t        });\n\t      } : function(callback) {\n\t        return window.setTimeout(callback, 1e3 / 60);\n\t      };\n\t    }();\n\t  }\n\t  if (!window.cancelAnimationFrame) {\n\t    window.cancelAnimationFrame = function() {\n\t      return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {\n\t        clearTimeout(id);\n\t      };\n\t    }();\n\t  }\n\t  var workingDefaultPrevented = function() {\n\t    var e = document.createEvent(\"Event\");\n\t    e.initEvent(\"foo\", true, true);\n\t    e.preventDefault();\n\t    return e.defaultPrevented;\n\t  }();\n\t  if (!workingDefaultPrevented) {\n\t    var origPreventDefault = Event.prototype.preventDefault;\n\t    Event.prototype.preventDefault = function() {\n\t      if (!this.cancelable) {\n\t        return;\n\t      }\n\t      origPreventDefault.call(this);\n\t      Object.defineProperty(this, \"defaultPrevented\", {\n\t        get: function() {\n\t          return true;\n\t        },\n\t        configurable: true\n\t      });\n\t    };\n\t  }\n\t  var isIE = /Trident/.test(navigator.userAgent);\n\t  if (!window.CustomEvent || isIE && typeof window.CustomEvent !== \"function\") {\n\t    window.CustomEvent = function(inType, params) {\n\t      params = params || {};\n\t      var e = document.createEvent(\"CustomEvent\");\n\t      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n\t      return e;\n\t    };\n\t    window.CustomEvent.prototype = window.Event.prototype;\n\t  }\n\t  if (!window.Event || isIE && typeof window.Event !== \"function\") {\n\t    var origEvent = window.Event;\n\t    window.Event = function(inType, params) {\n\t      params = params || {};\n\t      var e = document.createEvent(\"Event\");\n\t      e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n\t      return e;\n\t    };\n\t    window.Event.prototype = origEvent.prototype;\n\t  }\n\t})(window.WebComponents);\n\t\n\twindow.HTMLImports = window.HTMLImports || {\n\t  flags: {}\n\t};\n\t\n\t(function(scope) {\n\t  var IMPORT_LINK_TYPE = \"import\";\n\t  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement(\"link\"));\n\t  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\n\t  var wrap = function(node) {\n\t    return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;\n\t  };\n\t  var rootDocument = wrap(document);\n\t  var currentScriptDescriptor = {\n\t    get: function() {\n\t      var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== \"complete\" ? document.scripts[document.scripts.length - 1] : null);\n\t      return wrap(script);\n\t    },\n\t    configurable: true\n\t  };\n\t  Object.defineProperty(document, \"_currentScript\", currentScriptDescriptor);\n\t  Object.defineProperty(rootDocument, \"_currentScript\", currentScriptDescriptor);\n\t  var isIE = /Trident/.test(navigator.userAgent);\n\t  function whenReady(callback, doc) {\n\t    doc = doc || rootDocument;\n\t    whenDocumentReady(function() {\n\t      watchImportsLoad(callback, doc);\n\t    }, doc);\n\t  }\n\t  var requiredReadyState = isIE ? \"complete\" : \"interactive\";\n\t  var READY_EVENT = \"readystatechange\";\n\t  function isDocumentReady(doc) {\n\t    return doc.readyState === \"complete\" || doc.readyState === requiredReadyState;\n\t  }\n\t  function whenDocumentReady(callback, doc) {\n\t    if (!isDocumentReady(doc)) {\n\t      var checkReady = function() {\n\t        if (doc.readyState === \"complete\" || doc.readyState === requiredReadyState) {\n\t          doc.removeEventListener(READY_EVENT, checkReady);\n\t          whenDocumentReady(callback, doc);\n\t        }\n\t      };\n\t      doc.addEventListener(READY_EVENT, checkReady);\n\t    } else if (callback) {\n\t      callback();\n\t    }\n\t  }\n\t  function markTargetLoaded(event) {\n\t    event.target.__loaded = true;\n\t  }\n\t  function watchImportsLoad(callback, doc) {\n\t    var imports = doc.querySelectorAll(\"link[rel=import]\");\n\t    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];\n\t    function checkDone() {\n\t      if (parsedCount == importCount && callback) {\n\t        callback({\n\t          allImports: imports,\n\t          loadedImports: newImports,\n\t          errorImports: errorImports\n\t        });\n\t      }\n\t    }\n\t    function loadedImport(e) {\n\t      markTargetLoaded(e);\n\t      newImports.push(this);\n\t      parsedCount++;\n\t      checkDone();\n\t    }\n\t    function errorLoadingImport(e) {\n\t      errorImports.push(this);\n\t      parsedCount++;\n\t      checkDone();\n\t    }\n\t    if (importCount) {\n\t      for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {\n\t        if (isImportLoaded(imp)) {\n\t          newImports.push(this);\n\t          parsedCount++;\n\t          checkDone();\n\t        } else {\n\t          imp.addEventListener(\"load\", loadedImport);\n\t          imp.addEventListener(\"error\", errorLoadingImport);\n\t        }\n\t      }\n\t    } else {\n\t      checkDone();\n\t    }\n\t  }\n\t  function isImportLoaded(link) {\n\t    return useNative ? link.__loaded || link.import && link.import.readyState !== \"loading\" : link.__importParsed;\n\t  }\n\t  if (useNative) {\n\t    new MutationObserver(function(mxns) {\n\t      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {\n\t        if (m.addedNodes) {\n\t          handleImports(m.addedNodes);\n\t        }\n\t      }\n\t    }).observe(document.head, {\n\t      childList: true\n\t    });\n\t    function handleImports(nodes) {\n\t      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n\t        if (isImport(n)) {\n\t          handleImport(n);\n\t        }\n\t      }\n\t    }\n\t    function isImport(element) {\n\t      return element.localName === \"link\" && element.rel === \"import\";\n\t    }\n\t    function handleImport(element) {\n\t      var loaded = element.import;\n\t      if (loaded) {\n\t        markTargetLoaded({\n\t          target: element\n\t        });\n\t      } else {\n\t        element.addEventListener(\"load\", markTargetLoaded);\n\t        element.addEventListener(\"error\", markTargetLoaded);\n\t      }\n\t    }\n\t    (function() {\n\t      if (document.readyState === \"loading\") {\n\t        var imports = document.querySelectorAll(\"link[rel=import]\");\n\t        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {\n\t          handleImport(imp);\n\t        }\n\t      }\n\t    })();\n\t  }\n\t  whenReady(function(detail) {\n\t    window.HTMLImports.ready = true;\n\t    window.HTMLImports.readyTime = new Date().getTime();\n\t    var evt = rootDocument.createEvent(\"CustomEvent\");\n\t    evt.initCustomEvent(\"HTMLImportsLoaded\", true, true, detail);\n\t    rootDocument.dispatchEvent(evt);\n\t  });\n\t  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\n\t  scope.useNative = useNative;\n\t  scope.rootDocument = rootDocument;\n\t  scope.whenReady = whenReady;\n\t  scope.isIE = isIE;\n\t})(window.HTMLImports);\n\t\n\t(function(scope) {\n\t  var modules = [];\n\t  var addModule = function(module) {\n\t    modules.push(module);\n\t  };\n\t  var initializeModules = function() {\n\t    modules.forEach(function(module) {\n\t      module(scope);\n\t    });\n\t  };\n\t  scope.addModule = addModule;\n\t  scope.initializeModules = initializeModules;\n\t})(window.HTMLImports);\n\t\n\twindow.HTMLImports.addModule(function(scope) {\n\t  var CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\n\t  var CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n\t  var path = {\n\t    resolveUrlsInStyle: function(style, linkUrl) {\n\t      var doc = style.ownerDocument;\n\t      var resolver = doc.createElement(\"a\");\n\t      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);\n\t      return style;\n\t    },\n\t    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {\n\t      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);\n\t      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);\n\t      return r;\n\t    },\n\t    replaceUrls: function(text, urlObj, linkUrl, regexp) {\n\t      return text.replace(regexp, function(m, pre, url, post) {\n\t        var urlPath = url.replace(/[\"']/g, \"\");\n\t        if (linkUrl) {\n\t          urlPath = new URL(urlPath, linkUrl).href;\n\t        }\n\t        urlObj.href = urlPath;\n\t        urlPath = urlObj.href;\n\t        return pre + \"'\" + urlPath + \"'\" + post;\n\t      });\n\t    }\n\t  };\n\t  scope.path = path;\n\t});\n\t\n\twindow.HTMLImports.addModule(function(scope) {\n\t  var xhr = {\n\t    async: true,\n\t    ok: function(request) {\n\t      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;\n\t    },\n\t    load: function(url, next, nextContext) {\n\t      var request = new XMLHttpRequest();\n\t      if (scope.flags.debug || scope.flags.bust) {\n\t        url += \"?\" + Math.random();\n\t      }\n\t      request.open(\"GET\", url, xhr.async);\n\t      request.addEventListener(\"readystatechange\", function(e) {\n\t        if (request.readyState === 4) {\n\t          var redirectedUrl = null;\n\t          try {\n\t            var locationHeader = request.getResponseHeader(\"Location\");\n\t            if (locationHeader) {\n\t              redirectedUrl = locationHeader.substr(0, 1) === \"/\" ? location.origin + locationHeader : locationHeader;\n\t            }\n\t          } catch (e) {\n\t            console.error(e.message);\n\t          }\n\t          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);\n\t        }\n\t      });\n\t      request.send();\n\t      return request;\n\t    },\n\t    loadDocument: function(url, next, nextContext) {\n\t      this.load(url, next, nextContext).responseType = \"document\";\n\t    }\n\t  };\n\t  scope.xhr = xhr;\n\t});\n\t\n\twindow.HTMLImports.addModule(function(scope) {\n\t  var xhr = scope.xhr;\n\t  var flags = scope.flags;\n\t  var Loader = function(onLoad, onComplete) {\n\t    this.cache = {};\n\t    this.onload = onLoad;\n\t    this.oncomplete = onComplete;\n\t    this.inflight = 0;\n\t    this.pending = {};\n\t  };\n\t  Loader.prototype = {\n\t    addNodes: function(nodes) {\n\t      this.inflight += nodes.length;\n\t      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n\t        this.require(n);\n\t      }\n\t      this.checkDone();\n\t    },\n\t    addNode: function(node) {\n\t      this.inflight++;\n\t      this.require(node);\n\t      this.checkDone();\n\t    },\n\t    require: function(elt) {\n\t      var url = elt.src || elt.href;\n\t      elt.__nodeUrl = url;\n\t      if (!this.dedupe(url, elt)) {\n\t        this.fetch(url, elt);\n\t      }\n\t    },\n\t    dedupe: function(url, elt) {\n\t      if (this.pending[url]) {\n\t        this.pending[url].push(elt);\n\t        return true;\n\t      }\n\t      var resource;\n\t      if (this.cache[url]) {\n\t        this.onload(url, elt, this.cache[url]);\n\t        this.tail();\n\t        return true;\n\t      }\n\t      this.pending[url] = [ elt ];\n\t      return false;\n\t    },\n\t    fetch: function(url, elt) {\n\t      flags.load && console.log(\"fetch\", url, elt);\n\t      if (!url) {\n\t        setTimeout(function() {\n\t          this.receive(url, elt, {\n\t            error: \"href must be specified\"\n\t          }, null);\n\t        }.bind(this), 0);\n\t      } else if (url.match(/^data:/)) {\n\t        var pieces = url.split(\",\");\n\t        var header = pieces[0];\n\t        var body = pieces[1];\n\t        if (header.indexOf(\";base64\") > -1) {\n\t          body = atob(body);\n\t        } else {\n\t          body = decodeURIComponent(body);\n\t        }\n\t        setTimeout(function() {\n\t          this.receive(url, elt, null, body);\n\t        }.bind(this), 0);\n\t      } else {\n\t        var receiveXhr = function(err, resource, redirectedUrl) {\n\t          this.receive(url, elt, err, resource, redirectedUrl);\n\t        }.bind(this);\n\t        xhr.load(url, receiveXhr);\n\t      }\n\t    },\n\t    receive: function(url, elt, err, resource, redirectedUrl) {\n\t      this.cache[url] = resource;\n\t      var $p = this.pending[url];\n\t      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\n\t        this.onload(url, p, resource, err, redirectedUrl);\n\t        this.tail();\n\t      }\n\t      this.pending[url] = null;\n\t    },\n\t    tail: function() {\n\t      --this.inflight;\n\t      this.checkDone();\n\t    },\n\t    checkDone: function() {\n\t      if (!this.inflight) {\n\t        this.oncomplete();\n\t      }\n\t    }\n\t  };\n\t  scope.Loader = Loader;\n\t});\n\t\n\twindow.HTMLImports.addModule(function(scope) {\n\t  var Observer = function(addCallback) {\n\t    this.addCallback = addCallback;\n\t    this.mo = new MutationObserver(this.handler.bind(this));\n\t  };\n\t  Observer.prototype = {\n\t    handler: function(mutations) {\n\t      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {\n\t        if (m.type === \"childList\" && m.addedNodes.length) {\n\t          this.addedNodes(m.addedNodes);\n\t        }\n\t      }\n\t    },\n\t    addedNodes: function(nodes) {\n\t      if (this.addCallback) {\n\t        this.addCallback(nodes);\n\t      }\n\t      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {\n\t        if (n.children && n.children.length) {\n\t          this.addedNodes(n.children);\n\t        }\n\t      }\n\t    },\n\t    observe: function(root) {\n\t      this.mo.observe(root, {\n\t        childList: true,\n\t        subtree: true\n\t      });\n\t    }\n\t  };\n\t  scope.Observer = Observer;\n\t});\n\t\n\twindow.HTMLImports.addModule(function(scope) {\n\t  var path = scope.path;\n\t  var rootDocument = scope.rootDocument;\n\t  var flags = scope.flags;\n\t  var isIE = scope.isIE;\n\t  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n\t  var IMPORT_SELECTOR = \"link[rel=\" + IMPORT_LINK_TYPE + \"]\";\n\t  var importParser = {\n\t    documentSelectors: IMPORT_SELECTOR,\n\t    importsSelectors: [ IMPORT_SELECTOR, \"link[rel=stylesheet]:not([type])\", \"style:not([type])\", \"script:not([type])\", 'script[type=\"application/javascript\"]', 'script[type=\"text/javascript\"]' ].join(\",\"),\n\t    map: {\n\t      link: \"parseLink\",\n\t      script: \"parseScript\",\n\t      style: \"parseStyle\"\n\t    },\n\t    dynamicElements: [],\n\t    parseNext: function() {\n\t      var next = this.nextToParse();\n\t      if (next) {\n\t        this.parse(next);\n\t      }\n\t    },\n\t    parse: function(elt) {\n\t      if (this.isParsed(elt)) {\n\t        flags.parse && console.log(\"[%s] is already parsed\", elt.localName);\n\t        return;\n\t      }\n\t      var fn = this[this.map[elt.localName]];\n\t      if (fn) {\n\t        this.markParsing(elt);\n\t        fn.call(this, elt);\n\t      }\n\t    },\n\t    parseDynamic: function(elt, quiet) {\n\t      this.dynamicElements.push(elt);\n\t      if (!quiet) {\n\t        this.parseNext();\n\t      }\n\t    },\n\t    markParsing: function(elt) {\n\t      flags.parse && console.log(\"parsing\", elt);\n\t      this.parsingElement = elt;\n\t    },\n\t    markParsingComplete: function(elt) {\n\t      elt.__importParsed = true;\n\t      this.markDynamicParsingComplete(elt);\n\t      if (elt.__importElement) {\n\t        elt.__importElement.__importParsed = true;\n\t        this.markDynamicParsingComplete(elt.__importElement);\n\t      }\n\t      this.parsingElement = null;\n\t      flags.parse && console.log(\"completed\", elt);\n\t    },\n\t    markDynamicParsingComplete: function(elt) {\n\t      var i = this.dynamicElements.indexOf(elt);\n\t      if (i >= 0) {\n\t        this.dynamicElements.splice(i, 1);\n\t      }\n\t    },\n\t    parseImport: function(elt) {\n\t      elt.import = elt.__doc;\n\t      if (window.HTMLImports.__importsParsingHook) {\n\t        window.HTMLImports.__importsParsingHook(elt);\n\t      }\n\t      if (elt.import) {\n\t        elt.import.__importParsed = true;\n\t      }\n\t      this.markParsingComplete(elt);\n\t      if (elt.__resource && !elt.__error) {\n\t        elt.dispatchEvent(new CustomEvent(\"load\", {\n\t          bubbles: false\n\t        }));\n\t      } else {\n\t        elt.dispatchEvent(new CustomEvent(\"error\", {\n\t          bubbles: false\n\t        }));\n\t      }\n\t      if (elt.__pending) {\n\t        var fn;\n\t        while (elt.__pending.length) {\n\t          fn = elt.__pending.shift();\n\t          if (fn) {\n\t            fn({\n\t              target: elt\n\t            });\n\t          }\n\t        }\n\t      }\n\t      this.parseNext();\n\t    },\n\t    parseLink: function(linkElt) {\n\t      if (nodeIsImport(linkElt)) {\n\t        this.parseImport(linkElt);\n\t      } else {\n\t        linkElt.href = linkElt.href;\n\t        this.parseGeneric(linkElt);\n\t      }\n\t    },\n\t    parseStyle: function(elt) {\n\t      var src = elt;\n\t      elt = cloneStyle(elt);\n\t      src.__appliedElement = elt;\n\t      elt.__importElement = src;\n\t      this.parseGeneric(elt);\n\t    },\n\t    parseGeneric: function(elt) {\n\t      this.trackElement(elt);\n\t      this.addElementToDocument(elt);\n\t    },\n\t    rootImportForElement: function(elt) {\n\t      var n = elt;\n\t      while (n.ownerDocument.__importLink) {\n\t        n = n.ownerDocument.__importLink;\n\t      }\n\t      return n;\n\t    },\n\t    addElementToDocument: function(elt) {\n\t      var port = this.rootImportForElement(elt.__importElement || elt);\n\t      port.parentNode.insertBefore(elt, port);\n\t    },\n\t    trackElement: function(elt, callback) {\n\t      var self = this;\n\t      var done = function(e) {\n\t        elt.removeEventListener(\"load\", done);\n\t        elt.removeEventListener(\"error\", done);\n\t        if (callback) {\n\t          callback(e);\n\t        }\n\t        self.markParsingComplete(elt);\n\t        self.parseNext();\n\t      };\n\t      elt.addEventListener(\"load\", done);\n\t      elt.addEventListener(\"error\", done);\n\t      if (isIE && elt.localName === \"style\") {\n\t        var fakeLoad = false;\n\t        if (elt.textContent.indexOf(\"@import\") == -1) {\n\t          fakeLoad = true;\n\t        } else if (elt.sheet) {\n\t          fakeLoad = true;\n\t          var csr = elt.sheet.cssRules;\n\t          var len = csr ? csr.length : 0;\n\t          for (var i = 0, r; i < len && (r = csr[i]); i++) {\n\t            if (r.type === CSSRule.IMPORT_RULE) {\n\t              fakeLoad = fakeLoad && Boolean(r.styleSheet);\n\t            }\n\t          }\n\t        }\n\t        if (fakeLoad) {\n\t          setTimeout(function() {\n\t            elt.dispatchEvent(new CustomEvent(\"load\", {\n\t              bubbles: false\n\t            }));\n\t          });\n\t        }\n\t      }\n\t    },\n\t    parseScript: function(scriptElt) {\n\t      var script = document.createElement(\"script\");\n\t      script.__importElement = scriptElt;\n\t      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);\n\t      scope.currentScript = scriptElt;\n\t      this.trackElement(script, function(e) {\n\t        if (script.parentNode) {\n\t          script.parentNode.removeChild(script);\n\t        }\n\t        scope.currentScript = null;\n\t      });\n\t      this.addElementToDocument(script);\n\t    },\n\t    nextToParse: function() {\n\t      this._mayParse = [];\n\t      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());\n\t    },\n\t    nextToParseInDoc: function(doc, link) {\n\t      if (doc && this._mayParse.indexOf(doc) < 0) {\n\t        this._mayParse.push(doc);\n\t        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));\n\t        for (var i = 0, l = nodes.length, p = 0, n; i < l && (n = nodes[i]); i++) {\n\t          if (!this.isParsed(n)) {\n\t            if (this.hasResource(n)) {\n\t              return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;\n\t            } else {\n\t              return;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      return link;\n\t    },\n\t    nextToParseDynamic: function() {\n\t      return this.dynamicElements[0];\n\t    },\n\t    parseSelectorsForNode: function(node) {\n\t      var doc = node.ownerDocument || node;\n\t      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;\n\t    },\n\t    isParsed: function(node) {\n\t      return node.__importParsed;\n\t    },\n\t    needsDynamicParsing: function(elt) {\n\t      return this.dynamicElements.indexOf(elt) >= 0;\n\t    },\n\t    hasResource: function(node) {\n\t      if (nodeIsImport(node) && node.__doc === undefined) {\n\t        return false;\n\t      }\n\t      return true;\n\t    }\n\t  };\n\t  function nodeIsImport(elt) {\n\t    return elt.localName === \"link\" && elt.rel === IMPORT_LINK_TYPE;\n\t  }\n\t  function generateScriptDataUrl(script) {\n\t    var scriptContent = generateScriptContent(script);\n\t    return \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(scriptContent);\n\t  }\n\t  function generateScriptContent(script) {\n\t    return script.textContent + generateSourceMapHint(script);\n\t  }\n\t  function generateSourceMapHint(script) {\n\t    var owner = script.ownerDocument;\n\t    owner.__importedScripts = owner.__importedScripts || 0;\n\t    var moniker = script.ownerDocument.baseURI;\n\t    var num = owner.__importedScripts ? \"-\" + owner.__importedScripts : \"\";\n\t    owner.__importedScripts++;\n\t    return \"\\n//# sourceURL=\" + moniker + num + \".js\\n\";\n\t  }\n\t  function cloneStyle(style) {\n\t    var clone = style.ownerDocument.createElement(\"style\");\n\t    clone.textContent = style.textContent;\n\t    path.resolveUrlsInStyle(clone);\n\t    return clone;\n\t  }\n\t  scope.parser = importParser;\n\t  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;\n\t});\n\t\n\twindow.HTMLImports.addModule(function(scope) {\n\t  var flags = scope.flags;\n\t  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n\t  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;\n\t  var rootDocument = scope.rootDocument;\n\t  var Loader = scope.Loader;\n\t  var Observer = scope.Observer;\n\t  var parser = scope.parser;\n\t  var importer = {\n\t    documents: {},\n\t    documentPreloadSelectors: IMPORT_SELECTOR,\n\t    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(\",\"),\n\t    loadNode: function(node) {\n\t      importLoader.addNode(node);\n\t    },\n\t    loadSubtree: function(parent) {\n\t      var nodes = this.marshalNodes(parent);\n\t      importLoader.addNodes(nodes);\n\t    },\n\t    marshalNodes: function(parent) {\n\t      return parent.querySelectorAll(this.loadSelectorsForNode(parent));\n\t    },\n\t    loadSelectorsForNode: function(node) {\n\t      var doc = node.ownerDocument || node;\n\t      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;\n\t    },\n\t    loaded: function(url, elt, resource, err, redirectedUrl) {\n\t      flags.load && console.log(\"loaded\", url, elt);\n\t      elt.__resource = resource;\n\t      elt.__error = err;\n\t      if (isImportLink(elt)) {\n\t        var doc = this.documents[url];\n\t        if (doc === undefined) {\n\t          doc = err ? null : makeDocument(resource, redirectedUrl || url);\n\t          if (doc) {\n\t            doc.__importLink = elt;\n\t            this.bootDocument(doc);\n\t          }\n\t          this.documents[url] = doc;\n\t        }\n\t        elt.__doc = doc;\n\t      }\n\t      parser.parseNext();\n\t    },\n\t    bootDocument: function(doc) {\n\t      this.loadSubtree(doc);\n\t      this.observer.observe(doc);\n\t      parser.parseNext();\n\t    },\n\t    loadedAll: function() {\n\t      parser.parseNext();\n\t    }\n\t  };\n\t  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));\n\t  importer.observer = new Observer();\n\t  function isImportLink(elt) {\n\t    return isLinkRel(elt, IMPORT_LINK_TYPE);\n\t  }\n\t  function isLinkRel(elt, rel) {\n\t    return elt.localName === \"link\" && elt.getAttribute(\"rel\") === rel;\n\t  }\n\t  function hasBaseURIAccessor(doc) {\n\t    return !!Object.getOwnPropertyDescriptor(doc, \"baseURI\");\n\t  }\n\t  function makeDocument(resource, url) {\n\t    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);\n\t    doc._URL = url;\n\t    var base = doc.createElement(\"base\");\n\t    base.setAttribute(\"href\", url);\n\t    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {\n\t      Object.defineProperty(doc, \"baseURI\", {\n\t        value: url\n\t      });\n\t    }\n\t    var meta = doc.createElement(\"meta\");\n\t    meta.setAttribute(\"charset\", \"utf-8\");\n\t    doc.head.appendChild(meta);\n\t    doc.head.appendChild(base);\n\t    doc.body.innerHTML = resource;\n\t    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\n\t      HTMLTemplateElement.bootstrap(doc);\n\t    }\n\t    return doc;\n\t  }\n\t  if (!document.baseURI) {\n\t    var baseURIDescriptor = {\n\t      get: function() {\n\t        var base = document.querySelector(\"base\");\n\t        return base ? base.href : window.location.href;\n\t      },\n\t      configurable: true\n\t    };\n\t    Object.defineProperty(document, \"baseURI\", baseURIDescriptor);\n\t    Object.defineProperty(rootDocument, \"baseURI\", baseURIDescriptor);\n\t  }\n\t  scope.importer = importer;\n\t  scope.importLoader = importLoader;\n\t});\n\t\n\twindow.HTMLImports.addModule(function(scope) {\n\t  var parser = scope.parser;\n\t  var importer = scope.importer;\n\t  var dynamic = {\n\t    added: function(nodes) {\n\t      var owner, parsed, loading;\n\t      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n\t        if (!owner) {\n\t          owner = n.ownerDocument;\n\t          parsed = parser.isParsed(owner);\n\t        }\n\t        loading = this.shouldLoadNode(n);\n\t        if (loading) {\n\t          importer.loadNode(n);\n\t        }\n\t        if (this.shouldParseNode(n) && parsed) {\n\t          parser.parseDynamic(n, loading);\n\t        }\n\t      }\n\t    },\n\t    shouldLoadNode: function(node) {\n\t      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));\n\t    },\n\t    shouldParseNode: function(node) {\n\t      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));\n\t    }\n\t  };\n\t  importer.observer.addCallback = dynamic.added.bind(dynamic);\n\t  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;\n\t});\n\t\n\t(function(scope) {\n\t  var initializeModules = scope.initializeModules;\n\t  var isIE = scope.isIE;\n\t  if (scope.useNative) {\n\t    return;\n\t  }\n\t  initializeModules();\n\t  var rootDocument = scope.rootDocument;\n\t  function bootstrap() {\n\t    window.HTMLImports.importer.bootDocument(rootDocument);\n\t  }\n\t  if (document.readyState === \"complete\" || document.readyState === \"interactive\" && !window.attachEvent) {\n\t    bootstrap();\n\t  } else {\n\t    document.addEventListener(\"DOMContentLoaded\", bootstrap);\n\t  }\n\t})(window.HTMLImports);\n\t\n\twindow.CustomElements = window.CustomElements || {\n\t  flags: {}\n\t};\n\t\n\t(function(scope) {\n\t  var flags = scope.flags;\n\t  var modules = [];\n\t  var addModule = function(module) {\n\t    modules.push(module);\n\t  };\n\t  var initializeModules = function() {\n\t    modules.forEach(function(module) {\n\t      module(scope);\n\t    });\n\t  };\n\t  scope.addModule = addModule;\n\t  scope.initializeModules = initializeModules;\n\t  scope.hasNative = Boolean(document.registerElement);\n\t  scope.isIE = /Trident/.test(navigator.userAgent);\n\t  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);\n\t})(window.CustomElements);\n\t\n\twindow.CustomElements.addModule(function(scope) {\n\t  var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : \"none\";\n\t  function forSubtree(node, cb) {\n\t    findAllElements(node, function(e) {\n\t      if (cb(e)) {\n\t        return true;\n\t      }\n\t      forRoots(e, cb);\n\t    });\n\t    forRoots(node, cb);\n\t  }\n\t  function findAllElements(node, find, data) {\n\t    var e = node.firstElementChild;\n\t    if (!e) {\n\t      e = node.firstChild;\n\t      while (e && e.nodeType !== Node.ELEMENT_NODE) {\n\t        e = e.nextSibling;\n\t      }\n\t    }\n\t    while (e) {\n\t      if (find(e, data) !== true) {\n\t        findAllElements(e, find, data);\n\t      }\n\t      e = e.nextElementSibling;\n\t    }\n\t    return null;\n\t  }\n\t  function forRoots(node, cb) {\n\t    var root = node.shadowRoot;\n\t    while (root) {\n\t      forSubtree(root, cb);\n\t      root = root.olderShadowRoot;\n\t    }\n\t  }\n\t  function forDocumentTree(doc, cb) {\n\t    _forDocumentTree(doc, cb, []);\n\t  }\n\t  function _forDocumentTree(doc, cb, processingDocuments) {\n\t    doc = window.wrap(doc);\n\t    if (processingDocuments.indexOf(doc) >= 0) {\n\t      return;\n\t    }\n\t    processingDocuments.push(doc);\n\t    var imports = doc.querySelectorAll(\"link[rel=\" + IMPORT_LINK_TYPE + \"]\");\n\t    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {\n\t      if (n.import) {\n\t        _forDocumentTree(n.import, cb, processingDocuments);\n\t      }\n\t    }\n\t    cb(doc);\n\t  }\n\t  scope.forDocumentTree = forDocumentTree;\n\t  scope.forSubtree = forSubtree;\n\t});\n\t\n\twindow.CustomElements.addModule(function(scope) {\n\t  var flags = scope.flags;\n\t  var forSubtree = scope.forSubtree;\n\t  var forDocumentTree = scope.forDocumentTree;\n\t  function addedNode(node, isAttached) {\n\t    return added(node, isAttached) || addedSubtree(node, isAttached);\n\t  }\n\t  function added(node, isAttached) {\n\t    if (scope.upgrade(node, isAttached)) {\n\t      return true;\n\t    }\n\t    if (isAttached) {\n\t      attached(node);\n\t    }\n\t  }\n\t  function addedSubtree(node, isAttached) {\n\t    forSubtree(node, function(e) {\n\t      if (added(e, isAttached)) {\n\t        return true;\n\t      }\n\t    });\n\t  }\n\t  var hasThrottledAttached = window.MutationObserver._isPolyfilled && flags[\"throttle-attached\"];\n\t  scope.hasPolyfillMutations = hasThrottledAttached;\n\t  scope.hasThrottledAttached = hasThrottledAttached;\n\t  var isPendingMutations = false;\n\t  var pendingMutations = [];\n\t  function deferMutation(fn) {\n\t    pendingMutations.push(fn);\n\t    if (!isPendingMutations) {\n\t      isPendingMutations = true;\n\t      setTimeout(takeMutations);\n\t    }\n\t  }\n\t  function takeMutations() {\n\t    isPendingMutations = false;\n\t    var $p = pendingMutations;\n\t    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\n\t      p();\n\t    }\n\t    pendingMutations = [];\n\t  }\n\t  function attached(element) {\n\t    if (hasThrottledAttached) {\n\t      deferMutation(function() {\n\t        _attached(element);\n\t      });\n\t    } else {\n\t      _attached(element);\n\t    }\n\t  }\n\t  function _attached(element) {\n\t    if (element.__upgraded__ && !element.__attached) {\n\t      element.__attached = true;\n\t      if (element.attachedCallback) {\n\t        element.attachedCallback();\n\t      }\n\t    }\n\t  }\n\t  function detachedNode(node) {\n\t    detached(node);\n\t    forSubtree(node, function(e) {\n\t      detached(e);\n\t    });\n\t  }\n\t  function detached(element) {\n\t    if (hasThrottledAttached) {\n\t      deferMutation(function() {\n\t        _detached(element);\n\t      });\n\t    } else {\n\t      _detached(element);\n\t    }\n\t  }\n\t  function _detached(element) {\n\t    if (element.__upgraded__ && element.__attached) {\n\t      element.__attached = false;\n\t      if (element.detachedCallback) {\n\t        element.detachedCallback();\n\t      }\n\t    }\n\t  }\n\t  function inDocument(element) {\n\t    var p = element;\n\t    var doc = window.wrap(document);\n\t    while (p) {\n\t      if (p == doc) {\n\t        return true;\n\t      }\n\t      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;\n\t    }\n\t  }\n\t  function watchShadow(node) {\n\t    if (node.shadowRoot && !node.shadowRoot.__watched) {\n\t      flags.dom && console.log(\"watching shadow-root for: \", node.localName);\n\t      var root = node.shadowRoot;\n\t      while (root) {\n\t        observe(root);\n\t        root = root.olderShadowRoot;\n\t      }\n\t    }\n\t  }\n\t  function handler(root, mutations) {\n\t    if (flags.dom) {\n\t      var mx = mutations[0];\n\t      if (mx && mx.type === \"childList\" && mx.addedNodes) {\n\t        if (mx.addedNodes) {\n\t          var d = mx.addedNodes[0];\n\t          while (d && d !== document && !d.host) {\n\t            d = d.parentNode;\n\t          }\n\t          var u = d && (d.URL || d._URL || d.host && d.host.localName) || \"\";\n\t          u = u.split(\"/?\").shift().split(\"/\").pop();\n\t        }\n\t      }\n\t      console.group(\"mutations (%d) [%s]\", mutations.length, u || \"\");\n\t    }\n\t    var isAttached = inDocument(root);\n\t    mutations.forEach(function(mx) {\n\t      if (mx.type === \"childList\") {\n\t        forEach(mx.addedNodes, function(n) {\n\t          if (!n.localName) {\n\t            return;\n\t          }\n\t          addedNode(n, isAttached);\n\t        });\n\t        forEach(mx.removedNodes, function(n) {\n\t          if (!n.localName) {\n\t            return;\n\t          }\n\t          detachedNode(n);\n\t        });\n\t      }\n\t    });\n\t    flags.dom && console.groupEnd();\n\t  }\n\t  function takeRecords(node) {\n\t    node = window.wrap(node);\n\t    if (!node) {\n\t      node = window.wrap(document);\n\t    }\n\t    while (node.parentNode) {\n\t      node = node.parentNode;\n\t    }\n\t    var observer = node.__observer;\n\t    if (observer) {\n\t      handler(node, observer.takeRecords());\n\t      takeMutations();\n\t    }\n\t  }\n\t  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n\t  function observe(inRoot) {\n\t    if (inRoot.__observer) {\n\t      return;\n\t    }\n\t    var observer = new MutationObserver(handler.bind(this, inRoot));\n\t    observer.observe(inRoot, {\n\t      childList: true,\n\t      subtree: true\n\t    });\n\t    inRoot.__observer = observer;\n\t  }\n\t  function upgradeDocument(doc) {\n\t    doc = window.wrap(doc);\n\t    flags.dom && console.group(\"upgradeDocument: \", doc.baseURI.split(\"/\").pop());\n\t    var isMainDocument = doc === window.wrap(document);\n\t    addedNode(doc, isMainDocument);\n\t    observe(doc);\n\t    flags.dom && console.groupEnd();\n\t  }\n\t  function upgradeDocumentTree(doc) {\n\t    forDocumentTree(doc, upgradeDocument);\n\t  }\n\t  var originalCreateShadowRoot = Element.prototype.createShadowRoot;\n\t  if (originalCreateShadowRoot) {\n\t    Element.prototype.createShadowRoot = function() {\n\t      var root = originalCreateShadowRoot.call(this);\n\t      window.CustomElements.watchShadow(this);\n\t      return root;\n\t    };\n\t  }\n\t  scope.watchShadow = watchShadow;\n\t  scope.upgradeDocumentTree = upgradeDocumentTree;\n\t  scope.upgradeDocument = upgradeDocument;\n\t  scope.upgradeSubtree = addedSubtree;\n\t  scope.upgradeAll = addedNode;\n\t  scope.attached = attached;\n\t  scope.takeRecords = takeRecords;\n\t});\n\t\n\twindow.CustomElements.addModule(function(scope) {\n\t  var flags = scope.flags;\n\t  function upgrade(node, isAttached) {\n\t    if (node.localName === \"template\") {\n\t      if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n\t        HTMLTemplateElement.decorate(node);\n\t      }\n\t    }\n\t    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {\n\t      var is = node.getAttribute(\"is\");\n\t      var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);\n\t      if (definition) {\n\t        if (is && definition.tag == node.localName || !is && !definition.extends) {\n\t          return upgradeWithDefinition(node, definition, isAttached);\n\t        }\n\t      }\n\t    }\n\t  }\n\t  function upgradeWithDefinition(element, definition, isAttached) {\n\t    flags.upgrade && console.group(\"upgrade:\", element.localName);\n\t    if (definition.is) {\n\t      element.setAttribute(\"is\", definition.is);\n\t    }\n\t    implementPrototype(element, definition);\n\t    element.__upgraded__ = true;\n\t    created(element);\n\t    if (isAttached) {\n\t      scope.attached(element);\n\t    }\n\t    scope.upgradeSubtree(element, isAttached);\n\t    flags.upgrade && console.groupEnd();\n\t    return element;\n\t  }\n\t  function implementPrototype(element, definition) {\n\t    if (Object.__proto__) {\n\t      element.__proto__ = definition.prototype;\n\t    } else {\n\t      customMixin(element, definition.prototype, definition.native);\n\t      element.__proto__ = definition.prototype;\n\t    }\n\t  }\n\t  function customMixin(inTarget, inSrc, inNative) {\n\t    var used = {};\n\t    var p = inSrc;\n\t    while (p !== inNative && p !== HTMLElement.prototype) {\n\t      var keys = Object.getOwnPropertyNames(p);\n\t      for (var i = 0, k; k = keys[i]; i++) {\n\t        if (!used[k]) {\n\t          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));\n\t          used[k] = 1;\n\t        }\n\t      }\n\t      p = Object.getPrototypeOf(p);\n\t    }\n\t  }\n\t  function created(element) {\n\t    if (element.createdCallback) {\n\t      element.createdCallback();\n\t    }\n\t  }\n\t  scope.upgrade = upgrade;\n\t  scope.upgradeWithDefinition = upgradeWithDefinition;\n\t  scope.implementPrototype = implementPrototype;\n\t});\n\t\n\twindow.CustomElements.addModule(function(scope) {\n\t  var isIE = scope.isIE;\n\t  var upgradeDocumentTree = scope.upgradeDocumentTree;\n\t  var upgradeAll = scope.upgradeAll;\n\t  var upgradeWithDefinition = scope.upgradeWithDefinition;\n\t  var implementPrototype = scope.implementPrototype;\n\t  var useNative = scope.useNative;\n\t  function register(name, options) {\n\t    var definition = options || {};\n\t    if (!name) {\n\t      throw new Error(\"document.registerElement: first argument `name` must not be empty\");\n\t    }\n\t    if (name.indexOf(\"-\") < 0) {\n\t      throw new Error(\"document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '\" + String(name) + \"'.\");\n\t    }\n\t    if (isReservedTag(name)) {\n\t      throw new Error(\"Failed to execute 'registerElement' on 'Document': Registration failed for type '\" + String(name) + \"'. The type name is invalid.\");\n\t    }\n\t    if (getRegisteredDefinition(name)) {\n\t      throw new Error(\"DuplicateDefinitionError: a type with name '\" + String(name) + \"' is already registered\");\n\t    }\n\t    if (!definition.prototype) {\n\t      definition.prototype = Object.create(HTMLElement.prototype);\n\t    }\n\t    definition.__name = name.toLowerCase();\n\t    definition.lifecycle = definition.lifecycle || {};\n\t    definition.ancestry = ancestry(definition.extends);\n\t    resolveTagName(definition);\n\t    resolvePrototypeChain(definition);\n\t    overrideAttributeApi(definition.prototype);\n\t    registerDefinition(definition.__name, definition);\n\t    definition.ctor = generateConstructor(definition);\n\t    definition.ctor.prototype = definition.prototype;\n\t    definition.prototype.constructor = definition.ctor;\n\t    if (scope.ready) {\n\t      upgradeDocumentTree(document);\n\t    }\n\t    return definition.ctor;\n\t  }\n\t  function overrideAttributeApi(prototype) {\n\t    if (prototype.setAttribute._polyfilled) {\n\t      return;\n\t    }\n\t    var setAttribute = prototype.setAttribute;\n\t    prototype.setAttribute = function(name, value) {\n\t      changeAttribute.call(this, name, value, setAttribute);\n\t    };\n\t    var removeAttribute = prototype.removeAttribute;\n\t    prototype.removeAttribute = function(name) {\n\t      changeAttribute.call(this, name, null, removeAttribute);\n\t    };\n\t    prototype.setAttribute._polyfilled = true;\n\t  }\n\t  function changeAttribute(name, value, operation) {\n\t    name = name.toLowerCase();\n\t    var oldValue = this.getAttribute(name);\n\t    operation.apply(this, arguments);\n\t    var newValue = this.getAttribute(name);\n\t    if (this.attributeChangedCallback && newValue !== oldValue) {\n\t      this.attributeChangedCallback(name, oldValue, newValue);\n\t    }\n\t  }\n\t  function isReservedTag(name) {\n\t    for (var i = 0; i < reservedTagList.length; i++) {\n\t      if (name === reservedTagList[i]) {\n\t        return true;\n\t      }\n\t    }\n\t  }\n\t  var reservedTagList = [ \"annotation-xml\", \"color-profile\", \"font-face\", \"font-face-src\", \"font-face-uri\", \"font-face-format\", \"font-face-name\", \"missing-glyph\" ];\n\t  function ancestry(extnds) {\n\t    var extendee = getRegisteredDefinition(extnds);\n\t    if (extendee) {\n\t      return ancestry(extendee.extends).concat([ extendee ]);\n\t    }\n\t    return [];\n\t  }\n\t  function resolveTagName(definition) {\n\t    var baseTag = definition.extends;\n\t    for (var i = 0, a; a = definition.ancestry[i]; i++) {\n\t      baseTag = a.is && a.tag;\n\t    }\n\t    definition.tag = baseTag || definition.__name;\n\t    if (baseTag) {\n\t      definition.is = definition.__name;\n\t    }\n\t  }\n\t  function resolvePrototypeChain(definition) {\n\t    if (!Object.__proto__) {\n\t      var nativePrototype = HTMLElement.prototype;\n\t      if (definition.is) {\n\t        var inst = document.createElement(definition.tag);\n\t        nativePrototype = Object.getPrototypeOf(inst);\n\t      }\n\t      var proto = definition.prototype, ancestor;\n\t      var foundPrototype = false;\n\t      while (proto) {\n\t        if (proto == nativePrototype) {\n\t          foundPrototype = true;\n\t        }\n\t        ancestor = Object.getPrototypeOf(proto);\n\t        if (ancestor) {\n\t          proto.__proto__ = ancestor;\n\t        }\n\t        proto = ancestor;\n\t      }\n\t      if (!foundPrototype) {\n\t        console.warn(definition.tag + \" prototype not found in prototype chain for \" + definition.is);\n\t      }\n\t      definition.native = nativePrototype;\n\t    }\n\t  }\n\t  function instantiate(definition) {\n\t    return upgradeWithDefinition(domCreateElement(definition.tag), definition);\n\t  }\n\t  var registry = {};\n\t  function getRegisteredDefinition(name) {\n\t    if (name) {\n\t      return registry[name.toLowerCase()];\n\t    }\n\t  }\n\t  function registerDefinition(name, definition) {\n\t    registry[name] = definition;\n\t  }\n\t  function generateConstructor(definition) {\n\t    return function() {\n\t      return instantiate(definition);\n\t    };\n\t  }\n\t  var HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n\t  function createElementNS(namespace, tag, typeExtension) {\n\t    if (namespace === HTML_NAMESPACE) {\n\t      return createElement(tag, typeExtension);\n\t    } else {\n\t      return domCreateElementNS(namespace, tag);\n\t    }\n\t  }\n\t  function createElement(tag, typeExtension) {\n\t    if (tag) {\n\t      tag = tag.toLowerCase();\n\t    }\n\t    if (typeExtension) {\n\t      typeExtension = typeExtension.toLowerCase();\n\t    }\n\t    var definition = getRegisteredDefinition(typeExtension || tag);\n\t    if (definition) {\n\t      if (tag == definition.tag && typeExtension == definition.is) {\n\t        return new definition.ctor();\n\t      }\n\t      if (!typeExtension && !definition.is) {\n\t        return new definition.ctor();\n\t      }\n\t    }\n\t    var element;\n\t    if (typeExtension) {\n\t      element = createElement(tag);\n\t      element.setAttribute(\"is\", typeExtension);\n\t      return element;\n\t    }\n\t    element = domCreateElement(tag);\n\t    if (tag.indexOf(\"-\") >= 0) {\n\t      implementPrototype(element, HTMLElement);\n\t    }\n\t    return element;\n\t  }\n\t  var domCreateElement = document.createElement.bind(document);\n\t  var domCreateElementNS = document.createElementNS.bind(document);\n\t  var isInstance;\n\t  if (!Object.__proto__ && !useNative) {\n\t    isInstance = function(obj, ctor) {\n\t      if (obj instanceof ctor) {\n\t        return true;\n\t      }\n\t      var p = obj;\n\t      while (p) {\n\t        if (p === ctor.prototype) {\n\t          return true;\n\t        }\n\t        p = p.__proto__;\n\t      }\n\t      return false;\n\t    };\n\t  } else {\n\t    isInstance = function(obj, base) {\n\t      return obj instanceof base;\n\t    };\n\t  }\n\t  function wrapDomMethodToForceUpgrade(obj, methodName) {\n\t    var orig = obj[methodName];\n\t    obj[methodName] = function() {\n\t      var n = orig.apply(this, arguments);\n\t      upgradeAll(n);\n\t      return n;\n\t    };\n\t  }\n\t  wrapDomMethodToForceUpgrade(Node.prototype, \"cloneNode\");\n\t  wrapDomMethodToForceUpgrade(document, \"importNode\");\n\t  if (isIE) {\n\t    (function() {\n\t      var importNode = document.importNode;\n\t      document.importNode = function() {\n\t        var n = importNode.apply(document, arguments);\n\t        if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {\n\t          var f = document.createDocumentFragment();\n\t          f.appendChild(n);\n\t          return f;\n\t        } else {\n\t          return n;\n\t        }\n\t      };\n\t    })();\n\t  }\n\t  document.registerElement = register;\n\t  document.createElement = createElement;\n\t  document.createElementNS = createElementNS;\n\t  scope.registry = registry;\n\t  scope.instanceof = isInstance;\n\t  scope.reservedTagList = reservedTagList;\n\t  scope.getRegisteredDefinition = getRegisteredDefinition;\n\t  document.register = document.registerElement;\n\t});\n\t\n\t(function(scope) {\n\t  var useNative = scope.useNative;\n\t  var initializeModules = scope.initializeModules;\n\t  var isIE = scope.isIE;\n\t  if (useNative) {\n\t    var nop = function() {};\n\t    scope.watchShadow = nop;\n\t    scope.upgrade = nop;\n\t    scope.upgradeAll = nop;\n\t    scope.upgradeDocumentTree = nop;\n\t    scope.upgradeSubtree = nop;\n\t    scope.takeRecords = nop;\n\t    scope.instanceof = function(obj, base) {\n\t      return obj instanceof base;\n\t    };\n\t  } else {\n\t    initializeModules();\n\t  }\n\t  var upgradeDocumentTree = scope.upgradeDocumentTree;\n\t  var upgradeDocument = scope.upgradeDocument;\n\t  if (!window.wrap) {\n\t    if (window.ShadowDOMPolyfill) {\n\t      window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;\n\t      window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;\n\t    } else {\n\t      window.wrap = window.unwrap = function(node) {\n\t        return node;\n\t      };\n\t    }\n\t  }\n\t  if (window.HTMLImports) {\n\t    window.HTMLImports.__importsParsingHook = function(elt) {\n\t      if (elt.import) {\n\t        upgradeDocument(wrap(elt.import));\n\t      }\n\t    };\n\t  }\n\t  function bootstrap() {\n\t    upgradeDocumentTree(window.wrap(document));\n\t    window.CustomElements.ready = true;\n\t    var requestAnimationFrame = window.requestAnimationFrame || function(f) {\n\t      setTimeout(f, 16);\n\t    };\n\t    requestAnimationFrame(function() {\n\t      setTimeout(function() {\n\t        window.CustomElements.readyTime = Date.now();\n\t        if (window.HTMLImports) {\n\t          window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;\n\t        }\n\t        document.dispatchEvent(new CustomEvent(\"WebComponentsReady\", {\n\t          bubbles: true\n\t        }));\n\t      });\n\t    });\n\t  }\n\t  if (document.readyState === \"complete\" || scope.flags.eager) {\n\t    bootstrap();\n\t  } else if (document.readyState === \"interactive\" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {\n\t    bootstrap();\n\t  } else {\n\t    var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? \"HTMLImportsLoaded\" : \"DOMContentLoaded\";\n\t    window.addEventListener(loadEvent, bootstrap);\n\t  }\n\t})(window.CustomElements);\n\t\n\t(function(scope) {\n\t  if (!Function.prototype.bind) {\n\t    Function.prototype.bind = function(scope) {\n\t      var self = this;\n\t      var args = Array.prototype.slice.call(arguments, 1);\n\t      return function() {\n\t        var args2 = args.slice();\n\t        args2.push.apply(args2, arguments);\n\t        return self.apply(scope, args2);\n\t      };\n\t    };\n\t  }\n\t})(window.WebComponents);\n\t\n\t(function(scope) {\n\t  var style = document.createElement(\"style\");\n\t  style.textContent = \"\" + \"body {\" + \"transition: opacity ease-in 0.2s;\" + \" } \\n\" + \"body[unresolved] {\" + \"opacity: 0; display: block; overflow: hidden; position: relative;\" + \" } \\n\";\n\t  var head = document.querySelector(\"head\");\n\t  head.insertBefore(style, head.firstChild);\n\t})(window.WebComponents);\n\t\n\t(function(scope) {\n\t  window.Platform = scope;\n\t})(window.WebComponents);\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** webcomponent.91fc0dafbd71512e1b52.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 91fc0dafbd71512e1b52\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n// @version 0.7.20\n(function() {\n  window.WebComponents = window.WebComponents || {\n    flags: {}\n  };\n  var file = \"webcomponents.js\";\n  var script = document.querySelector('script[src*=\"' + file + '\"]');\n  var flags = {};\n  if (!flags.noOpts) {\n    location.search.slice(1).split(\"&\").forEach(function(option) {\n      var parts = option.split(\"=\");\n      var match;\n      if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {\n        flags[match[1]] = parts[1] || true;\n      }\n    });\n    if (script) {\n      for (var i = 0, a; a = script.attributes[i]; i++) {\n        if (a.name !== \"src\") {\n          flags[a.name] = a.value || true;\n        }\n      }\n    }\n    if (flags.log && flags.log.split) {\n      var parts = flags.log.split(\",\");\n      flags.log = {};\n      parts.forEach(function(f) {\n        flags.log[f] = true;\n      });\n    } else {\n      flags.log = {};\n    }\n  }\n  flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;\n  if (flags.shadow === \"native\") {\n    flags.shadow = false;\n  } else {\n    flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;\n  }\n  if (flags.register) {\n    window.CustomElements = window.CustomElements || {\n      flags: {}\n    };\n    window.CustomElements.flags.register = flags.register;\n  }\n  WebComponents.flags = flags;\n})();\n\nif (WebComponents.flags.shadow) {\n  if (typeof WeakMap === \"undefined\") {\n    (function() {\n      var defineProperty = Object.defineProperty;\n      var counter = Date.now() % 1e9;\n      var WeakMap = function() {\n        this.name = \"__st\" + (Math.random() * 1e9 >>> 0) + (counter++ + \"__\");\n      };\n      WeakMap.prototype = {\n        set: function(key, value) {\n          var entry = key[this.name];\n          if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {\n            value: [ key, value ],\n            writable: true\n          });\n          return this;\n        },\n        get: function(key) {\n          var entry;\n          return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;\n        },\n        \"delete\": function(key) {\n          var entry = key[this.name];\n          if (!entry || entry[0] !== key) return false;\n          entry[0] = entry[1] = undefined;\n          return true;\n        },\n        has: function(key) {\n          var entry = key[this.name];\n          if (!entry) return false;\n          return entry[0] === key;\n        }\n      };\n      window.WeakMap = WeakMap;\n    })();\n  }\n  window.ShadowDOMPolyfill = {};\n  (function(scope) {\n    \"use strict\";\n    var constructorTable = new WeakMap();\n    var nativePrototypeTable = new WeakMap();\n    var wrappers = Object.create(null);\n    function detectEval() {\n      if (typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime) {\n        return false;\n      }\n      if (navigator.getDeviceStorage) {\n        return false;\n      }\n      try {\n        var f = new Function(\"return true;\");\n        return f();\n      } catch (ex) {\n        return false;\n      }\n    }\n    var hasEval = detectEval();\n    function assert(b) {\n      if (!b) throw new Error(\"Assertion failed\");\n    }\n    var defineProperty = Object.defineProperty;\n    var getOwnPropertyNames = Object.getOwnPropertyNames;\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    function mixin(to, from) {\n      var names = getOwnPropertyNames(from);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n      }\n      return to;\n    }\n    function mixinStatics(to, from) {\n      var names = getOwnPropertyNames(from);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        switch (name) {\n         case \"arguments\":\n         case \"caller\":\n         case \"length\":\n         case \"name\":\n         case \"prototype\":\n         case \"toString\":\n          continue;\n        }\n        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n      }\n      return to;\n    }\n    function oneOf(object, propertyNames) {\n      for (var i = 0; i < propertyNames.length; i++) {\n        if (propertyNames[i] in object) return propertyNames[i];\n      }\n    }\n    var nonEnumerableDataDescriptor = {\n      value: undefined,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    };\n    function defineNonEnumerableDataProperty(object, name, value) {\n      nonEnumerableDataDescriptor.value = value;\n      defineProperty(object, name, nonEnumerableDataDescriptor);\n    }\n    getOwnPropertyNames(window);\n    function getWrapperConstructor(node, opt_instance) {\n      var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);\n      if (isFirefox) {\n        try {\n          getOwnPropertyNames(nativePrototype);\n        } catch (error) {\n          nativePrototype = nativePrototype.__proto__;\n        }\n      }\n      var wrapperConstructor = constructorTable.get(nativePrototype);\n      if (wrapperConstructor) return wrapperConstructor;\n      var parentWrapperConstructor = getWrapperConstructor(nativePrototype);\n      var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);\n      registerInternal(nativePrototype, GeneratedWrapper, opt_instance);\n      return GeneratedWrapper;\n    }\n    function addForwardingProperties(nativePrototype, wrapperPrototype) {\n      installProperty(nativePrototype, wrapperPrototype, true);\n    }\n    function registerInstanceProperties(wrapperPrototype, instanceObject) {\n      installProperty(instanceObject, wrapperPrototype, false);\n    }\n    var isFirefox = /Firefox/.test(navigator.userAgent);\n    var dummyDescriptor = {\n      get: function() {},\n      set: function(v) {},\n      configurable: true,\n      enumerable: true\n    };\n    function isEventHandlerName(name) {\n      return /^on[a-z]+$/.test(name);\n    }\n    function isIdentifierName(name) {\n      return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);\n    }\n    function getGetter(name) {\n      return hasEval && isIdentifierName(name) ? new Function(\"return this.__impl4cf1e782hg__.\" + name) : function() {\n        return this.__impl4cf1e782hg__[name];\n      };\n    }\n    function getSetter(name) {\n      return hasEval && isIdentifierName(name) ? new Function(\"v\", \"this.__impl4cf1e782hg__.\" + name + \" = v\") : function(v) {\n        this.__impl4cf1e782hg__[name] = v;\n      };\n    }\n    function getMethod(name) {\n      return hasEval && isIdentifierName(name) ? new Function(\"return this.__impl4cf1e782hg__.\" + name + \".apply(this.__impl4cf1e782hg__, arguments)\") : function() {\n        return this.__impl4cf1e782hg__[name].apply(this.__impl4cf1e782hg__, arguments);\n      };\n    }\n    function getDescriptor(source, name) {\n      try {\n        return Object.getOwnPropertyDescriptor(source, name);\n      } catch (ex) {\n        return dummyDescriptor;\n      }\n    }\n    var isBrokenSafari = function() {\n      var descr = Object.getOwnPropertyDescriptor(Node.prototype, \"nodeType\");\n      return descr && !descr.get && !descr.set;\n    }();\n    function installProperty(source, target, allowMethod, opt_blacklist) {\n      var names = getOwnPropertyNames(source);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        if (name === \"polymerBlackList_\") continue;\n        if (name in target) continue;\n        if (source.polymerBlackList_ && source.polymerBlackList_[name]) continue;\n        if (isFirefox) {\n          source.__lookupGetter__(name);\n        }\n        var descriptor = getDescriptor(source, name);\n        var getter, setter;\n        if (typeof descriptor.value === \"function\") {\n          if (allowMethod) {\n            target[name] = getMethod(name);\n          }\n          continue;\n        }\n        var isEvent = isEventHandlerName(name);\n        if (isEvent) getter = scope.getEventHandlerGetter(name); else getter = getGetter(name);\n        if (descriptor.writable || descriptor.set || isBrokenSafari) {\n          if (isEvent) setter = scope.getEventHandlerSetter(name); else setter = getSetter(name);\n        }\n        var configurable = isBrokenSafari || descriptor.configurable;\n        defineProperty(target, name, {\n          get: getter,\n          set: setter,\n          configurable: configurable,\n          enumerable: descriptor.enumerable\n        });\n      }\n    }\n    function register(nativeConstructor, wrapperConstructor, opt_instance) {\n      if (nativeConstructor == null) {\n        return;\n      }\n      var nativePrototype = nativeConstructor.prototype;\n      registerInternal(nativePrototype, wrapperConstructor, opt_instance);\n      mixinStatics(wrapperConstructor, nativeConstructor);\n    }\n    function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {\n      var wrapperPrototype = wrapperConstructor.prototype;\n      assert(constructorTable.get(nativePrototype) === undefined);\n      constructorTable.set(nativePrototype, wrapperConstructor);\n      nativePrototypeTable.set(wrapperPrototype, nativePrototype);\n      addForwardingProperties(nativePrototype, wrapperPrototype);\n      if (opt_instance) registerInstanceProperties(wrapperPrototype, opt_instance);\n      defineNonEnumerableDataProperty(wrapperPrototype, \"constructor\", wrapperConstructor);\n      wrapperConstructor.prototype = wrapperPrototype;\n    }\n    function isWrapperFor(wrapperConstructor, nativeConstructor) {\n      return constructorTable.get(nativeConstructor.prototype) === wrapperConstructor;\n    }\n    function registerObject(object) {\n      var nativePrototype = Object.getPrototypeOf(object);\n      var superWrapperConstructor = getWrapperConstructor(nativePrototype);\n      var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);\n      registerInternal(nativePrototype, GeneratedWrapper, object);\n      return GeneratedWrapper;\n    }\n    function createWrapperConstructor(superWrapperConstructor) {\n      function GeneratedWrapper(node) {\n        superWrapperConstructor.call(this, node);\n      }\n      var p = Object.create(superWrapperConstructor.prototype);\n      p.constructor = GeneratedWrapper;\n      GeneratedWrapper.prototype = p;\n      return GeneratedWrapper;\n    }\n    function isWrapper(object) {\n      return object && object.__impl4cf1e782hg__;\n    }\n    function isNative(object) {\n      return !isWrapper(object);\n    }\n    function wrap(impl) {\n      if (impl === null) return null;\n      assert(isNative(impl));\n      var wrapper = impl.__wrapper8e3dd93a60__;\n      if (wrapper != null) {\n        return wrapper;\n      }\n      return impl.__wrapper8e3dd93a60__ = new (getWrapperConstructor(impl, impl))(impl);\n    }\n    function unwrap(wrapper) {\n      if (wrapper === null) return null;\n      assert(isWrapper(wrapper));\n      return wrapper.__impl4cf1e782hg__;\n    }\n    function unsafeUnwrap(wrapper) {\n      return wrapper.__impl4cf1e782hg__;\n    }\n    function setWrapper(impl, wrapper) {\n      wrapper.__impl4cf1e782hg__ = impl;\n      impl.__wrapper8e3dd93a60__ = wrapper;\n    }\n    function unwrapIfNeeded(object) {\n      return object && isWrapper(object) ? unwrap(object) : object;\n    }\n    function wrapIfNeeded(object) {\n      return object && !isWrapper(object) ? wrap(object) : object;\n    }\n    function rewrap(node, wrapper) {\n      if (wrapper === null) return;\n      assert(isNative(node));\n      assert(wrapper === undefined || isWrapper(wrapper));\n      node.__wrapper8e3dd93a60__ = wrapper;\n    }\n    var getterDescriptor = {\n      get: undefined,\n      configurable: true,\n      enumerable: true\n    };\n    function defineGetter(constructor, name, getter) {\n      getterDescriptor.get = getter;\n      defineProperty(constructor.prototype, name, getterDescriptor);\n    }\n    function defineWrapGetter(constructor, name) {\n      defineGetter(constructor, name, function() {\n        return wrap(this.__impl4cf1e782hg__[name]);\n      });\n    }\n    function forwardMethodsToWrapper(constructors, names) {\n      constructors.forEach(function(constructor) {\n        names.forEach(function(name) {\n          constructor.prototype[name] = function() {\n            var w = wrapIfNeeded(this);\n            return w[name].apply(w, arguments);\n          };\n        });\n      });\n    }\n    scope.addForwardingProperties = addForwardingProperties;\n    scope.assert = assert;\n    scope.constructorTable = constructorTable;\n    scope.defineGetter = defineGetter;\n    scope.defineWrapGetter = defineWrapGetter;\n    scope.forwardMethodsToWrapper = forwardMethodsToWrapper;\n    scope.isIdentifierName = isIdentifierName;\n    scope.isWrapper = isWrapper;\n    scope.isWrapperFor = isWrapperFor;\n    scope.mixin = mixin;\n    scope.nativePrototypeTable = nativePrototypeTable;\n    scope.oneOf = oneOf;\n    scope.registerObject = registerObject;\n    scope.registerWrapper = register;\n    scope.rewrap = rewrap;\n    scope.setWrapper = setWrapper;\n    scope.unsafeUnwrap = unsafeUnwrap;\n    scope.unwrap = unwrap;\n    scope.unwrapIfNeeded = unwrapIfNeeded;\n    scope.wrap = wrap;\n    scope.wrapIfNeeded = wrapIfNeeded;\n    scope.wrappers = wrappers;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    function newSplice(index, removed, addedCount) {\n      return {\n        index: index,\n        removed: removed,\n        addedCount: addedCount\n      };\n    }\n    var EDIT_LEAVE = 0;\n    var EDIT_UPDATE = 1;\n    var EDIT_ADD = 2;\n    var EDIT_DELETE = 3;\n    function ArraySplice() {}\n    ArraySplice.prototype = {\n      calcEditDistances: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n        var rowCount = oldEnd - oldStart + 1;\n        var columnCount = currentEnd - currentStart + 1;\n        var distances = new Array(rowCount);\n        for (var i = 0; i < rowCount; i++) {\n          distances[i] = new Array(columnCount);\n          distances[i][0] = i;\n        }\n        for (var j = 0; j < columnCount; j++) distances[0][j] = j;\n        for (var i = 1; i < rowCount; i++) {\n          for (var j = 1; j < columnCount; j++) {\n            if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1]; else {\n              var north = distances[i - 1][j] + 1;\n              var west = distances[i][j - 1] + 1;\n              distances[i][j] = north < west ? north : west;\n            }\n          }\n        }\n        return distances;\n      },\n      spliceOperationsFromEditDistances: function(distances) {\n        var i = distances.length - 1;\n        var j = distances[0].length - 1;\n        var current = distances[i][j];\n        var edits = [];\n        while (i > 0 || j > 0) {\n          if (i == 0) {\n            edits.push(EDIT_ADD);\n            j--;\n            continue;\n          }\n          if (j == 0) {\n            edits.push(EDIT_DELETE);\n            i--;\n            continue;\n          }\n          var northWest = distances[i - 1][j - 1];\n          var west = distances[i - 1][j];\n          var north = distances[i][j - 1];\n          var min;\n          if (west < north) min = west < northWest ? west : northWest; else min = north < northWest ? north : northWest;\n          if (min == northWest) {\n            if (northWest == current) {\n              edits.push(EDIT_LEAVE);\n            } else {\n              edits.push(EDIT_UPDATE);\n              current = northWest;\n            }\n            i--;\n            j--;\n          } else if (min == west) {\n            edits.push(EDIT_DELETE);\n            i--;\n            current = west;\n          } else {\n            edits.push(EDIT_ADD);\n            j--;\n            current = north;\n          }\n        }\n        edits.reverse();\n        return edits;\n      },\n      calcSplices: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n        var prefixCount = 0;\n        var suffixCount = 0;\n        var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n        if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);\n        if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n        currentStart += prefixCount;\n        oldStart += prefixCount;\n        currentEnd -= suffixCount;\n        oldEnd -= suffixCount;\n        if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n        if (currentStart == currentEnd) {\n          var splice = newSplice(currentStart, [], 0);\n          while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);\n          return [ splice ];\n        } else if (oldStart == oldEnd) return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n        var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n        var splice = undefined;\n        var splices = [];\n        var index = currentStart;\n        var oldIndex = oldStart;\n        for (var i = 0; i < ops.length; i++) {\n          switch (ops[i]) {\n           case EDIT_LEAVE:\n            if (splice) {\n              splices.push(splice);\n              splice = undefined;\n            }\n            index++;\n            oldIndex++;\n            break;\n\n           case EDIT_UPDATE:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.addedCount++;\n            index++;\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n\n           case EDIT_ADD:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.addedCount++;\n            index++;\n            break;\n\n           case EDIT_DELETE:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n          }\n        }\n        if (splice) {\n          splices.push(splice);\n        }\n        return splices;\n      },\n      sharedPrefix: function(current, old, searchLength) {\n        for (var i = 0; i < searchLength; i++) if (!this.equals(current[i], old[i])) return i;\n        return searchLength;\n      },\n      sharedSuffix: function(current, old, searchLength) {\n        var index1 = current.length;\n        var index2 = old.length;\n        var count = 0;\n        while (count < searchLength && this.equals(current[--index1], old[--index2])) count++;\n        return count;\n      },\n      calculateSplices: function(current, previous) {\n        return this.calcSplices(current, 0, current.length, previous, 0, previous.length);\n      },\n      equals: function(currentValue, previousValue) {\n        return currentValue === previousValue;\n      }\n    };\n    scope.ArraySplice = ArraySplice;\n  })(window.ShadowDOMPolyfill);\n  (function(context) {\n    \"use strict\";\n    var OriginalMutationObserver = window.MutationObserver;\n    var callbacks = [];\n    var pending = false;\n    var timerFunc;\n    function handle() {\n      pending = false;\n      var copies = callbacks.slice(0);\n      callbacks = [];\n      for (var i = 0; i < copies.length; i++) {\n        (0, copies[i])();\n      }\n    }\n    if (OriginalMutationObserver) {\n      var counter = 1;\n      var observer = new OriginalMutationObserver(handle);\n      var textNode = document.createTextNode(counter);\n      observer.observe(textNode, {\n        characterData: true\n      });\n      timerFunc = function() {\n        counter = (counter + 1) % 2;\n        textNode.data = counter;\n      };\n    } else {\n      timerFunc = window.setTimeout;\n    }\n    function setEndOfMicrotask(func) {\n      callbacks.push(func);\n      if (pending) return;\n      pending = true;\n      timerFunc(handle, 0);\n    }\n    context.setEndOfMicrotask = setEndOfMicrotask;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var setEndOfMicrotask = scope.setEndOfMicrotask;\n    var wrapIfNeeded = scope.wrapIfNeeded;\n    var wrappers = scope.wrappers;\n    var registrationsTable = new WeakMap();\n    var globalMutationObservers = [];\n    var isScheduled = false;\n    function scheduleCallback(observer) {\n      if (observer.scheduled_) return;\n      observer.scheduled_ = true;\n      globalMutationObservers.push(observer);\n      if (isScheduled) return;\n      setEndOfMicrotask(notifyObservers);\n      isScheduled = true;\n    }\n    function notifyObservers() {\n      isScheduled = false;\n      while (globalMutationObservers.length) {\n        var notifyList = globalMutationObservers;\n        globalMutationObservers = [];\n        notifyList.sort(function(x, y) {\n          return x.uid_ - y.uid_;\n        });\n        for (var i = 0; i < notifyList.length; i++) {\n          var mo = notifyList[i];\n          mo.scheduled_ = false;\n          var queue = mo.takeRecords();\n          removeTransientObserversFor(mo);\n          if (queue.length) {\n            mo.callback_(queue, mo);\n          }\n        }\n      }\n    }\n    function MutationRecord(type, target) {\n      this.type = type;\n      this.target = target;\n      this.addedNodes = new wrappers.NodeList();\n      this.removedNodes = new wrappers.NodeList();\n      this.previousSibling = null;\n      this.nextSibling = null;\n      this.attributeName = null;\n      this.attributeNamespace = null;\n      this.oldValue = null;\n    }\n    function registerTransientObservers(ancestor, node) {\n      for (;ancestor; ancestor = ancestor.parentNode) {\n        var registrations = registrationsTable.get(ancestor);\n        if (!registrations) continue;\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.options.subtree) registration.addTransientObserver(node);\n        }\n      }\n    }\n    function removeTransientObserversFor(observer) {\n      for (var i = 0; i < observer.nodes_.length; i++) {\n        var node = observer.nodes_[i];\n        var registrations = registrationsTable.get(node);\n        if (!registrations) return;\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          if (registration.observer === observer) registration.removeTransientObservers();\n        }\n      }\n    }\n    function enqueueMutation(target, type, data) {\n      var interestedObservers = Object.create(null);\n      var associatedStrings = Object.create(null);\n      for (var node = target; node; node = node.parentNode) {\n        var registrations = registrationsTable.get(node);\n        if (!registrations) continue;\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n          if (node !== target && !options.subtree) continue;\n          if (type === \"attributes\" && !options.attributes) continue;\n          if (type === \"attributes\" && options.attributeFilter && (data.namespace !== null || options.attributeFilter.indexOf(data.name) === -1)) {\n            continue;\n          }\n          if (type === \"characterData\" && !options.characterData) continue;\n          if (type === \"childList\" && !options.childList) continue;\n          var observer = registration.observer;\n          interestedObservers[observer.uid_] = observer;\n          if (type === \"attributes\" && options.attributeOldValue || type === \"characterData\" && options.characterDataOldValue) {\n            associatedStrings[observer.uid_] = data.oldValue;\n          }\n        }\n      }\n      for (var uid in interestedObservers) {\n        var observer = interestedObservers[uid];\n        var record = new MutationRecord(type, target);\n        if (\"name\" in data && \"namespace\" in data) {\n          record.attributeName = data.name;\n          record.attributeNamespace = data.namespace;\n        }\n        if (data.addedNodes) record.addedNodes = data.addedNodes;\n        if (data.removedNodes) record.removedNodes = data.removedNodes;\n        if (data.previousSibling) record.previousSibling = data.previousSibling;\n        if (data.nextSibling) record.nextSibling = data.nextSibling;\n        if (associatedStrings[uid] !== undefined) record.oldValue = associatedStrings[uid];\n        scheduleCallback(observer);\n        observer.records_.push(record);\n      }\n    }\n    var slice = Array.prototype.slice;\n    function MutationObserverOptions(options) {\n      this.childList = !!options.childList;\n      this.subtree = !!options.subtree;\n      if (!(\"attributes\" in options) && (\"attributeOldValue\" in options || \"attributeFilter\" in options)) {\n        this.attributes = true;\n      } else {\n        this.attributes = !!options.attributes;\n      }\n      if (\"characterDataOldValue\" in options && !(\"characterData\" in options)) this.characterData = true; else this.characterData = !!options.characterData;\n      if (!this.attributes && (options.attributeOldValue || \"attributeFilter\" in options) || !this.characterData && options.characterDataOldValue) {\n        throw new TypeError();\n      }\n      this.characterData = !!options.characterData;\n      this.attributeOldValue = !!options.attributeOldValue;\n      this.characterDataOldValue = !!options.characterDataOldValue;\n      if (\"attributeFilter\" in options) {\n        if (options.attributeFilter == null || typeof options.attributeFilter !== \"object\") {\n          throw new TypeError();\n        }\n        this.attributeFilter = slice.call(options.attributeFilter);\n      } else {\n        this.attributeFilter = null;\n      }\n    }\n    var uidCounter = 0;\n    function MutationObserver(callback) {\n      this.callback_ = callback;\n      this.nodes_ = [];\n      this.records_ = [];\n      this.uid_ = ++uidCounter;\n      this.scheduled_ = false;\n    }\n    MutationObserver.prototype = {\n      constructor: MutationObserver,\n      observe: function(target, options) {\n        target = wrapIfNeeded(target);\n        var newOptions = new MutationObserverOptions(options);\n        var registration;\n        var registrations = registrationsTable.get(target);\n        if (!registrations) registrationsTable.set(target, registrations = []);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i].observer === this) {\n            registration = registrations[i];\n            registration.removeTransientObservers();\n            registration.options = newOptions;\n          }\n        }\n        if (!registration) {\n          registration = new Registration(this, target, newOptions);\n          registrations.push(registration);\n          this.nodes_.push(target);\n        }\n      },\n      disconnect: function() {\n        this.nodes_.forEach(function(node) {\n          var registrations = registrationsTable.get(node);\n          for (var i = 0; i < registrations.length; i++) {\n            var registration = registrations[i];\n            if (registration.observer === this) {\n              registrations.splice(i, 1);\n              break;\n            }\n          }\n        }, this);\n        this.records_ = [];\n      },\n      takeRecords: function() {\n        var copyOfRecords = this.records_;\n        this.records_ = [];\n        return copyOfRecords;\n      }\n    };\n    function Registration(observer, target, options) {\n      this.observer = observer;\n      this.target = target;\n      this.options = options;\n      this.transientObservedNodes = [];\n    }\n    Registration.prototype = {\n      addTransientObserver: function(node) {\n        if (node === this.target) return;\n        scheduleCallback(this.observer);\n        this.transientObservedNodes.push(node);\n        var registrations = registrationsTable.get(node);\n        if (!registrations) registrationsTable.set(node, registrations = []);\n        registrations.push(this);\n      },\n      removeTransientObservers: function() {\n        var transientObservedNodes = this.transientObservedNodes;\n        this.transientObservedNodes = [];\n        for (var i = 0; i < transientObservedNodes.length; i++) {\n          var node = transientObservedNodes[i];\n          var registrations = registrationsTable.get(node);\n          for (var j = 0; j < registrations.length; j++) {\n            if (registrations[j] === this) {\n              registrations.splice(j, 1);\n              break;\n            }\n          }\n        }\n      }\n    };\n    scope.enqueueMutation = enqueueMutation;\n    scope.registerTransientObservers = registerTransientObservers;\n    scope.wrappers.MutationObserver = MutationObserver;\n    scope.wrappers.MutationRecord = MutationRecord;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    function TreeScope(root, parent) {\n      this.root = root;\n      this.parent = parent;\n    }\n    TreeScope.prototype = {\n      get renderer() {\n        if (this.root instanceof scope.wrappers.ShadowRoot) {\n          return scope.getRendererForHost(this.root.host);\n        }\n        return null;\n      },\n      contains: function(treeScope) {\n        for (;treeScope; treeScope = treeScope.parent) {\n          if (treeScope === this) return true;\n        }\n        return false;\n      }\n    };\n    function setTreeScope(node, treeScope) {\n      if (node.treeScope_ !== treeScope) {\n        node.treeScope_ = treeScope;\n        for (var sr = node.shadowRoot; sr; sr = sr.olderShadowRoot) {\n          sr.treeScope_.parent = treeScope;\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          setTreeScope(child, treeScope);\n        }\n      }\n    }\n    function getTreeScope(node) {\n      if (node instanceof scope.wrappers.Window) {\n        debugger;\n      }\n      if (node.treeScope_) return node.treeScope_;\n      var parent = node.parentNode;\n      var treeScope;\n      if (parent) treeScope = getTreeScope(parent); else treeScope = new TreeScope(node, null);\n      return node.treeScope_ = treeScope;\n    }\n    scope.TreeScope = TreeScope;\n    scope.getTreeScope = getTreeScope;\n    scope.setTreeScope = setTreeScope;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrappers = scope.wrappers;\n    var wrappedFuns = new WeakMap();\n    var listenersTable = new WeakMap();\n    var handledEventsTable = new WeakMap();\n    var currentlyDispatchingEvents = new WeakMap();\n    var targetTable = new WeakMap();\n    var currentTargetTable = new WeakMap();\n    var relatedTargetTable = new WeakMap();\n    var eventPhaseTable = new WeakMap();\n    var stopPropagationTable = new WeakMap();\n    var stopImmediatePropagationTable = new WeakMap();\n    var eventHandlersTable = new WeakMap();\n    var eventPathTable = new WeakMap();\n    function isShadowRoot(node) {\n      return node instanceof wrappers.ShadowRoot;\n    }\n    function rootOfNode(node) {\n      return getTreeScope(node).root;\n    }\n    function getEventPath(node, event) {\n      var path = [];\n      var current = node;\n      path.push(current);\n      while (current) {\n        var destinationInsertionPoints = getDestinationInsertionPoints(current);\n        if (destinationInsertionPoints && destinationInsertionPoints.length > 0) {\n          for (var i = 0; i < destinationInsertionPoints.length; i++) {\n            var insertionPoint = destinationInsertionPoints[i];\n            if (isShadowInsertionPoint(insertionPoint)) {\n              var shadowRoot = rootOfNode(insertionPoint);\n              var olderShadowRoot = shadowRoot.olderShadowRoot;\n              if (olderShadowRoot) path.push(olderShadowRoot);\n            }\n            path.push(insertionPoint);\n          }\n          current = destinationInsertionPoints[destinationInsertionPoints.length - 1];\n        } else {\n          if (isShadowRoot(current)) {\n            if (inSameTree(node, current) && eventMustBeStopped(event)) {\n              break;\n            }\n            current = current.host;\n            path.push(current);\n          } else {\n            current = current.parentNode;\n            if (current) path.push(current);\n          }\n        }\n      }\n      return path;\n    }\n    function eventMustBeStopped(event) {\n      if (!event) return false;\n      switch (event.type) {\n       case \"abort\":\n       case \"error\":\n       case \"select\":\n       case \"change\":\n       case \"load\":\n       case \"reset\":\n       case \"resize\":\n       case \"scroll\":\n       case \"selectstart\":\n        return true;\n      }\n      return false;\n    }\n    function isShadowInsertionPoint(node) {\n      return node instanceof HTMLShadowElement;\n    }\n    function getDestinationInsertionPoints(node) {\n      return scope.getDestinationInsertionPoints(node);\n    }\n    function eventRetargetting(path, currentTarget) {\n      if (path.length === 0) return currentTarget;\n      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\n      var currentTargetTree = getTreeScope(currentTarget);\n      var originalTarget = path[0];\n      var originalTargetTree = getTreeScope(originalTarget);\n      var relativeTargetTree = lowestCommonInclusiveAncestor(currentTargetTree, originalTargetTree);\n      for (var i = 0; i < path.length; i++) {\n        var node = path[i];\n        if (getTreeScope(node) === relativeTargetTree) return node;\n      }\n      return path[path.length - 1];\n    }\n    function getTreeScopeAncestors(treeScope) {\n      var ancestors = [];\n      for (;treeScope; treeScope = treeScope.parent) {\n        ancestors.push(treeScope);\n      }\n      return ancestors;\n    }\n    function lowestCommonInclusiveAncestor(tsA, tsB) {\n      var ancestorsA = getTreeScopeAncestors(tsA);\n      var ancestorsB = getTreeScopeAncestors(tsB);\n      var result = null;\n      while (ancestorsA.length > 0 && ancestorsB.length > 0) {\n        var a = ancestorsA.pop();\n        var b = ancestorsB.pop();\n        if (a === b) result = a; else break;\n      }\n      return result;\n    }\n    function getTreeScopeRoot(ts) {\n      if (!ts.parent) return ts;\n      return getTreeScopeRoot(ts.parent);\n    }\n    function relatedTargetResolution(event, currentTarget, relatedTarget) {\n      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\n      var currentTargetTree = getTreeScope(currentTarget);\n      var relatedTargetTree = getTreeScope(relatedTarget);\n      var relatedTargetEventPath = getEventPath(relatedTarget, event);\n      var lowestCommonAncestorTree;\n      var lowestCommonAncestorTree = lowestCommonInclusiveAncestor(currentTargetTree, relatedTargetTree);\n      if (!lowestCommonAncestorTree) lowestCommonAncestorTree = relatedTargetTree.root;\n      for (var commonAncestorTree = lowestCommonAncestorTree; commonAncestorTree; commonAncestorTree = commonAncestorTree.parent) {\n        var adjustedRelatedTarget;\n        for (var i = 0; i < relatedTargetEventPath.length; i++) {\n          var node = relatedTargetEventPath[i];\n          if (getTreeScope(node) === commonAncestorTree) return node;\n        }\n      }\n      return null;\n    }\n    function inSameTree(a, b) {\n      return getTreeScope(a) === getTreeScope(b);\n    }\n    var NONE = 0;\n    var CAPTURING_PHASE = 1;\n    var AT_TARGET = 2;\n    var BUBBLING_PHASE = 3;\n    var pendingError;\n    function dispatchOriginalEvent(originalEvent) {\n      if (handledEventsTable.get(originalEvent)) return;\n      handledEventsTable.set(originalEvent, true);\n      dispatchEvent(wrap(originalEvent), wrap(originalEvent.target));\n      if (pendingError) {\n        var err = pendingError;\n        pendingError = null;\n        throw err;\n      }\n    }\n    function isLoadLikeEvent(event) {\n      switch (event.type) {\n       case \"load\":\n       case \"beforeunload\":\n       case \"unload\":\n        return true;\n      }\n      return false;\n    }\n    function dispatchEvent(event, originalWrapperTarget) {\n      if (currentlyDispatchingEvents.get(event)) throw new Error(\"InvalidStateError\");\n      currentlyDispatchingEvents.set(event, true);\n      scope.renderAllPending();\n      var eventPath;\n      var overrideTarget;\n      var win;\n      if (isLoadLikeEvent(event) && !event.bubbles) {\n        var doc = originalWrapperTarget;\n        if (doc instanceof wrappers.Document && (win = doc.defaultView)) {\n          overrideTarget = doc;\n          eventPath = [];\n        }\n      }\n      if (!eventPath) {\n        if (originalWrapperTarget instanceof wrappers.Window) {\n          win = originalWrapperTarget;\n          eventPath = [];\n        } else {\n          eventPath = getEventPath(originalWrapperTarget, event);\n          if (!isLoadLikeEvent(event)) {\n            var doc = eventPath[eventPath.length - 1];\n            if (doc instanceof wrappers.Document) win = doc.defaultView;\n          }\n        }\n      }\n      eventPathTable.set(event, eventPath);\n      if (dispatchCapturing(event, eventPath, win, overrideTarget)) {\n        if (dispatchAtTarget(event, eventPath, win, overrideTarget)) {\n          dispatchBubbling(event, eventPath, win, overrideTarget);\n        }\n      }\n      eventPhaseTable.set(event, NONE);\n      currentTargetTable.delete(event, null);\n      currentlyDispatchingEvents.delete(event);\n      return event.defaultPrevented;\n    }\n    function dispatchCapturing(event, eventPath, win, overrideTarget) {\n      var phase = CAPTURING_PHASE;\n      if (win) {\n        if (!invoke(win, event, phase, eventPath, overrideTarget)) return false;\n      }\n      for (var i = eventPath.length - 1; i > 0; i--) {\n        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return false;\n      }\n      return true;\n    }\n    function dispatchAtTarget(event, eventPath, win, overrideTarget) {\n      var phase = AT_TARGET;\n      var currentTarget = eventPath[0] || win;\n      return invoke(currentTarget, event, phase, eventPath, overrideTarget);\n    }\n    function dispatchBubbling(event, eventPath, win, overrideTarget) {\n      var phase = BUBBLING_PHASE;\n      for (var i = 1; i < eventPath.length; i++) {\n        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return;\n      }\n      if (win && eventPath.length > 0) {\n        invoke(win, event, phase, eventPath, overrideTarget);\n      }\n    }\n    function invoke(currentTarget, event, phase, eventPath, overrideTarget) {\n      var listeners = listenersTable.get(currentTarget);\n      if (!listeners) return true;\n      var target = overrideTarget || eventRetargetting(eventPath, currentTarget);\n      if (target === currentTarget) {\n        if (phase === CAPTURING_PHASE) return true;\n        if (phase === BUBBLING_PHASE) phase = AT_TARGET;\n      } else if (phase === BUBBLING_PHASE && !event.bubbles) {\n        return true;\n      }\n      if (\"relatedTarget\" in event) {\n        var originalEvent = unwrap(event);\n        var unwrappedRelatedTarget = originalEvent.relatedTarget;\n        if (unwrappedRelatedTarget) {\n          if (unwrappedRelatedTarget instanceof Object && unwrappedRelatedTarget.addEventListener) {\n            var relatedTarget = wrap(unwrappedRelatedTarget);\n            var adjusted = relatedTargetResolution(event, currentTarget, relatedTarget);\n            if (adjusted === target) return true;\n          } else {\n            adjusted = null;\n          }\n          relatedTargetTable.set(event, adjusted);\n        }\n      }\n      eventPhaseTable.set(event, phase);\n      var type = event.type;\n      var anyRemoved = false;\n      targetTable.set(event, target);\n      currentTargetTable.set(event, currentTarget);\n      listeners.depth++;\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        var listener = listeners[i];\n        if (listener.removed) {\n          anyRemoved = true;\n          continue;\n        }\n        if (listener.type !== type || !listener.capture && phase === CAPTURING_PHASE || listener.capture && phase === BUBBLING_PHASE) {\n          continue;\n        }\n        try {\n          if (typeof listener.handler === \"function\") listener.handler.call(currentTarget, event); else listener.handler.handleEvent(event);\n          if (stopImmediatePropagationTable.get(event)) return false;\n        } catch (ex) {\n          if (!pendingError) pendingError = ex;\n        }\n      }\n      listeners.depth--;\n      if (anyRemoved && listeners.depth === 0) {\n        var copy = listeners.slice();\n        listeners.length = 0;\n        for (var i = 0; i < copy.length; i++) {\n          if (!copy[i].removed) listeners.push(copy[i]);\n        }\n      }\n      return !stopPropagationTable.get(event);\n    }\n    function Listener(type, handler, capture) {\n      this.type = type;\n      this.handler = handler;\n      this.capture = Boolean(capture);\n    }\n    Listener.prototype = {\n      equals: function(that) {\n        return this.handler === that.handler && this.type === that.type && this.capture === that.capture;\n      },\n      get removed() {\n        return this.handler === null;\n      },\n      remove: function() {\n        this.handler = null;\n      }\n    };\n    var OriginalEvent = window.Event;\n    OriginalEvent.prototype.polymerBlackList_ = {\n      returnValue: true,\n      keyLocation: true\n    };\n    function Event(type, options) {\n      if (type instanceof OriginalEvent) {\n        var impl = type;\n        if (!OriginalBeforeUnloadEvent && impl.type === \"beforeunload\" && !(this instanceof BeforeUnloadEvent)) {\n          return new BeforeUnloadEvent(impl);\n        }\n        setWrapper(impl, this);\n      } else {\n        return wrap(constructEvent(OriginalEvent, \"Event\", type, options));\n      }\n    }\n    Event.prototype = {\n      get target() {\n        return targetTable.get(this);\n      },\n      get currentTarget() {\n        return currentTargetTable.get(this);\n      },\n      get eventPhase() {\n        return eventPhaseTable.get(this);\n      },\n      get path() {\n        var eventPath = eventPathTable.get(this);\n        if (!eventPath) return [];\n        return eventPath.slice();\n      },\n      stopPropagation: function() {\n        stopPropagationTable.set(this, true);\n      },\n      stopImmediatePropagation: function() {\n        stopPropagationTable.set(this, true);\n        stopImmediatePropagationTable.set(this, true);\n      }\n    };\n    var supportsDefaultPrevented = function() {\n      var e = document.createEvent(\"Event\");\n      e.initEvent(\"test\", true, true);\n      e.preventDefault();\n      return e.defaultPrevented;\n    }();\n    if (!supportsDefaultPrevented) {\n      Event.prototype.preventDefault = function() {\n        if (!this.cancelable) return;\n        unsafeUnwrap(this).preventDefault();\n        Object.defineProperty(this, \"defaultPrevented\", {\n          get: function() {\n            return true;\n          },\n          configurable: true\n        });\n      };\n    }\n    registerWrapper(OriginalEvent, Event, document.createEvent(\"Event\"));\n    function unwrapOptions(options) {\n      if (!options || !options.relatedTarget) return options;\n      return Object.create(options, {\n        relatedTarget: {\n          value: unwrap(options.relatedTarget)\n        }\n      });\n    }\n    function registerGenericEvent(name, SuperEvent, prototype) {\n      var OriginalEvent = window[name];\n      var GenericEvent = function(type, options) {\n        if (type instanceof OriginalEvent) setWrapper(type, this); else return wrap(constructEvent(OriginalEvent, name, type, options));\n      };\n      GenericEvent.prototype = Object.create(SuperEvent.prototype);\n      if (prototype) mixin(GenericEvent.prototype, prototype);\n      if (OriginalEvent) {\n        try {\n          registerWrapper(OriginalEvent, GenericEvent, new OriginalEvent(\"temp\"));\n        } catch (ex) {\n          registerWrapper(OriginalEvent, GenericEvent, document.createEvent(name));\n        }\n      }\n      return GenericEvent;\n    }\n    var UIEvent = registerGenericEvent(\"UIEvent\", Event);\n    var CustomEvent = registerGenericEvent(\"CustomEvent\", Event);\n    var relatedTargetProto = {\n      get relatedTarget() {\n        var relatedTarget = relatedTargetTable.get(this);\n        if (relatedTarget !== undefined) return relatedTarget;\n        return wrap(unwrap(this).relatedTarget);\n      }\n    };\n    function getInitFunction(name, relatedTargetIndex) {\n      return function() {\n        arguments[relatedTargetIndex] = unwrap(arguments[relatedTargetIndex]);\n        var impl = unwrap(this);\n        impl[name].apply(impl, arguments);\n      };\n    }\n    var mouseEventProto = mixin({\n      initMouseEvent: getInitFunction(\"initMouseEvent\", 14)\n    }, relatedTargetProto);\n    var focusEventProto = mixin({\n      initFocusEvent: getInitFunction(\"initFocusEvent\", 5)\n    }, relatedTargetProto);\n    var MouseEvent = registerGenericEvent(\"MouseEvent\", UIEvent, mouseEventProto);\n    var FocusEvent = registerGenericEvent(\"FocusEvent\", UIEvent, focusEventProto);\n    var defaultInitDicts = Object.create(null);\n    var supportsEventConstructors = function() {\n      try {\n        new window.FocusEvent(\"focus\");\n      } catch (ex) {\n        return false;\n      }\n      return true;\n    }();\n    function constructEvent(OriginalEvent, name, type, options) {\n      if (supportsEventConstructors) return new OriginalEvent(type, unwrapOptions(options));\n      var event = unwrap(document.createEvent(name));\n      var defaultDict = defaultInitDicts[name];\n      var args = [ type ];\n      Object.keys(defaultDict).forEach(function(key) {\n        var v = options != null && key in options ? options[key] : defaultDict[key];\n        if (key === \"relatedTarget\") v = unwrap(v);\n        args.push(v);\n      });\n      event[\"init\" + name].apply(event, args);\n      return event;\n    }\n    if (!supportsEventConstructors) {\n      var configureEventConstructor = function(name, initDict, superName) {\n        if (superName) {\n          var superDict = defaultInitDicts[superName];\n          initDict = mixin(mixin({}, superDict), initDict);\n        }\n        defaultInitDicts[name] = initDict;\n      };\n      configureEventConstructor(\"Event\", {\n        bubbles: false,\n        cancelable: false\n      });\n      configureEventConstructor(\"CustomEvent\", {\n        detail: null\n      }, \"Event\");\n      configureEventConstructor(\"UIEvent\", {\n        view: null,\n        detail: 0\n      }, \"Event\");\n      configureEventConstructor(\"MouseEvent\", {\n        screenX: 0,\n        screenY: 0,\n        clientX: 0,\n        clientY: 0,\n        ctrlKey: false,\n        altKey: false,\n        shiftKey: false,\n        metaKey: false,\n        button: 0,\n        relatedTarget: null\n      }, \"UIEvent\");\n      configureEventConstructor(\"FocusEvent\", {\n        relatedTarget: null\n      }, \"UIEvent\");\n    }\n    var OriginalBeforeUnloadEvent = window.BeforeUnloadEvent;\n    function BeforeUnloadEvent(impl) {\n      Event.call(this, impl);\n    }\n    BeforeUnloadEvent.prototype = Object.create(Event.prototype);\n    mixin(BeforeUnloadEvent.prototype, {\n      get returnValue() {\n        return unsafeUnwrap(this).returnValue;\n      },\n      set returnValue(v) {\n        unsafeUnwrap(this).returnValue = v;\n      }\n    });\n    if (OriginalBeforeUnloadEvent) registerWrapper(OriginalBeforeUnloadEvent, BeforeUnloadEvent);\n    function isValidListener(fun) {\n      if (typeof fun === \"function\") return true;\n      return fun && fun.handleEvent;\n    }\n    function isMutationEvent(type) {\n      switch (type) {\n       case \"DOMAttrModified\":\n       case \"DOMAttributeNameChanged\":\n       case \"DOMCharacterDataModified\":\n       case \"DOMElementNameChanged\":\n       case \"DOMNodeInserted\":\n       case \"DOMNodeInsertedIntoDocument\":\n       case \"DOMNodeRemoved\":\n       case \"DOMNodeRemovedFromDocument\":\n       case \"DOMSubtreeModified\":\n        return true;\n      }\n      return false;\n    }\n    var OriginalEventTarget = window.EventTarget;\n    function EventTarget(impl) {\n      setWrapper(impl, this);\n    }\n    var methodNames = [ \"addEventListener\", \"removeEventListener\", \"dispatchEvent\" ];\n    [ Node, Window ].forEach(function(constructor) {\n      var p = constructor.prototype;\n      methodNames.forEach(function(name) {\n        Object.defineProperty(p, name + \"_\", {\n          value: p[name]\n        });\n      });\n    });\n    function getTargetToListenAt(wrapper) {\n      if (wrapper instanceof wrappers.ShadowRoot) wrapper = wrapper.host;\n      return unwrap(wrapper);\n    }\n    EventTarget.prototype = {\n      addEventListener: function(type, fun, capture) {\n        if (!isValidListener(fun) || isMutationEvent(type)) return;\n        var listener = new Listener(type, fun, capture);\n        var listeners = listenersTable.get(this);\n        if (!listeners) {\n          listeners = [];\n          listeners.depth = 0;\n          listenersTable.set(this, listeners);\n        } else {\n          for (var i = 0; i < listeners.length; i++) {\n            if (listener.equals(listeners[i])) return;\n          }\n        }\n        listeners.push(listener);\n        var target = getTargetToListenAt(this);\n        target.addEventListener_(type, dispatchOriginalEvent, true);\n      },\n      removeEventListener: function(type, fun, capture) {\n        capture = Boolean(capture);\n        var listeners = listenersTable.get(this);\n        if (!listeners) return;\n        var count = 0, found = false;\n        for (var i = 0; i < listeners.length; i++) {\n          if (listeners[i].type === type && listeners[i].capture === capture) {\n            count++;\n            if (listeners[i].handler === fun) {\n              found = true;\n              listeners[i].remove();\n            }\n          }\n        }\n        if (found && count === 1) {\n          var target = getTargetToListenAt(this);\n          target.removeEventListener_(type, dispatchOriginalEvent, true);\n        }\n      },\n      dispatchEvent: function(event) {\n        var nativeEvent = unwrap(event);\n        var eventType = nativeEvent.type;\n        handledEventsTable.set(nativeEvent, false);\n        scope.renderAllPending();\n        var tempListener;\n        if (!hasListenerInAncestors(this, eventType)) {\n          tempListener = function() {};\n          this.addEventListener(eventType, tempListener, true);\n        }\n        try {\n          return unwrap(this).dispatchEvent_(nativeEvent);\n        } finally {\n          if (tempListener) this.removeEventListener(eventType, tempListener, true);\n        }\n      }\n    };\n    function hasListener(node, type) {\n      var listeners = listenersTable.get(node);\n      if (listeners) {\n        for (var i = 0; i < listeners.length; i++) {\n          if (!listeners[i].removed && listeners[i].type === type) return true;\n        }\n      }\n      return false;\n    }\n    function hasListenerInAncestors(target, type) {\n      for (var node = unwrap(target); node; node = node.parentNode) {\n        if (hasListener(wrap(node), type)) return true;\n      }\n      return false;\n    }\n    if (OriginalEventTarget) registerWrapper(OriginalEventTarget, EventTarget);\n    function wrapEventTargetMethods(constructors) {\n      forwardMethodsToWrapper(constructors, methodNames);\n    }\n    var originalElementFromPoint = document.elementFromPoint;\n    function elementFromPoint(self, document, x, y) {\n      scope.renderAllPending();\n      var element = wrap(originalElementFromPoint.call(unsafeUnwrap(document), x, y));\n      if (!element) return null;\n      var path = getEventPath(element, null);\n      var idx = path.lastIndexOf(self);\n      if (idx == -1) return null; else path = path.slice(0, idx);\n      return eventRetargetting(path, self);\n    }\n    function getEventHandlerGetter(name) {\n      return function() {\n        var inlineEventHandlers = eventHandlersTable.get(this);\n        return inlineEventHandlers && inlineEventHandlers[name] && inlineEventHandlers[name].value || null;\n      };\n    }\n    function getEventHandlerSetter(name) {\n      var eventType = name.slice(2);\n      return function(value) {\n        var inlineEventHandlers = eventHandlersTable.get(this);\n        if (!inlineEventHandlers) {\n          inlineEventHandlers = Object.create(null);\n          eventHandlersTable.set(this, inlineEventHandlers);\n        }\n        var old = inlineEventHandlers[name];\n        if (old) this.removeEventListener(eventType, old.wrapped, false);\n        if (typeof value === \"function\") {\n          var wrapped = function(e) {\n            var rv = value.call(this, e);\n            if (rv === false) e.preventDefault(); else if (name === \"onbeforeunload\" && typeof rv === \"string\") e.returnValue = rv;\n          };\n          this.addEventListener(eventType, wrapped, false);\n          inlineEventHandlers[name] = {\n            value: value,\n            wrapped: wrapped\n          };\n        }\n      };\n    }\n    scope.elementFromPoint = elementFromPoint;\n    scope.getEventHandlerGetter = getEventHandlerGetter;\n    scope.getEventHandlerSetter = getEventHandlerSetter;\n    scope.wrapEventTargetMethods = wrapEventTargetMethods;\n    scope.wrappers.BeforeUnloadEvent = BeforeUnloadEvent;\n    scope.wrappers.CustomEvent = CustomEvent;\n    scope.wrappers.Event = Event;\n    scope.wrappers.EventTarget = EventTarget;\n    scope.wrappers.FocusEvent = FocusEvent;\n    scope.wrappers.MouseEvent = MouseEvent;\n    scope.wrappers.UIEvent = UIEvent;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var UIEvent = scope.wrappers.UIEvent;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalTouchEvent = window.TouchEvent;\n    if (!OriginalTouchEvent) return;\n    var nativeEvent;\n    try {\n      nativeEvent = document.createEvent(\"TouchEvent\");\n    } catch (ex) {\n      return;\n    }\n    var nonEnumDescriptor = {\n      enumerable: false\n    };\n    function nonEnum(obj, prop) {\n      Object.defineProperty(obj, prop, nonEnumDescriptor);\n    }\n    function Touch(impl) {\n      setWrapper(impl, this);\n    }\n    Touch.prototype = {\n      get target() {\n        return wrap(unsafeUnwrap(this).target);\n      }\n    };\n    var descr = {\n      configurable: true,\n      enumerable: true,\n      get: null\n    };\n    [ \"clientX\", \"clientY\", \"screenX\", \"screenY\", \"pageX\", \"pageY\", \"identifier\", \"webkitRadiusX\", \"webkitRadiusY\", \"webkitRotationAngle\", \"webkitForce\" ].forEach(function(name) {\n      descr.get = function() {\n        return unsafeUnwrap(this)[name];\n      };\n      Object.defineProperty(Touch.prototype, name, descr);\n    });\n    function TouchList() {\n      this.length = 0;\n      nonEnum(this, \"length\");\n    }\n    TouchList.prototype = {\n      item: function(index) {\n        return this[index];\n      }\n    };\n    function wrapTouchList(nativeTouchList) {\n      var list = new TouchList();\n      for (var i = 0; i < nativeTouchList.length; i++) {\n        list[i] = new Touch(nativeTouchList[i]);\n      }\n      list.length = i;\n      return list;\n    }\n    function TouchEvent(impl) {\n      UIEvent.call(this, impl);\n    }\n    TouchEvent.prototype = Object.create(UIEvent.prototype);\n    mixin(TouchEvent.prototype, {\n      get touches() {\n        return wrapTouchList(unsafeUnwrap(this).touches);\n      },\n      get targetTouches() {\n        return wrapTouchList(unsafeUnwrap(this).targetTouches);\n      },\n      get changedTouches() {\n        return wrapTouchList(unsafeUnwrap(this).changedTouches);\n      },\n      initTouchEvent: function() {\n        throw new Error(\"Not implemented\");\n      }\n    });\n    registerWrapper(OriginalTouchEvent, TouchEvent, nativeEvent);\n    scope.wrappers.Touch = Touch;\n    scope.wrappers.TouchEvent = TouchEvent;\n    scope.wrappers.TouchList = TouchList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var nonEnumDescriptor = {\n      enumerable: false\n    };\n    function nonEnum(obj, prop) {\n      Object.defineProperty(obj, prop, nonEnumDescriptor);\n    }\n    function NodeList() {\n      this.length = 0;\n      nonEnum(this, \"length\");\n    }\n    NodeList.prototype = {\n      item: function(index) {\n        return this[index];\n      }\n    };\n    nonEnum(NodeList.prototype, \"item\");\n    function wrapNodeList(list) {\n      if (list == null) return list;\n      var wrapperList = new NodeList();\n      for (var i = 0, length = list.length; i < length; i++) {\n        wrapperList[i] = wrap(list[i]);\n      }\n      wrapperList.length = length;\n      return wrapperList;\n    }\n    function addWrapNodeListMethod(wrapperConstructor, name) {\n      wrapperConstructor.prototype[name] = function() {\n        return wrapNodeList(unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    scope.wrappers.NodeList = NodeList;\n    scope.addWrapNodeListMethod = addWrapNodeListMethod;\n    scope.wrapNodeList = wrapNodeList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    scope.wrapHTMLCollection = scope.wrapNodeList;\n    scope.wrappers.HTMLCollection = scope.wrappers.NodeList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var EventTarget = scope.wrappers.EventTarget;\n    var NodeList = scope.wrappers.NodeList;\n    var TreeScope = scope.TreeScope;\n    var assert = scope.assert;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var enqueueMutation = scope.enqueueMutation;\n    var getTreeScope = scope.getTreeScope;\n    var isWrapper = scope.isWrapper;\n    var mixin = scope.mixin;\n    var registerTransientObservers = scope.registerTransientObservers;\n    var registerWrapper = scope.registerWrapper;\n    var setTreeScope = scope.setTreeScope;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var wrapIfNeeded = scope.wrapIfNeeded;\n    var wrappers = scope.wrappers;\n    function assertIsNodeWrapper(node) {\n      assert(node instanceof Node);\n    }\n    function createOneElementNodeList(node) {\n      var nodes = new NodeList();\n      nodes[0] = node;\n      nodes.length = 1;\n      return nodes;\n    }\n    var surpressMutations = false;\n    function enqueueRemovalForInsertedNodes(node, parent, nodes) {\n      enqueueMutation(parent, \"childList\", {\n        removedNodes: nodes,\n        previousSibling: node.previousSibling,\n        nextSibling: node.nextSibling\n      });\n    }\n    function enqueueRemovalForInsertedDocumentFragment(df, nodes) {\n      enqueueMutation(df, \"childList\", {\n        removedNodes: nodes\n      });\n    }\n    function collectNodes(node, parentNode, previousNode, nextNode) {\n      if (node instanceof DocumentFragment) {\n        var nodes = collectNodesForDocumentFragment(node);\n        surpressMutations = true;\n        for (var i = nodes.length - 1; i >= 0; i--) {\n          node.removeChild(nodes[i]);\n          nodes[i].parentNode_ = parentNode;\n        }\n        surpressMutations = false;\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].previousSibling_ = nodes[i - 1] || previousNode;\n          nodes[i].nextSibling_ = nodes[i + 1] || nextNode;\n        }\n        if (previousNode) previousNode.nextSibling_ = nodes[0];\n        if (nextNode) nextNode.previousSibling_ = nodes[nodes.length - 1];\n        return nodes;\n      }\n      var nodes = createOneElementNodeList(node);\n      var oldParent = node.parentNode;\n      if (oldParent) {\n        oldParent.removeChild(node);\n      }\n      node.parentNode_ = parentNode;\n      node.previousSibling_ = previousNode;\n      node.nextSibling_ = nextNode;\n      if (previousNode) previousNode.nextSibling_ = node;\n      if (nextNode) nextNode.previousSibling_ = node;\n      return nodes;\n    }\n    function collectNodesNative(node) {\n      if (node instanceof DocumentFragment) return collectNodesForDocumentFragment(node);\n      var nodes = createOneElementNodeList(node);\n      var oldParent = node.parentNode;\n      if (oldParent) enqueueRemovalForInsertedNodes(node, oldParent, nodes);\n      return nodes;\n    }\n    function collectNodesForDocumentFragment(node) {\n      var nodes = new NodeList();\n      var i = 0;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        nodes[i++] = child;\n      }\n      nodes.length = i;\n      enqueueRemovalForInsertedDocumentFragment(node, nodes);\n      return nodes;\n    }\n    function snapshotNodeList(nodeList) {\n      return nodeList;\n    }\n    function nodeWasAdded(node, treeScope) {\n      setTreeScope(node, treeScope);\n      node.nodeIsInserted_();\n    }\n    function nodesWereAdded(nodes, parent) {\n      var treeScope = getTreeScope(parent);\n      for (var i = 0; i < nodes.length; i++) {\n        nodeWasAdded(nodes[i], treeScope);\n      }\n    }\n    function nodeWasRemoved(node) {\n      setTreeScope(node, new TreeScope(node, null));\n    }\n    function nodesWereRemoved(nodes) {\n      for (var i = 0; i < nodes.length; i++) {\n        nodeWasRemoved(nodes[i]);\n      }\n    }\n    function ensureSameOwnerDocument(parent, child) {\n      var ownerDoc = parent.nodeType === Node.DOCUMENT_NODE ? parent : parent.ownerDocument;\n      if (ownerDoc !== child.ownerDocument) ownerDoc.adoptNode(child);\n    }\n    function adoptNodesIfNeeded(owner, nodes) {\n      if (!nodes.length) return;\n      var ownerDoc = owner.ownerDocument;\n      if (ownerDoc === nodes[0].ownerDocument) return;\n      for (var i = 0; i < nodes.length; i++) {\n        scope.adoptNodeNoRemove(nodes[i], ownerDoc);\n      }\n    }\n    function unwrapNodesForInsertion(owner, nodes) {\n      adoptNodesIfNeeded(owner, nodes);\n      var length = nodes.length;\n      if (length === 1) return unwrap(nodes[0]);\n      var df = unwrap(owner.ownerDocument.createDocumentFragment());\n      for (var i = 0; i < length; i++) {\n        df.appendChild(unwrap(nodes[i]));\n      }\n      return df;\n    }\n    function clearChildNodes(wrapper) {\n      if (wrapper.firstChild_ !== undefined) {\n        var child = wrapper.firstChild_;\n        while (child) {\n          var tmp = child;\n          child = child.nextSibling_;\n          tmp.parentNode_ = tmp.previousSibling_ = tmp.nextSibling_ = undefined;\n        }\n      }\n      wrapper.firstChild_ = wrapper.lastChild_ = undefined;\n    }\n    function removeAllChildNodes(wrapper) {\n      if (wrapper.invalidateShadowRenderer()) {\n        var childWrapper = wrapper.firstChild;\n        while (childWrapper) {\n          assert(childWrapper.parentNode === wrapper);\n          var nextSibling = childWrapper.nextSibling;\n          var childNode = unwrap(childWrapper);\n          var parentNode = childNode.parentNode;\n          if (parentNode) originalRemoveChild.call(parentNode, childNode);\n          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;\n          childWrapper = nextSibling;\n        }\n        wrapper.firstChild_ = wrapper.lastChild_ = null;\n      } else {\n        var node = unwrap(wrapper);\n        var child = node.firstChild;\n        var nextSibling;\n        while (child) {\n          nextSibling = child.nextSibling;\n          originalRemoveChild.call(node, child);\n          child = nextSibling;\n        }\n      }\n    }\n    function invalidateParent(node) {\n      var p = node.parentNode;\n      return p && p.invalidateShadowRenderer();\n    }\n    function cleanupNodes(nodes) {\n      for (var i = 0, n; i < nodes.length; i++) {\n        n = nodes[i];\n        n.parentNode.removeChild(n);\n      }\n    }\n    var originalImportNode = document.importNode;\n    var originalCloneNode = window.Node.prototype.cloneNode;\n    function cloneNode(node, deep, opt_doc) {\n      var clone;\n      if (opt_doc) clone = wrap(originalImportNode.call(opt_doc, unsafeUnwrap(node), false)); else clone = wrap(originalCloneNode.call(unsafeUnwrap(node), false));\n      if (deep) {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          clone.appendChild(cloneNode(child, true, opt_doc));\n        }\n        if (node instanceof wrappers.HTMLTemplateElement) {\n          var cloneContent = clone.content;\n          for (var child = node.content.firstChild; child; child = child.nextSibling) {\n            cloneContent.appendChild(cloneNode(child, true, opt_doc));\n          }\n        }\n      }\n      return clone;\n    }\n    function contains(self, child) {\n      if (!child || getTreeScope(self) !== getTreeScope(child)) return false;\n      for (var node = child; node; node = node.parentNode) {\n        if (node === self) return true;\n      }\n      return false;\n    }\n    var OriginalNode = window.Node;\n    function Node(original) {\n      assert(original instanceof OriginalNode);\n      EventTarget.call(this, original);\n      this.parentNode_ = undefined;\n      this.firstChild_ = undefined;\n      this.lastChild_ = undefined;\n      this.nextSibling_ = undefined;\n      this.previousSibling_ = undefined;\n      this.treeScope_ = undefined;\n    }\n    var OriginalDocumentFragment = window.DocumentFragment;\n    var originalAppendChild = OriginalNode.prototype.appendChild;\n    var originalCompareDocumentPosition = OriginalNode.prototype.compareDocumentPosition;\n    var originalIsEqualNode = OriginalNode.prototype.isEqualNode;\n    var originalInsertBefore = OriginalNode.prototype.insertBefore;\n    var originalRemoveChild = OriginalNode.prototype.removeChild;\n    var originalReplaceChild = OriginalNode.prototype.replaceChild;\n    var isIEOrEdge = /Trident|Edge/.test(navigator.userAgent);\n    var removeChildOriginalHelper = isIEOrEdge ? function(parent, child) {\n      try {\n        originalRemoveChild.call(parent, child);\n      } catch (ex) {\n        if (!(parent instanceof OriginalDocumentFragment)) throw ex;\n      }\n    } : function(parent, child) {\n      originalRemoveChild.call(parent, child);\n    };\n    Node.prototype = Object.create(EventTarget.prototype);\n    mixin(Node.prototype, {\n      appendChild: function(childWrapper) {\n        return this.insertBefore(childWrapper, null);\n      },\n      insertBefore: function(childWrapper, refWrapper) {\n        assertIsNodeWrapper(childWrapper);\n        var refNode;\n        if (refWrapper) {\n          if (isWrapper(refWrapper)) {\n            refNode = unwrap(refWrapper);\n          } else {\n            refNode = refWrapper;\n            refWrapper = wrap(refNode);\n          }\n        } else {\n          refWrapper = null;\n          refNode = null;\n        }\n        refWrapper && assert(refWrapper.parentNode === this);\n        var nodes;\n        var previousNode = refWrapper ? refWrapper.previousSibling : this.lastChild;\n        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(childWrapper);\n        if (useNative) nodes = collectNodesNative(childWrapper); else nodes = collectNodes(childWrapper, this, previousNode, refWrapper);\n        if (useNative) {\n          ensureSameOwnerDocument(this, childWrapper);\n          clearChildNodes(this);\n          originalInsertBefore.call(unsafeUnwrap(this), unwrap(childWrapper), refNode);\n        } else {\n          if (!previousNode) this.firstChild_ = nodes[0];\n          if (!refWrapper) {\n            this.lastChild_ = nodes[nodes.length - 1];\n            if (this.firstChild_ === undefined) this.firstChild_ = this.firstChild;\n          }\n          var parentNode = refNode ? refNode.parentNode : unsafeUnwrap(this);\n          if (parentNode) {\n            originalInsertBefore.call(parentNode, unwrapNodesForInsertion(this, nodes), refNode);\n          } else {\n            adoptNodesIfNeeded(this, nodes);\n          }\n        }\n        enqueueMutation(this, \"childList\", {\n          addedNodes: nodes,\n          nextSibling: refWrapper,\n          previousSibling: previousNode\n        });\n        nodesWereAdded(nodes, this);\n        return childWrapper;\n      },\n      removeChild: function(childWrapper) {\n        assertIsNodeWrapper(childWrapper);\n        if (childWrapper.parentNode !== this) {\n          var found = false;\n          var childNodes = this.childNodes;\n          for (var ieChild = this.firstChild; ieChild; ieChild = ieChild.nextSibling) {\n            if (ieChild === childWrapper) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new Error(\"NotFoundError\");\n          }\n        }\n        var childNode = unwrap(childWrapper);\n        var childWrapperNextSibling = childWrapper.nextSibling;\n        var childWrapperPreviousSibling = childWrapper.previousSibling;\n        if (this.invalidateShadowRenderer()) {\n          var thisFirstChild = this.firstChild;\n          var thisLastChild = this.lastChild;\n          var parentNode = childNode.parentNode;\n          if (parentNode) removeChildOriginalHelper(parentNode, childNode);\n          if (thisFirstChild === childWrapper) this.firstChild_ = childWrapperNextSibling;\n          if (thisLastChild === childWrapper) this.lastChild_ = childWrapperPreviousSibling;\n          if (childWrapperPreviousSibling) childWrapperPreviousSibling.nextSibling_ = childWrapperNextSibling;\n          if (childWrapperNextSibling) {\n            childWrapperNextSibling.previousSibling_ = childWrapperPreviousSibling;\n          }\n          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = undefined;\n        } else {\n          clearChildNodes(this);\n          removeChildOriginalHelper(unsafeUnwrap(this), childNode);\n        }\n        if (!surpressMutations) {\n          enqueueMutation(this, \"childList\", {\n            removedNodes: createOneElementNodeList(childWrapper),\n            nextSibling: childWrapperNextSibling,\n            previousSibling: childWrapperPreviousSibling\n          });\n        }\n        registerTransientObservers(this, childWrapper);\n        return childWrapper;\n      },\n      replaceChild: function(newChildWrapper, oldChildWrapper) {\n        assertIsNodeWrapper(newChildWrapper);\n        var oldChildNode;\n        if (isWrapper(oldChildWrapper)) {\n          oldChildNode = unwrap(oldChildWrapper);\n        } else {\n          oldChildNode = oldChildWrapper;\n          oldChildWrapper = wrap(oldChildNode);\n        }\n        if (oldChildWrapper.parentNode !== this) {\n          throw new Error(\"NotFoundError\");\n        }\n        var nextNode = oldChildWrapper.nextSibling;\n        var previousNode = oldChildWrapper.previousSibling;\n        var nodes;\n        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(newChildWrapper);\n        if (useNative) {\n          nodes = collectNodesNative(newChildWrapper);\n        } else {\n          if (nextNode === newChildWrapper) nextNode = newChildWrapper.nextSibling;\n          nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);\n        }\n        if (!useNative) {\n          if (this.firstChild === oldChildWrapper) this.firstChild_ = nodes[0];\n          if (this.lastChild === oldChildWrapper) this.lastChild_ = nodes[nodes.length - 1];\n          oldChildWrapper.previousSibling_ = oldChildWrapper.nextSibling_ = oldChildWrapper.parentNode_ = undefined;\n          if (oldChildNode.parentNode) {\n            originalReplaceChild.call(oldChildNode.parentNode, unwrapNodesForInsertion(this, nodes), oldChildNode);\n          }\n        } else {\n          ensureSameOwnerDocument(this, newChildWrapper);\n          clearChildNodes(this);\n          originalReplaceChild.call(unsafeUnwrap(this), unwrap(newChildWrapper), oldChildNode);\n        }\n        enqueueMutation(this, \"childList\", {\n          addedNodes: nodes,\n          removedNodes: createOneElementNodeList(oldChildWrapper),\n          nextSibling: nextNode,\n          previousSibling: previousNode\n        });\n        nodeWasRemoved(oldChildWrapper);\n        nodesWereAdded(nodes, this);\n        return oldChildWrapper;\n      },\n      nodeIsInserted_: function() {\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          child.nodeIsInserted_();\n        }\n      },\n      hasChildNodes: function() {\n        return this.firstChild !== null;\n      },\n      get parentNode() {\n        return this.parentNode_ !== undefined ? this.parentNode_ : wrap(unsafeUnwrap(this).parentNode);\n      },\n      get firstChild() {\n        return this.firstChild_ !== undefined ? this.firstChild_ : wrap(unsafeUnwrap(this).firstChild);\n      },\n      get lastChild() {\n        return this.lastChild_ !== undefined ? this.lastChild_ : wrap(unsafeUnwrap(this).lastChild);\n      },\n      get nextSibling() {\n        return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(unsafeUnwrap(this).nextSibling);\n      },\n      get previousSibling() {\n        return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(unsafeUnwrap(this).previousSibling);\n      },\n      get parentElement() {\n        var p = this.parentNode;\n        while (p && p.nodeType !== Node.ELEMENT_NODE) {\n          p = p.parentNode;\n        }\n        return p;\n      },\n      get textContent() {\n        var s = \"\";\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType != Node.COMMENT_NODE) {\n            s += child.textContent;\n          }\n        }\n        return s;\n      },\n      set textContent(textContent) {\n        if (textContent == null) textContent = \"\";\n        var removedNodes = snapshotNodeList(this.childNodes);\n        if (this.invalidateShadowRenderer()) {\n          removeAllChildNodes(this);\n          if (textContent !== \"\") {\n            var textNode = unsafeUnwrap(this).ownerDocument.createTextNode(textContent);\n            this.appendChild(textNode);\n          }\n        } else {\n          clearChildNodes(this);\n          unsafeUnwrap(this).textContent = textContent;\n        }\n        var addedNodes = snapshotNodeList(this.childNodes);\n        enqueueMutation(this, \"childList\", {\n          addedNodes: addedNodes,\n          removedNodes: removedNodes\n        });\n        nodesWereRemoved(removedNodes);\n        nodesWereAdded(addedNodes, this);\n      },\n      get childNodes() {\n        var wrapperList = new NodeList();\n        var i = 0;\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          wrapperList[i++] = child;\n        }\n        wrapperList.length = i;\n        return wrapperList;\n      },\n      cloneNode: function(deep) {\n        return cloneNode(this, deep);\n      },\n      contains: function(child) {\n        return contains(this, wrapIfNeeded(child));\n      },\n      compareDocumentPosition: function(otherNode) {\n        return originalCompareDocumentPosition.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\n      },\n      isEqualNode: function(otherNode) {\n        return originalIsEqualNode.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\n      },\n      normalize: function() {\n        var nodes = snapshotNodeList(this.childNodes);\n        var remNodes = [];\n        var s = \"\";\n        var modNode;\n        for (var i = 0, n; i < nodes.length; i++) {\n          n = nodes[i];\n          if (n.nodeType === Node.TEXT_NODE) {\n            if (!modNode && !n.data.length) this.removeChild(n); else if (!modNode) modNode = n; else {\n              s += n.data;\n              remNodes.push(n);\n            }\n          } else {\n            if (modNode && remNodes.length) {\n              modNode.data += s;\n              cleanupNodes(remNodes);\n            }\n            remNodes = [];\n            s = \"\";\n            modNode = null;\n            if (n.childNodes.length) n.normalize();\n          }\n        }\n        if (modNode && remNodes.length) {\n          modNode.data += s;\n          cleanupNodes(remNodes);\n        }\n      }\n    });\n    defineWrapGetter(Node, \"ownerDocument\");\n    registerWrapper(OriginalNode, Node, document.createDocumentFragment());\n    delete Node.prototype.querySelector;\n    delete Node.prototype.querySelectorAll;\n    Node.prototype = mixin(Object.create(EventTarget.prototype), Node.prototype);\n    scope.cloneNode = cloneNode;\n    scope.nodeWasAdded = nodeWasAdded;\n    scope.nodeWasRemoved = nodeWasRemoved;\n    scope.nodesWereAdded = nodesWereAdded;\n    scope.nodesWereRemoved = nodesWereRemoved;\n    scope.originalInsertBefore = originalInsertBefore;\n    scope.originalRemoveChild = originalRemoveChild;\n    scope.snapshotNodeList = snapshotNodeList;\n    scope.wrappers.Node = Node;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLCollection = scope.wrappers.HTMLCollection;\n    var NodeList = scope.wrappers.NodeList;\n    var getTreeScope = scope.getTreeScope;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var originalDocumentQuerySelector = document.querySelector;\n    var originalElementQuerySelector = document.documentElement.querySelector;\n    var originalDocumentQuerySelectorAll = document.querySelectorAll;\n    var originalElementQuerySelectorAll = document.documentElement.querySelectorAll;\n    var originalDocumentGetElementsByTagName = document.getElementsByTagName;\n    var originalElementGetElementsByTagName = document.documentElement.getElementsByTagName;\n    var originalDocumentGetElementsByTagNameNS = document.getElementsByTagNameNS;\n    var originalElementGetElementsByTagNameNS = document.documentElement.getElementsByTagNameNS;\n    var OriginalElement = window.Element;\n    var OriginalDocument = window.HTMLDocument || window.Document;\n    function filterNodeList(list, index, result, deep) {\n      var wrappedItem = null;\n      var root = null;\n      for (var i = 0, length = list.length; i < length; i++) {\n        wrappedItem = wrap(list[i]);\n        if (!deep && (root = getTreeScope(wrappedItem).root)) {\n          if (root instanceof scope.wrappers.ShadowRoot) {\n            continue;\n          }\n        }\n        result[index++] = wrappedItem;\n      }\n      return index;\n    }\n    function shimSelector(selector) {\n      return String(selector).replace(/\\/deep\\/|::shadow|>>>/g, \" \");\n    }\n    function shimMatchesSelector(selector) {\n      return String(selector).replace(/:host\\(([^\\s]+)\\)/g, \"$1\").replace(/([^\\s]):host/g, \"$1\").replace(\":host\", \"*\").replace(/\\^|\\/shadow\\/|\\/shadow-deep\\/|::shadow|\\/deep\\/|::content|>>>/g, \" \");\n    }\n    function findOne(node, selector) {\n      var m, el = node.firstElementChild;\n      while (el) {\n        if (el.matches(selector)) return el;\n        m = findOne(el, selector);\n        if (m) return m;\n        el = el.nextElementSibling;\n      }\n      return null;\n    }\n    function matchesSelector(el, selector) {\n      return el.matches(selector);\n    }\n    var XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n    function matchesTagName(el, localName, localNameLowerCase) {\n      var ln = el.localName;\n      return ln === localName || ln === localNameLowerCase && el.namespaceURI === XHTML_NS;\n    }\n    function matchesEveryThing() {\n      return true;\n    }\n    function matchesLocalNameOnly(el, ns, localName) {\n      return el.localName === localName;\n    }\n    function matchesNameSpace(el, ns) {\n      return el.namespaceURI === ns;\n    }\n    function matchesLocalNameNS(el, ns, localName) {\n      return el.namespaceURI === ns && el.localName === localName;\n    }\n    function findElements(node, index, result, p, arg0, arg1) {\n      var el = node.firstElementChild;\n      while (el) {\n        if (p(el, arg0, arg1)) result[index++] = el;\n        index = findElements(el, index, result, p, arg0, arg1);\n        el = el.nextElementSibling;\n      }\n      return index;\n    }\n    function querySelectorAllFiltered(p, index, result, selector, deep) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, selector, null);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementQuerySelectorAll.call(target, selector);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentQuerySelectorAll.call(target, selector);\n      } else {\n        return findElements(this, index, result, p, selector, null);\n      }\n      return filterNodeList(list, index, result, deep);\n    }\n    var SelectorsInterface = {\n      querySelector: function(selector) {\n        var shimmed = shimSelector(selector);\n        var deep = shimmed !== selector;\n        selector = shimmed;\n        var target = unsafeUnwrap(this);\n        var wrappedItem;\n        var root = getTreeScope(this).root;\n        if (root instanceof scope.wrappers.ShadowRoot) {\n          return findOne(this, selector);\n        } else if (target instanceof OriginalElement) {\n          wrappedItem = wrap(originalElementQuerySelector.call(target, selector));\n        } else if (target instanceof OriginalDocument) {\n          wrappedItem = wrap(originalDocumentQuerySelector.call(target, selector));\n        } else {\n          return findOne(this, selector);\n        }\n        if (!wrappedItem) {\n          return wrappedItem;\n        } else if (!deep && (root = getTreeScope(wrappedItem).root)) {\n          if (root instanceof scope.wrappers.ShadowRoot) {\n            return findOne(this, selector);\n          }\n        }\n        return wrappedItem;\n      },\n      querySelectorAll: function(selector) {\n        var shimmed = shimSelector(selector);\n        var deep = shimmed !== selector;\n        selector = shimmed;\n        var result = new NodeList();\n        result.length = querySelectorAllFiltered.call(this, matchesSelector, 0, result, selector, deep);\n        return result;\n      }\n    };\n    var MatchesInterface = {\n      matches: function(selector) {\n        selector = shimMatchesSelector(selector);\n        return scope.originalMatches.call(unsafeUnwrap(this), selector);\n      }\n    };\n    function getElementsByTagNameFiltered(p, index, result, localName, lowercase) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, localName, lowercase);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementGetElementsByTagName.call(target, localName, lowercase);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentGetElementsByTagName.call(target, localName, lowercase);\n      } else {\n        return findElements(this, index, result, p, localName, lowercase);\n      }\n      return filterNodeList(list, index, result, false);\n    }\n    function getElementsByTagNameNSFiltered(p, index, result, ns, localName) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, ns, localName);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementGetElementsByTagNameNS.call(target, ns, localName);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentGetElementsByTagNameNS.call(target, ns, localName);\n      } else {\n        return findElements(this, index, result, p, ns, localName);\n      }\n      return filterNodeList(list, index, result, false);\n    }\n    var GetElementsByInterface = {\n      getElementsByTagName: function(localName) {\n        var result = new HTMLCollection();\n        var match = localName === \"*\" ? matchesEveryThing : matchesTagName;\n        result.length = getElementsByTagNameFiltered.call(this, match, 0, result, localName, localName.toLowerCase());\n        return result;\n      },\n      getElementsByClassName: function(className) {\n        return this.querySelectorAll(\".\" + className);\n      },\n      getElementsByTagNameNS: function(ns, localName) {\n        var result = new HTMLCollection();\n        var match = null;\n        if (ns === \"*\") {\n          match = localName === \"*\" ? matchesEveryThing : matchesLocalNameOnly;\n        } else {\n          match = localName === \"*\" ? matchesNameSpace : matchesLocalNameNS;\n        }\n        result.length = getElementsByTagNameNSFiltered.call(this, match, 0, result, ns || null, localName);\n        return result;\n      }\n    };\n    scope.GetElementsByInterface = GetElementsByInterface;\n    scope.SelectorsInterface = SelectorsInterface;\n    scope.MatchesInterface = MatchesInterface;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var NodeList = scope.wrappers.NodeList;\n    function forwardElement(node) {\n      while (node && node.nodeType !== Node.ELEMENT_NODE) {\n        node = node.nextSibling;\n      }\n      return node;\n    }\n    function backwardsElement(node) {\n      while (node && node.nodeType !== Node.ELEMENT_NODE) {\n        node = node.previousSibling;\n      }\n      return node;\n    }\n    var ParentNodeInterface = {\n      get firstElementChild() {\n        return forwardElement(this.firstChild);\n      },\n      get lastElementChild() {\n        return backwardsElement(this.lastChild);\n      },\n      get childElementCount() {\n        var count = 0;\n        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n          count++;\n        }\n        return count;\n      },\n      get children() {\n        var wrapperList = new NodeList();\n        var i = 0;\n        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n          wrapperList[i++] = child;\n        }\n        wrapperList.length = i;\n        return wrapperList;\n      },\n      remove: function() {\n        var p = this.parentNode;\n        if (p) p.removeChild(this);\n      }\n    };\n    var ChildNodeInterface = {\n      get nextElementSibling() {\n        return forwardElement(this.nextSibling);\n      },\n      get previousElementSibling() {\n        return backwardsElement(this.previousSibling);\n      }\n    };\n    var NonElementParentNodeInterface = {\n      getElementById: function(id) {\n        if (/[ \\t\\n\\r\\f]/.test(id)) return null;\n        return this.querySelector('[id=\"' + id + '\"]');\n      }\n    };\n    scope.ChildNodeInterface = ChildNodeInterface;\n    scope.NonElementParentNodeInterface = NonElementParentNodeInterface;\n    scope.ParentNodeInterface = ParentNodeInterface;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var ChildNodeInterface = scope.ChildNodeInterface;\n    var Node = scope.wrappers.Node;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var OriginalCharacterData = window.CharacterData;\n    function CharacterData(node) {\n      Node.call(this, node);\n    }\n    CharacterData.prototype = Object.create(Node.prototype);\n    mixin(CharacterData.prototype, {\n      get nodeValue() {\n        return this.data;\n      },\n      set nodeValue(data) {\n        this.data = data;\n      },\n      get textContent() {\n        return this.data;\n      },\n      set textContent(value) {\n        this.data = value;\n      },\n      get data() {\n        return unsafeUnwrap(this).data;\n      },\n      set data(value) {\n        var oldValue = unsafeUnwrap(this).data;\n        enqueueMutation(this, \"characterData\", {\n          oldValue: oldValue\n        });\n        unsafeUnwrap(this).data = value;\n      }\n    });\n    mixin(CharacterData.prototype, ChildNodeInterface);\n    registerWrapper(OriginalCharacterData, CharacterData, document.createTextNode(\"\"));\n    scope.wrappers.CharacterData = CharacterData;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var CharacterData = scope.wrappers.CharacterData;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    function toUInt32(x) {\n      return x >>> 0;\n    }\n    var OriginalText = window.Text;\n    function Text(node) {\n      CharacterData.call(this, node);\n    }\n    Text.prototype = Object.create(CharacterData.prototype);\n    mixin(Text.prototype, {\n      splitText: function(offset) {\n        offset = toUInt32(offset);\n        var s = this.data;\n        if (offset > s.length) throw new Error(\"IndexSizeError\");\n        var head = s.slice(0, offset);\n        var tail = s.slice(offset);\n        this.data = head;\n        var newTextNode = this.ownerDocument.createTextNode(tail);\n        if (this.parentNode) this.parentNode.insertBefore(newTextNode, this.nextSibling);\n        return newTextNode;\n      }\n    });\n    registerWrapper(OriginalText, Text, document.createTextNode(\"\"));\n    scope.wrappers.Text = Text;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    if (!window.DOMTokenList) {\n      console.warn(\"Missing DOMTokenList prototype, please include a \" + \"compatible classList polyfill such as http://goo.gl/uTcepH.\");\n      return;\n    }\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var enqueueMutation = scope.enqueueMutation;\n    function getClass(el) {\n      return unsafeUnwrap(el).getAttribute(\"class\");\n    }\n    function enqueueClassAttributeChange(el, oldValue) {\n      enqueueMutation(el, \"attributes\", {\n        name: \"class\",\n        namespace: null,\n        oldValue: oldValue\n      });\n    }\n    function invalidateClass(el) {\n      scope.invalidateRendererBasedOnAttribute(el, \"class\");\n    }\n    function changeClass(tokenList, method, args) {\n      var ownerElement = tokenList.ownerElement_;\n      if (ownerElement == null) {\n        return method.apply(tokenList, args);\n      }\n      var oldValue = getClass(ownerElement);\n      var retv = method.apply(tokenList, args);\n      if (getClass(ownerElement) !== oldValue) {\n        enqueueClassAttributeChange(ownerElement, oldValue);\n        invalidateClass(ownerElement);\n      }\n      return retv;\n    }\n    var oldAdd = DOMTokenList.prototype.add;\n    DOMTokenList.prototype.add = function() {\n      changeClass(this, oldAdd, arguments);\n    };\n    var oldRemove = DOMTokenList.prototype.remove;\n    DOMTokenList.prototype.remove = function() {\n      changeClass(this, oldRemove, arguments);\n    };\n    var oldToggle = DOMTokenList.prototype.toggle;\n    DOMTokenList.prototype.toggle = function() {\n      return changeClass(this, oldToggle, arguments);\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var ChildNodeInterface = scope.ChildNodeInterface;\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var Node = scope.wrappers.Node;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var MatchesInterface = scope.MatchesInterface;\n    var addWrapNodeListMethod = scope.addWrapNodeListMethod;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var oneOf = scope.oneOf;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrappers = scope.wrappers;\n    var OriginalElement = window.Element;\n    var matchesNames = [ \"matches\", \"mozMatchesSelector\", \"msMatchesSelector\", \"webkitMatchesSelector\" ].filter(function(name) {\n      return OriginalElement.prototype[name];\n    });\n    var matchesName = matchesNames[0];\n    var originalMatches = OriginalElement.prototype[matchesName];\n    function invalidateRendererBasedOnAttribute(element, name) {\n      var p = element.parentNode;\n      if (!p || !p.shadowRoot) return;\n      var renderer = scope.getRendererForHost(p);\n      if (renderer.dependsOnAttribute(name)) renderer.invalidate();\n    }\n    function enqueAttributeChange(element, name, oldValue) {\n      enqueueMutation(element, \"attributes\", {\n        name: name,\n        namespace: null,\n        oldValue: oldValue\n      });\n    }\n    var classListTable = new WeakMap();\n    function Element(node) {\n      Node.call(this, node);\n    }\n    Element.prototype = Object.create(Node.prototype);\n    mixin(Element.prototype, {\n      createShadowRoot: function() {\n        var newShadowRoot = new wrappers.ShadowRoot(this);\n        unsafeUnwrap(this).polymerShadowRoot_ = newShadowRoot;\n        var renderer = scope.getRendererForHost(this);\n        renderer.invalidate();\n        return newShadowRoot;\n      },\n      get shadowRoot() {\n        return unsafeUnwrap(this).polymerShadowRoot_ || null;\n      },\n      setAttribute: function(name, value) {\n        var oldValue = unsafeUnwrap(this).getAttribute(name);\n        unsafeUnwrap(this).setAttribute(name, value);\n        enqueAttributeChange(this, name, oldValue);\n        invalidateRendererBasedOnAttribute(this, name);\n      },\n      removeAttribute: function(name) {\n        var oldValue = unsafeUnwrap(this).getAttribute(name);\n        unsafeUnwrap(this).removeAttribute(name);\n        enqueAttributeChange(this, name, oldValue);\n        invalidateRendererBasedOnAttribute(this, name);\n      },\n      get classList() {\n        var list = classListTable.get(this);\n        if (!list) {\n          list = unsafeUnwrap(this).classList;\n          if (!list) return;\n          list.ownerElement_ = this;\n          classListTable.set(this, list);\n        }\n        return list;\n      },\n      get className() {\n        return unsafeUnwrap(this).className;\n      },\n      set className(v) {\n        this.setAttribute(\"class\", v);\n      },\n      get id() {\n        return unsafeUnwrap(this).id;\n      },\n      set id(v) {\n        this.setAttribute(\"id\", v);\n      }\n    });\n    matchesNames.forEach(function(name) {\n      if (name !== \"matches\") {\n        Element.prototype[name] = function(selector) {\n          return this.matches(selector);\n        };\n      }\n    });\n    if (OriginalElement.prototype.webkitCreateShadowRoot) {\n      Element.prototype.webkitCreateShadowRoot = Element.prototype.createShadowRoot;\n    }\n    mixin(Element.prototype, ChildNodeInterface);\n    mixin(Element.prototype, GetElementsByInterface);\n    mixin(Element.prototype, ParentNodeInterface);\n    mixin(Element.prototype, SelectorsInterface);\n    mixin(Element.prototype, MatchesInterface);\n    registerWrapper(OriginalElement, Element, document.createElementNS(null, \"x\"));\n    scope.invalidateRendererBasedOnAttribute = invalidateRendererBasedOnAttribute;\n    scope.matchesNames = matchesNames;\n    scope.originalMatches = originalMatches;\n    scope.wrappers.Element = Element;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Element = scope.wrappers.Element;\n    var defineGetter = scope.defineGetter;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var nodesWereAdded = scope.nodesWereAdded;\n    var nodesWereRemoved = scope.nodesWereRemoved;\n    var registerWrapper = scope.registerWrapper;\n    var snapshotNodeList = scope.snapshotNodeList;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrappers = scope.wrappers;\n    var escapeAttrRegExp = /[&\\u00A0\"]/g;\n    var escapeDataRegExp = /[&\\u00A0<>]/g;\n    function escapeReplace(c) {\n      switch (c) {\n       case \"&\":\n        return \"&amp;\";\n\n       case \"<\":\n        return \"&lt;\";\n\n       case \">\":\n        return \"&gt;\";\n\n       case '\"':\n        return \"&quot;\";\n\n       case \"\":\n        return \"&nbsp;\";\n      }\n    }\n    function escapeAttr(s) {\n      return s.replace(escapeAttrRegExp, escapeReplace);\n    }\n    function escapeData(s) {\n      return s.replace(escapeDataRegExp, escapeReplace);\n    }\n    function makeSet(arr) {\n      var set = {};\n      for (var i = 0; i < arr.length; i++) {\n        set[arr[i]] = true;\n      }\n      return set;\n    }\n    var voidElements = makeSet([ \"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\" ]);\n    var plaintextParents = makeSet([ \"style\", \"script\", \"xmp\", \"iframe\", \"noembed\", \"noframes\", \"plaintext\", \"noscript\" ]);\n    var XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n    function needsSelfClosingSlash(node) {\n      if (node.namespaceURI !== XHTML_NS) return true;\n      var doctype = node.ownerDocument.doctype;\n      return doctype && doctype.publicId && doctype.systemId;\n    }\n    function getOuterHTML(node, parentNode) {\n      switch (node.nodeType) {\n       case Node.ELEMENT_NODE:\n        var tagName = node.tagName.toLowerCase();\n        var s = \"<\" + tagName;\n        var attrs = node.attributes;\n        for (var i = 0, attr; attr = attrs[i]; i++) {\n          s += \" \" + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n        }\n        if (voidElements[tagName]) {\n          if (needsSelfClosingSlash(node)) s += \"/\";\n          return s + \">\";\n        }\n        return s + \">\" + getInnerHTML(node) + \"</\" + tagName + \">\";\n\n       case Node.TEXT_NODE:\n        var data = node.data;\n        if (parentNode && plaintextParents[parentNode.localName]) return data;\n        return escapeData(data);\n\n       case Node.COMMENT_NODE:\n        return \"<!--\" + node.data + \"-->\";\n\n       default:\n        console.error(node);\n        throw new Error(\"not implemented\");\n      }\n    }\n    function getInnerHTML(node) {\n      if (node instanceof wrappers.HTMLTemplateElement) node = node.content;\n      var s = \"\";\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        s += getOuterHTML(child, node);\n      }\n      return s;\n    }\n    function setInnerHTML(node, value, opt_tagName) {\n      var tagName = opt_tagName || \"div\";\n      node.textContent = \"\";\n      var tempElement = unwrap(node.ownerDocument.createElement(tagName));\n      tempElement.innerHTML = value;\n      var firstChild;\n      while (firstChild = tempElement.firstChild) {\n        node.appendChild(wrap(firstChild));\n      }\n    }\n    var oldIe = /MSIE/.test(navigator.userAgent);\n    var OriginalHTMLElement = window.HTMLElement;\n    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n    function HTMLElement(node) {\n      Element.call(this, node);\n    }\n    HTMLElement.prototype = Object.create(Element.prototype);\n    mixin(HTMLElement.prototype, {\n      get innerHTML() {\n        return getInnerHTML(this);\n      },\n      set innerHTML(value) {\n        if (oldIe && plaintextParents[this.localName]) {\n          this.textContent = value;\n          return;\n        }\n        var removedNodes = snapshotNodeList(this.childNodes);\n        if (this.invalidateShadowRenderer()) {\n          if (this instanceof wrappers.HTMLTemplateElement) setInnerHTML(this.content, value); else setInnerHTML(this, value, this.tagName);\n        } else if (!OriginalHTMLTemplateElement && this instanceof wrappers.HTMLTemplateElement) {\n          setInnerHTML(this.content, value);\n        } else {\n          unsafeUnwrap(this).innerHTML = value;\n        }\n        var addedNodes = snapshotNodeList(this.childNodes);\n        enqueueMutation(this, \"childList\", {\n          addedNodes: addedNodes,\n          removedNodes: removedNodes\n        });\n        nodesWereRemoved(removedNodes);\n        nodesWereAdded(addedNodes, this);\n      },\n      get outerHTML() {\n        return getOuterHTML(this, this.parentNode);\n      },\n      set outerHTML(value) {\n        var p = this.parentNode;\n        if (p) {\n          p.invalidateShadowRenderer();\n          var df = frag(p, value);\n          p.replaceChild(df, this);\n        }\n      },\n      insertAdjacentHTML: function(position, text) {\n        var contextElement, refNode;\n        switch (String(position).toLowerCase()) {\n         case \"beforebegin\":\n          contextElement = this.parentNode;\n          refNode = this;\n          break;\n\n         case \"afterend\":\n          contextElement = this.parentNode;\n          refNode = this.nextSibling;\n          break;\n\n         case \"afterbegin\":\n          contextElement = this;\n          refNode = this.firstChild;\n          break;\n\n         case \"beforeend\":\n          contextElement = this;\n          refNode = null;\n          break;\n\n         default:\n          return;\n        }\n        var df = frag(contextElement, text);\n        contextElement.insertBefore(df, refNode);\n      },\n      get hidden() {\n        return this.hasAttribute(\"hidden\");\n      },\n      set hidden(v) {\n        if (v) {\n          this.setAttribute(\"hidden\", \"\");\n        } else {\n          this.removeAttribute(\"hidden\");\n        }\n      }\n    });\n    function frag(contextElement, html) {\n      var p = unwrap(contextElement.cloneNode(false));\n      p.innerHTML = html;\n      var df = unwrap(document.createDocumentFragment());\n      var c;\n      while (c = p.firstChild) {\n        df.appendChild(c);\n      }\n      return wrap(df);\n    }\n    function getter(name) {\n      return function() {\n        scope.renderAllPending();\n        return unsafeUnwrap(this)[name];\n      };\n    }\n    function getterRequiresRendering(name) {\n      defineGetter(HTMLElement, name, getter(name));\n    }\n    [ \"clientHeight\", \"clientLeft\", \"clientTop\", \"clientWidth\", \"offsetHeight\", \"offsetLeft\", \"offsetTop\", \"offsetWidth\", \"scrollHeight\", \"scrollWidth\" ].forEach(getterRequiresRendering);\n    function getterAndSetterRequiresRendering(name) {\n      Object.defineProperty(HTMLElement.prototype, name, {\n        get: getter(name),\n        set: function(v) {\n          scope.renderAllPending();\n          unsafeUnwrap(this)[name] = v;\n        },\n        configurable: true,\n        enumerable: true\n      });\n    }\n    [ \"scrollLeft\", \"scrollTop\" ].forEach(getterAndSetterRequiresRendering);\n    function methodRequiresRendering(name) {\n      Object.defineProperty(HTMLElement.prototype, name, {\n        value: function() {\n          scope.renderAllPending();\n          return unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments);\n        },\n        configurable: true,\n        enumerable: true\n      });\n    }\n    [ \"focus\", \"getBoundingClientRect\", \"getClientRects\", \"scrollIntoView\" ].forEach(methodRequiresRendering);\n    registerWrapper(OriginalHTMLElement, HTMLElement, document.createElement(\"b\"));\n    scope.wrappers.HTMLElement = HTMLElement;\n    scope.getInnerHTML = getInnerHTML;\n    scope.setInnerHTML = setInnerHTML;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLCanvasElement = window.HTMLCanvasElement;\n    function HTMLCanvasElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLCanvasElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLCanvasElement.prototype, {\n      getContext: function() {\n        var context = unsafeUnwrap(this).getContext.apply(unsafeUnwrap(this), arguments);\n        return context && wrap(context);\n      }\n    });\n    registerWrapper(OriginalHTMLCanvasElement, HTMLCanvasElement, document.createElement(\"canvas\"));\n    scope.wrappers.HTMLCanvasElement = HTMLCanvasElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLContentElement = window.HTMLContentElement;\n    function HTMLContentElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLContentElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLContentElement.prototype, {\n      constructor: HTMLContentElement,\n      get select() {\n        return this.getAttribute(\"select\");\n      },\n      set select(value) {\n        this.setAttribute(\"select\", value);\n      },\n      setAttribute: function(n, v) {\n        HTMLElement.prototype.setAttribute.call(this, n, v);\n        if (String(n).toLowerCase() === \"select\") this.invalidateShadowRenderer(true);\n      }\n    });\n    if (OriginalHTMLContentElement) registerWrapper(OriginalHTMLContentElement, HTMLContentElement);\n    scope.wrappers.HTMLContentElement = HTMLContentElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var OriginalHTMLFormElement = window.HTMLFormElement;\n    function HTMLFormElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLFormElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLFormElement.prototype, {\n      get elements() {\n        return wrapHTMLCollection(unwrap(this).elements);\n      }\n    });\n    registerWrapper(OriginalHTMLFormElement, HTMLFormElement, document.createElement(\"form\"));\n    scope.wrappers.HTMLFormElement = HTMLFormElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var rewrap = scope.rewrap;\n    var OriginalHTMLImageElement = window.HTMLImageElement;\n    function HTMLImageElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLImageElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLImageElement, HTMLImageElement, document.createElement(\"img\"));\n    function Image(width, height) {\n      if (!(this instanceof Image)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      var node = unwrap(document.createElement(\"img\"));\n      HTMLElement.call(this, node);\n      rewrap(node, this);\n      if (width !== undefined) node.width = width;\n      if (height !== undefined) node.height = height;\n    }\n    Image.prototype = HTMLImageElement.prototype;\n    scope.wrappers.HTMLImageElement = HTMLImageElement;\n    scope.wrappers.Image = Image;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var NodeList = scope.wrappers.NodeList;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLShadowElement = window.HTMLShadowElement;\n    function HTMLShadowElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLShadowElement.prototype = Object.create(HTMLElement.prototype);\n    HTMLShadowElement.prototype.constructor = HTMLShadowElement;\n    if (OriginalHTMLShadowElement) registerWrapper(OriginalHTMLShadowElement, HTMLShadowElement);\n    scope.wrappers.HTMLShadowElement = HTMLShadowElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var contentTable = new WeakMap();\n    var templateContentsOwnerTable = new WeakMap();\n    function getTemplateContentsOwner(doc) {\n      if (!doc.defaultView) return doc;\n      var d = templateContentsOwnerTable.get(doc);\n      if (!d) {\n        d = doc.implementation.createHTMLDocument(\"\");\n        while (d.lastChild) {\n          d.removeChild(d.lastChild);\n        }\n        templateContentsOwnerTable.set(doc, d);\n      }\n      return d;\n    }\n    function extractContent(templateElement) {\n      var doc = getTemplateContentsOwner(templateElement.ownerDocument);\n      var df = unwrap(doc.createDocumentFragment());\n      var child;\n      while (child = templateElement.firstChild) {\n        df.appendChild(child);\n      }\n      return df;\n    }\n    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n    function HTMLTemplateElement(node) {\n      HTMLElement.call(this, node);\n      if (!OriginalHTMLTemplateElement) {\n        var content = extractContent(node);\n        contentTable.set(this, wrap(content));\n      }\n    }\n    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTemplateElement.prototype, {\n      constructor: HTMLTemplateElement,\n      get content() {\n        if (OriginalHTMLTemplateElement) return wrap(unsafeUnwrap(this).content);\n        return contentTable.get(this);\n      }\n    });\n    if (OriginalHTMLTemplateElement) registerWrapper(OriginalHTMLTemplateElement, HTMLTemplateElement);\n    scope.wrappers.HTMLTemplateElement = HTMLTemplateElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLMediaElement = window.HTMLMediaElement;\n    if (!OriginalHTMLMediaElement) return;\n    function HTMLMediaElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLMediaElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLMediaElement, HTMLMediaElement, document.createElement(\"audio\"));\n    scope.wrappers.HTMLMediaElement = HTMLMediaElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLMediaElement = scope.wrappers.HTMLMediaElement;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var rewrap = scope.rewrap;\n    var OriginalHTMLAudioElement = window.HTMLAudioElement;\n    if (!OriginalHTMLAudioElement) return;\n    function HTMLAudioElement(node) {\n      HTMLMediaElement.call(this, node);\n    }\n    HTMLAudioElement.prototype = Object.create(HTMLMediaElement.prototype);\n    registerWrapper(OriginalHTMLAudioElement, HTMLAudioElement, document.createElement(\"audio\"));\n    function Audio(src) {\n      if (!(this instanceof Audio)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      var node = unwrap(document.createElement(\"audio\"));\n      HTMLMediaElement.call(this, node);\n      rewrap(node, this);\n      node.setAttribute(\"preload\", \"auto\");\n      if (src !== undefined) node.setAttribute(\"src\", src);\n    }\n    Audio.prototype = HTMLAudioElement.prototype;\n    scope.wrappers.HTMLAudioElement = HTMLAudioElement;\n    scope.wrappers.Audio = Audio;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var rewrap = scope.rewrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLOptionElement = window.HTMLOptionElement;\n    function trimText(s) {\n      return s.replace(/\\s+/g, \" \").trim();\n    }\n    function HTMLOptionElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLOptionElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLOptionElement.prototype, {\n      get text() {\n        return trimText(this.textContent);\n      },\n      set text(value) {\n        this.textContent = trimText(String(value));\n      },\n      get form() {\n        return wrap(unwrap(this).form);\n      }\n    });\n    registerWrapper(OriginalHTMLOptionElement, HTMLOptionElement, document.createElement(\"option\"));\n    function Option(text, value, defaultSelected, selected) {\n      if (!(this instanceof Option)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      var node = unwrap(document.createElement(\"option\"));\n      HTMLElement.call(this, node);\n      rewrap(node, this);\n      if (text !== undefined) node.text = text;\n      if (value !== undefined) node.setAttribute(\"value\", value);\n      if (defaultSelected === true) node.setAttribute(\"selected\", \"\");\n      node.selected = selected === true;\n    }\n    Option.prototype = HTMLOptionElement.prototype;\n    scope.wrappers.HTMLOptionElement = HTMLOptionElement;\n    scope.wrappers.Option = Option;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLSelectElement = window.HTMLSelectElement;\n    function HTMLSelectElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLSelectElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLSelectElement.prototype, {\n      add: function(element, before) {\n        if (typeof before === \"object\") before = unwrap(before);\n        unwrap(this).add(unwrap(element), before);\n      },\n      remove: function(indexOrNode) {\n        if (indexOrNode === undefined) {\n          HTMLElement.prototype.remove.call(this);\n          return;\n        }\n        if (typeof indexOrNode === \"object\") indexOrNode = unwrap(indexOrNode);\n        unwrap(this).remove(indexOrNode);\n      },\n      get form() {\n        return wrap(unwrap(this).form);\n      }\n    });\n    registerWrapper(OriginalHTMLSelectElement, HTMLSelectElement, document.createElement(\"select\"));\n    scope.wrappers.HTMLSelectElement = HTMLSelectElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var OriginalHTMLTableElement = window.HTMLTableElement;\n    function HTMLTableElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableElement.prototype, {\n      get caption() {\n        return wrap(unwrap(this).caption);\n      },\n      createCaption: function() {\n        return wrap(unwrap(this).createCaption());\n      },\n      get tHead() {\n        return wrap(unwrap(this).tHead);\n      },\n      createTHead: function() {\n        return wrap(unwrap(this).createTHead());\n      },\n      createTFoot: function() {\n        return wrap(unwrap(this).createTFoot());\n      },\n      get tFoot() {\n        return wrap(unwrap(this).tFoot);\n      },\n      get tBodies() {\n        return wrapHTMLCollection(unwrap(this).tBodies);\n      },\n      createTBody: function() {\n        return wrap(unwrap(this).createTBody());\n      },\n      get rows() {\n        return wrapHTMLCollection(unwrap(this).rows);\n      },\n      insertRow: function(index) {\n        return wrap(unwrap(this).insertRow(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableElement, HTMLTableElement, document.createElement(\"table\"));\n    scope.wrappers.HTMLTableElement = HTMLTableElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLTableSectionElement = window.HTMLTableSectionElement;\n    function HTMLTableSectionElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableSectionElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableSectionElement.prototype, {\n      constructor: HTMLTableSectionElement,\n      get rows() {\n        return wrapHTMLCollection(unwrap(this).rows);\n      },\n      insertRow: function(index) {\n        return wrap(unwrap(this).insertRow(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableSectionElement, HTMLTableSectionElement, document.createElement(\"thead\"));\n    scope.wrappers.HTMLTableSectionElement = HTMLTableSectionElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLTableRowElement = window.HTMLTableRowElement;\n    function HTMLTableRowElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableRowElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableRowElement.prototype, {\n      get cells() {\n        return wrapHTMLCollection(unwrap(this).cells);\n      },\n      insertCell: function(index) {\n        return wrap(unwrap(this).insertCell(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableRowElement, HTMLTableRowElement, document.createElement(\"tr\"));\n    scope.wrappers.HTMLTableRowElement = HTMLTableRowElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLContentElement = scope.wrappers.HTMLContentElement;\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n    var HTMLTemplateElement = scope.wrappers.HTMLTemplateElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLUnknownElement = window.HTMLUnknownElement;\n    function HTMLUnknownElement(node) {\n      switch (node.localName) {\n       case \"content\":\n        return new HTMLContentElement(node);\n\n       case \"shadow\":\n        return new HTMLShadowElement(node);\n\n       case \"template\":\n        return new HTMLTemplateElement(node);\n      }\n      HTMLElement.call(this, node);\n    }\n    HTMLUnknownElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLUnknownElement, HTMLUnknownElement);\n    scope.wrappers.HTMLUnknownElement = HTMLUnknownElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Element = scope.wrappers.Element;\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var mixin = scope.mixin;\n    var SVG_NS = \"http://www.w3.org/2000/svg\";\n    var OriginalSVGElement = window.SVGElement;\n    var svgTitleElement = document.createElementNS(SVG_NS, \"title\");\n    if (!(\"classList\" in svgTitleElement)) {\n      var descr = Object.getOwnPropertyDescriptor(Element.prototype, \"classList\");\n      Object.defineProperty(HTMLElement.prototype, \"classList\", descr);\n      delete Element.prototype.classList;\n    }\n    function SVGElement(node) {\n      Element.call(this, node);\n    }\n    SVGElement.prototype = Object.create(Element.prototype);\n    mixin(SVGElement.prototype, {\n      get ownerSVGElement() {\n        return wrap(unsafeUnwrap(this).ownerSVGElement);\n      }\n    });\n    registerWrapper(OriginalSVGElement, SVGElement, document.createElementNS(SVG_NS, \"title\"));\n    scope.wrappers.SVGElement = SVGElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalSVGUseElement = window.SVGUseElement;\n    var SVG_NS = \"http://www.w3.org/2000/svg\";\n    var gWrapper = wrap(document.createElementNS(SVG_NS, \"g\"));\n    var useElement = document.createElementNS(SVG_NS, \"use\");\n    var SVGGElement = gWrapper.constructor;\n    var parentInterfacePrototype = Object.getPrototypeOf(SVGGElement.prototype);\n    var parentInterface = parentInterfacePrototype.constructor;\n    function SVGUseElement(impl) {\n      parentInterface.call(this, impl);\n    }\n    SVGUseElement.prototype = Object.create(parentInterfacePrototype);\n    if (\"instanceRoot\" in useElement) {\n      mixin(SVGUseElement.prototype, {\n        get instanceRoot() {\n          return wrap(unwrap(this).instanceRoot);\n        },\n        get animatedInstanceRoot() {\n          return wrap(unwrap(this).animatedInstanceRoot);\n        }\n      });\n    }\n    registerWrapper(OriginalSVGUseElement, SVGUseElement, useElement);\n    scope.wrappers.SVGUseElement = SVGUseElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var EventTarget = scope.wrappers.EventTarget;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalSVGElementInstance = window.SVGElementInstance;\n    if (!OriginalSVGElementInstance) return;\n    function SVGElementInstance(impl) {\n      EventTarget.call(this, impl);\n    }\n    SVGElementInstance.prototype = Object.create(EventTarget.prototype);\n    mixin(SVGElementInstance.prototype, {\n      get correspondingElement() {\n        return wrap(unsafeUnwrap(this).correspondingElement);\n      },\n      get correspondingUseElement() {\n        return wrap(unsafeUnwrap(this).correspondingUseElement);\n      },\n      get parentNode() {\n        return wrap(unsafeUnwrap(this).parentNode);\n      },\n      get childNodes() {\n        throw new Error(\"Not implemented\");\n      },\n      get firstChild() {\n        return wrap(unsafeUnwrap(this).firstChild);\n      },\n      get lastChild() {\n        return wrap(unsafeUnwrap(this).lastChild);\n      },\n      get previousSibling() {\n        return wrap(unsafeUnwrap(this).previousSibling);\n      },\n      get nextSibling() {\n        return wrap(unsafeUnwrap(this).nextSibling);\n      }\n    });\n    registerWrapper(OriginalSVGElementInstance, SVGElementInstance);\n    scope.wrappers.SVGElementInstance = SVGElementInstance;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalCanvasRenderingContext2D = window.CanvasRenderingContext2D;\n    function CanvasRenderingContext2D(impl) {\n      setWrapper(impl, this);\n    }\n    mixin(CanvasRenderingContext2D.prototype, {\n      get canvas() {\n        return wrap(unsafeUnwrap(this).canvas);\n      },\n      drawImage: function() {\n        arguments[0] = unwrapIfNeeded(arguments[0]);\n        unsafeUnwrap(this).drawImage.apply(unsafeUnwrap(this), arguments);\n      },\n      createPattern: function() {\n        arguments[0] = unwrap(arguments[0]);\n        return unsafeUnwrap(this).createPattern.apply(unsafeUnwrap(this), arguments);\n      }\n    });\n    registerWrapper(OriginalCanvasRenderingContext2D, CanvasRenderingContext2D, document.createElement(\"canvas\").getContext(\"2d\"));\n    scope.wrappers.CanvasRenderingContext2D = CanvasRenderingContext2D;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var addForwardingProperties = scope.addForwardingProperties;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalWebGLRenderingContext = window.WebGLRenderingContext;\n    if (!OriginalWebGLRenderingContext) return;\n    function WebGLRenderingContext(impl) {\n      setWrapper(impl, this);\n    }\n    mixin(WebGLRenderingContext.prototype, {\n      get canvas() {\n        return wrap(unsafeUnwrap(this).canvas);\n      },\n      texImage2D: function() {\n        arguments[5] = unwrapIfNeeded(arguments[5]);\n        unsafeUnwrap(this).texImage2D.apply(unsafeUnwrap(this), arguments);\n      },\n      texSubImage2D: function() {\n        arguments[6] = unwrapIfNeeded(arguments[6]);\n        unsafeUnwrap(this).texSubImage2D.apply(unsafeUnwrap(this), arguments);\n      }\n    });\n    var OriginalWebGLRenderingContextBase = Object.getPrototypeOf(OriginalWebGLRenderingContext.prototype);\n    if (OriginalWebGLRenderingContextBase !== Object.prototype) {\n      addForwardingProperties(OriginalWebGLRenderingContextBase, WebGLRenderingContext.prototype);\n    }\n    var instanceProperties = /WebKit/.test(navigator.userAgent) ? {\n      drawingBufferHeight: null,\n      drawingBufferWidth: null\n    } : {};\n    registerWrapper(OriginalWebGLRenderingContext, WebGLRenderingContext, instanceProperties);\n    scope.wrappers.WebGLRenderingContext = WebGLRenderingContext;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Node = scope.wrappers.Node;\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var mixin = scope.mixin;\n    var registerObject = scope.registerObject;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalDocumentFragment = window.DocumentFragment;\n    function DocumentFragment(node) {\n      Node.call(this, node);\n    }\n    DocumentFragment.prototype = Object.create(Node.prototype);\n    mixin(DocumentFragment.prototype, ParentNodeInterface);\n    mixin(DocumentFragment.prototype, SelectorsInterface);\n    mixin(DocumentFragment.prototype, GetElementsByInterface);\n    mixin(DocumentFragment.prototype, NonElementParentNodeInterface);\n    registerWrapper(OriginalDocumentFragment, DocumentFragment, document.createDocumentFragment());\n    scope.wrappers.DocumentFragment = DocumentFragment;\n    var Comment = registerObject(document.createComment(\"\"));\n    scope.wrappers.Comment = Comment;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var DocumentFragment = scope.wrappers.DocumentFragment;\n    var TreeScope = scope.TreeScope;\n    var elementFromPoint = scope.elementFromPoint;\n    var getInnerHTML = scope.getInnerHTML;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var rewrap = scope.rewrap;\n    var setInnerHTML = scope.setInnerHTML;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var shadowHostTable = new WeakMap();\n    var nextOlderShadowTreeTable = new WeakMap();\n    function ShadowRoot(hostWrapper) {\n      var node = unwrap(unsafeUnwrap(hostWrapper).ownerDocument.createDocumentFragment());\n      DocumentFragment.call(this, node);\n      rewrap(node, this);\n      var oldShadowRoot = hostWrapper.shadowRoot;\n      nextOlderShadowTreeTable.set(this, oldShadowRoot);\n      this.treeScope_ = new TreeScope(this, getTreeScope(oldShadowRoot || hostWrapper));\n      shadowHostTable.set(this, hostWrapper);\n    }\n    ShadowRoot.prototype = Object.create(DocumentFragment.prototype);\n    mixin(ShadowRoot.prototype, {\n      constructor: ShadowRoot,\n      get innerHTML() {\n        return getInnerHTML(this);\n      },\n      set innerHTML(value) {\n        setInnerHTML(this, value);\n        this.invalidateShadowRenderer();\n      },\n      get olderShadowRoot() {\n        return nextOlderShadowTreeTable.get(this) || null;\n      },\n      get host() {\n        return shadowHostTable.get(this) || null;\n      },\n      invalidateShadowRenderer: function() {\n        return shadowHostTable.get(this).invalidateShadowRenderer();\n      },\n      elementFromPoint: function(x, y) {\n        return elementFromPoint(this, this.ownerDocument, x, y);\n      },\n      getSelection: function() {\n        return document.getSelection();\n      },\n      get activeElement() {\n        var unwrappedActiveElement = unwrap(this).ownerDocument.activeElement;\n        if (!unwrappedActiveElement || !unwrappedActiveElement.nodeType) return null;\n        var activeElement = wrap(unwrappedActiveElement);\n        if (activeElement === this.host) {\n          return null;\n        }\n        while (!this.contains(activeElement) && !this.host.contains(activeElement)) {\n          while (activeElement.parentNode) {\n            activeElement = activeElement.parentNode;\n          }\n          if (activeElement.host) {\n            activeElement = activeElement.host;\n          } else {\n            return null;\n          }\n        }\n        return activeElement;\n      }\n    });\n    scope.wrappers.ShadowRoot = ShadowRoot;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var getTreeScope = scope.getTreeScope;\n    var OriginalRange = window.Range;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    function getHost(node) {\n      var root = getTreeScope(node).root;\n      if (root instanceof ShadowRoot) {\n        return root.host;\n      }\n      return null;\n    }\n    function hostNodeToShadowNode(refNode, offset) {\n      if (refNode.shadowRoot) {\n        offset = Math.min(refNode.childNodes.length - 1, offset);\n        var child = refNode.childNodes[offset];\n        if (child) {\n          var insertionPoint = scope.getDestinationInsertionPoints(child);\n          if (insertionPoint.length > 0) {\n            var parentNode = insertionPoint[0].parentNode;\n            if (parentNode.nodeType == Node.ELEMENT_NODE) {\n              refNode = parentNode;\n            }\n          }\n        }\n      }\n      return refNode;\n    }\n    function shadowNodeToHostNode(node) {\n      node = wrap(node);\n      return getHost(node) || node;\n    }\n    function Range(impl) {\n      setWrapper(impl, this);\n    }\n    Range.prototype = {\n      get startContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).startContainer);\n      },\n      get endContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).endContainer);\n      },\n      get commonAncestorContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).commonAncestorContainer);\n      },\n      setStart: function(refNode, offset) {\n        refNode = hostNodeToShadowNode(refNode, offset);\n        unsafeUnwrap(this).setStart(unwrapIfNeeded(refNode), offset);\n      },\n      setEnd: function(refNode, offset) {\n        refNode = hostNodeToShadowNode(refNode, offset);\n        unsafeUnwrap(this).setEnd(unwrapIfNeeded(refNode), offset);\n      },\n      setStartBefore: function(refNode) {\n        unsafeUnwrap(this).setStartBefore(unwrapIfNeeded(refNode));\n      },\n      setStartAfter: function(refNode) {\n        unsafeUnwrap(this).setStartAfter(unwrapIfNeeded(refNode));\n      },\n      setEndBefore: function(refNode) {\n        unsafeUnwrap(this).setEndBefore(unwrapIfNeeded(refNode));\n      },\n      setEndAfter: function(refNode) {\n        unsafeUnwrap(this).setEndAfter(unwrapIfNeeded(refNode));\n      },\n      selectNode: function(refNode) {\n        unsafeUnwrap(this).selectNode(unwrapIfNeeded(refNode));\n      },\n      selectNodeContents: function(refNode) {\n        unsafeUnwrap(this).selectNodeContents(unwrapIfNeeded(refNode));\n      },\n      compareBoundaryPoints: function(how, sourceRange) {\n        return unsafeUnwrap(this).compareBoundaryPoints(how, unwrap(sourceRange));\n      },\n      extractContents: function() {\n        return wrap(unsafeUnwrap(this).extractContents());\n      },\n      cloneContents: function() {\n        return wrap(unsafeUnwrap(this).cloneContents());\n      },\n      insertNode: function(node) {\n        unsafeUnwrap(this).insertNode(unwrapIfNeeded(node));\n      },\n      surroundContents: function(newParent) {\n        unsafeUnwrap(this).surroundContents(unwrapIfNeeded(newParent));\n      },\n      cloneRange: function() {\n        return wrap(unsafeUnwrap(this).cloneRange());\n      },\n      isPointInRange: function(node, offset) {\n        return unsafeUnwrap(this).isPointInRange(unwrapIfNeeded(node), offset);\n      },\n      comparePoint: function(node, offset) {\n        return unsafeUnwrap(this).comparePoint(unwrapIfNeeded(node), offset);\n      },\n      intersectsNode: function(node) {\n        return unsafeUnwrap(this).intersectsNode(unwrapIfNeeded(node));\n      },\n      toString: function() {\n        return unsafeUnwrap(this).toString();\n      }\n    };\n    if (OriginalRange.prototype.createContextualFragment) {\n      Range.prototype.createContextualFragment = function(html) {\n        return wrap(unsafeUnwrap(this).createContextualFragment(html));\n      };\n    }\n    registerWrapper(window.Range, Range, document.createRange());\n    scope.wrappers.Range = Range;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Element = scope.wrappers.Element;\n    var HTMLContentElement = scope.wrappers.HTMLContentElement;\n    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n    var Node = scope.wrappers.Node;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    var assert = scope.assert;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var oneOf = scope.oneOf;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var ArraySplice = scope.ArraySplice;\n    function updateWrapperUpAndSideways(wrapper) {\n      wrapper.previousSibling_ = wrapper.previousSibling;\n      wrapper.nextSibling_ = wrapper.nextSibling;\n      wrapper.parentNode_ = wrapper.parentNode;\n    }\n    function updateWrapperDown(wrapper) {\n      wrapper.firstChild_ = wrapper.firstChild;\n      wrapper.lastChild_ = wrapper.lastChild;\n    }\n    function updateAllChildNodes(parentNodeWrapper) {\n      assert(parentNodeWrapper instanceof Node);\n      for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {\n        updateWrapperUpAndSideways(childWrapper);\n      }\n      updateWrapperDown(parentNodeWrapper);\n    }\n    function insertBefore(parentNodeWrapper, newChildWrapper, refChildWrapper) {\n      var parentNode = unwrap(parentNodeWrapper);\n      var newChild = unwrap(newChildWrapper);\n      var refChild = refChildWrapper ? unwrap(refChildWrapper) : null;\n      remove(newChildWrapper);\n      updateWrapperUpAndSideways(newChildWrapper);\n      if (!refChildWrapper) {\n        parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;\n        if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild) parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;\n        var lastChildWrapper = wrap(parentNode.lastChild);\n        if (lastChildWrapper) lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;\n      } else {\n        if (parentNodeWrapper.firstChild === refChildWrapper) parentNodeWrapper.firstChild_ = refChildWrapper;\n        refChildWrapper.previousSibling_ = refChildWrapper.previousSibling;\n      }\n      scope.originalInsertBefore.call(parentNode, newChild, refChild);\n    }\n    function remove(nodeWrapper) {\n      var node = unwrap(nodeWrapper);\n      var parentNode = node.parentNode;\n      if (!parentNode) return;\n      var parentNodeWrapper = wrap(parentNode);\n      updateWrapperUpAndSideways(nodeWrapper);\n      if (nodeWrapper.previousSibling) nodeWrapper.previousSibling.nextSibling_ = nodeWrapper;\n      if (nodeWrapper.nextSibling) nodeWrapper.nextSibling.previousSibling_ = nodeWrapper;\n      if (parentNodeWrapper.lastChild === nodeWrapper) parentNodeWrapper.lastChild_ = nodeWrapper;\n      if (parentNodeWrapper.firstChild === nodeWrapper) parentNodeWrapper.firstChild_ = nodeWrapper;\n      scope.originalRemoveChild.call(parentNode, node);\n    }\n    var distributedNodesTable = new WeakMap();\n    var destinationInsertionPointsTable = new WeakMap();\n    var rendererForHostTable = new WeakMap();\n    function resetDistributedNodes(insertionPoint) {\n      distributedNodesTable.set(insertionPoint, []);\n    }\n    function getDistributedNodes(insertionPoint) {\n      var rv = distributedNodesTable.get(insertionPoint);\n      if (!rv) distributedNodesTable.set(insertionPoint, rv = []);\n      return rv;\n    }\n    function getChildNodesSnapshot(node) {\n      var result = [], i = 0;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        result[i++] = child;\n      }\n      return result;\n    }\n    var request = oneOf(window, [ \"requestAnimationFrame\", \"mozRequestAnimationFrame\", \"webkitRequestAnimationFrame\", \"setTimeout\" ]);\n    var pendingDirtyRenderers = [];\n    var renderTimer;\n    function renderAllPending() {\n      for (var i = 0; i < pendingDirtyRenderers.length; i++) {\n        var renderer = pendingDirtyRenderers[i];\n        var parentRenderer = renderer.parentRenderer;\n        if (parentRenderer && parentRenderer.dirty) continue;\n        renderer.render();\n      }\n      pendingDirtyRenderers = [];\n    }\n    function handleRequestAnimationFrame() {\n      renderTimer = null;\n      renderAllPending();\n    }\n    function getRendererForHost(host) {\n      var renderer = rendererForHostTable.get(host);\n      if (!renderer) {\n        renderer = new ShadowRenderer(host);\n        rendererForHostTable.set(host, renderer);\n      }\n      return renderer;\n    }\n    function getShadowRootAncestor(node) {\n      var root = getTreeScope(node).root;\n      if (root instanceof ShadowRoot) return root;\n      return null;\n    }\n    function getRendererForShadowRoot(shadowRoot) {\n      return getRendererForHost(shadowRoot.host);\n    }\n    var spliceDiff = new ArraySplice();\n    spliceDiff.equals = function(renderNode, rawNode) {\n      return unwrap(renderNode.node) === rawNode;\n    };\n    function RenderNode(node) {\n      this.skip = false;\n      this.node = node;\n      this.childNodes = [];\n    }\n    RenderNode.prototype = {\n      append: function(node) {\n        var rv = new RenderNode(node);\n        this.childNodes.push(rv);\n        return rv;\n      },\n      sync: function(opt_added) {\n        if (this.skip) return;\n        var nodeWrapper = this.node;\n        var newChildren = this.childNodes;\n        var oldChildren = getChildNodesSnapshot(unwrap(nodeWrapper));\n        var added = opt_added || new WeakMap();\n        var splices = spliceDiff.calculateSplices(newChildren, oldChildren);\n        var newIndex = 0, oldIndex = 0;\n        var lastIndex = 0;\n        for (var i = 0; i < splices.length; i++) {\n          var splice = splices[i];\n          for (;lastIndex < splice.index; lastIndex++) {\n            oldIndex++;\n            newChildren[newIndex++].sync(added);\n          }\n          var removedCount = splice.removed.length;\n          for (var j = 0; j < removedCount; j++) {\n            var wrapper = wrap(oldChildren[oldIndex++]);\n            if (!added.get(wrapper)) remove(wrapper);\n          }\n          var addedCount = splice.addedCount;\n          var refNode = oldChildren[oldIndex] && wrap(oldChildren[oldIndex]);\n          for (var j = 0; j < addedCount; j++) {\n            var newChildRenderNode = newChildren[newIndex++];\n            var newChildWrapper = newChildRenderNode.node;\n            insertBefore(nodeWrapper, newChildWrapper, refNode);\n            added.set(newChildWrapper, true);\n            newChildRenderNode.sync(added);\n          }\n          lastIndex += addedCount;\n        }\n        for (var i = lastIndex; i < newChildren.length; i++) {\n          newChildren[i].sync(added);\n        }\n      }\n    };\n    function ShadowRenderer(host) {\n      this.host = host;\n      this.dirty = false;\n      this.invalidateAttributes();\n      this.associateNode(host);\n    }\n    ShadowRenderer.prototype = {\n      render: function(opt_renderNode) {\n        if (!this.dirty) return;\n        this.invalidateAttributes();\n        var host = this.host;\n        this.distribution(host);\n        var renderNode = opt_renderNode || new RenderNode(host);\n        this.buildRenderTree(renderNode, host);\n        var topMostRenderer = !opt_renderNode;\n        if (topMostRenderer) renderNode.sync();\n        this.dirty = false;\n      },\n      get parentRenderer() {\n        return getTreeScope(this.host).renderer;\n      },\n      invalidate: function() {\n        if (!this.dirty) {\n          this.dirty = true;\n          var parentRenderer = this.parentRenderer;\n          if (parentRenderer) parentRenderer.invalidate();\n          pendingDirtyRenderers.push(this);\n          if (renderTimer) return;\n          renderTimer = window[request](handleRequestAnimationFrame, 0);\n        }\n      },\n      distribution: function(root) {\n        this.resetAllSubtrees(root);\n        this.distributionResolution(root);\n      },\n      resetAll: function(node) {\n        if (isInsertionPoint(node)) resetDistributedNodes(node); else resetDestinationInsertionPoints(node);\n        this.resetAllSubtrees(node);\n      },\n      resetAllSubtrees: function(node) {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.resetAll(child);\n        }\n        if (node.shadowRoot) this.resetAll(node.shadowRoot);\n        if (node.olderShadowRoot) this.resetAll(node.olderShadowRoot);\n      },\n      distributionResolution: function(node) {\n        if (isShadowHost(node)) {\n          var shadowHost = node;\n          var pool = poolPopulation(shadowHost);\n          var shadowTrees = getShadowTrees(shadowHost);\n          for (var i = 0; i < shadowTrees.length; i++) {\n            this.poolDistribution(shadowTrees[i], pool);\n          }\n          for (var i = shadowTrees.length - 1; i >= 0; i--) {\n            var shadowTree = shadowTrees[i];\n            var shadow = getShadowInsertionPoint(shadowTree);\n            if (shadow) {\n              var olderShadowRoot = shadowTree.olderShadowRoot;\n              if (olderShadowRoot) {\n                pool = poolPopulation(olderShadowRoot);\n              }\n              for (var j = 0; j < pool.length; j++) {\n                destributeNodeInto(pool[j], shadow);\n              }\n            }\n            this.distributionResolution(shadowTree);\n          }\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.distributionResolution(child);\n        }\n      },\n      poolDistribution: function(node, pool) {\n        if (node instanceof HTMLShadowElement) return;\n        if (node instanceof HTMLContentElement) {\n          var content = node;\n          this.updateDependentAttributes(content.getAttribute(\"select\"));\n          var anyDistributed = false;\n          for (var i = 0; i < pool.length; i++) {\n            var node = pool[i];\n            if (!node) continue;\n            if (matches(node, content)) {\n              destributeNodeInto(node, content);\n              pool[i] = undefined;\n              anyDistributed = true;\n            }\n          }\n          if (!anyDistributed) {\n            for (var child = content.firstChild; child; child = child.nextSibling) {\n              destributeNodeInto(child, content);\n            }\n          }\n          return;\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.poolDistribution(child, pool);\n        }\n      },\n      buildRenderTree: function(renderNode, node) {\n        var children = this.compose(node);\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          var childRenderNode = renderNode.append(child);\n          this.buildRenderTree(childRenderNode, child);\n        }\n        if (isShadowHost(node)) {\n          var renderer = getRendererForHost(node);\n          renderer.dirty = false;\n        }\n      },\n      compose: function(node) {\n        var children = [];\n        var p = node.shadowRoot || node;\n        for (var child = p.firstChild; child; child = child.nextSibling) {\n          if (isInsertionPoint(child)) {\n            this.associateNode(p);\n            var distributedNodes = getDistributedNodes(child);\n            for (var j = 0; j < distributedNodes.length; j++) {\n              var distributedNode = distributedNodes[j];\n              if (isFinalDestination(child, distributedNode)) children.push(distributedNode);\n            }\n          } else {\n            children.push(child);\n          }\n        }\n        return children;\n      },\n      invalidateAttributes: function() {\n        this.attributes = Object.create(null);\n      },\n      updateDependentAttributes: function(selector) {\n        if (!selector) return;\n        var attributes = this.attributes;\n        if (/\\.\\w+/.test(selector)) attributes[\"class\"] = true;\n        if (/#\\w+/.test(selector)) attributes[\"id\"] = true;\n        selector.replace(/\\[\\s*([^\\s=\\|~\\]]+)/g, function(_, name) {\n          attributes[name] = true;\n        });\n      },\n      dependsOnAttribute: function(name) {\n        return this.attributes[name];\n      },\n      associateNode: function(node) {\n        unsafeUnwrap(node).polymerShadowRenderer_ = this;\n      }\n    };\n    function poolPopulation(node) {\n      var pool = [];\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        if (isInsertionPoint(child)) {\n          pool.push.apply(pool, getDistributedNodes(child));\n        } else {\n          pool.push(child);\n        }\n      }\n      return pool;\n    }\n    function getShadowInsertionPoint(node) {\n      if (node instanceof HTMLShadowElement) return node;\n      if (node instanceof HTMLContentElement) return null;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        var res = getShadowInsertionPoint(child);\n        if (res) return res;\n      }\n      return null;\n    }\n    function destributeNodeInto(child, insertionPoint) {\n      getDistributedNodes(insertionPoint).push(child);\n      var points = destinationInsertionPointsTable.get(child);\n      if (!points) destinationInsertionPointsTable.set(child, [ insertionPoint ]); else points.push(insertionPoint);\n    }\n    function getDestinationInsertionPoints(node) {\n      return destinationInsertionPointsTable.get(node);\n    }\n    function resetDestinationInsertionPoints(node) {\n      destinationInsertionPointsTable.set(node, undefined);\n    }\n    var selectorStartCharRe = /^(:not\\()?[*.#[a-zA-Z_|]/;\n    function matches(node, contentElement) {\n      var select = contentElement.getAttribute(\"select\");\n      if (!select) return true;\n      select = select.trim();\n      if (!select) return true;\n      if (!(node instanceof Element)) return false;\n      if (!selectorStartCharRe.test(select)) return false;\n      try {\n        return node.matches(select);\n      } catch (ex) {\n        return false;\n      }\n    }\n    function isFinalDestination(insertionPoint, node) {\n      var points = getDestinationInsertionPoints(node);\n      return points && points[points.length - 1] === insertionPoint;\n    }\n    function isInsertionPoint(node) {\n      return node instanceof HTMLContentElement || node instanceof HTMLShadowElement;\n    }\n    function isShadowHost(shadowHost) {\n      return shadowHost.shadowRoot;\n    }\n    function getShadowTrees(host) {\n      var trees = [];\n      for (var tree = host.shadowRoot; tree; tree = tree.olderShadowRoot) {\n        trees.push(tree);\n      }\n      return trees;\n    }\n    function render(host) {\n      new ShadowRenderer(host).render();\n    }\n    Node.prototype.invalidateShadowRenderer = function(force) {\n      var renderer = unsafeUnwrap(this).polymerShadowRenderer_;\n      if (renderer) {\n        renderer.invalidate();\n        return true;\n      }\n      return false;\n    };\n    HTMLContentElement.prototype.getDistributedNodes = HTMLShadowElement.prototype.getDistributedNodes = function() {\n      renderAllPending();\n      return getDistributedNodes(this);\n    };\n    Element.prototype.getDestinationInsertionPoints = function() {\n      renderAllPending();\n      return getDestinationInsertionPoints(this) || [];\n    };\n    HTMLContentElement.prototype.nodeIsInserted_ = HTMLShadowElement.prototype.nodeIsInserted_ = function() {\n      this.invalidateShadowRenderer();\n      var shadowRoot = getShadowRootAncestor(this);\n      var renderer;\n      if (shadowRoot) renderer = getRendererForShadowRoot(shadowRoot);\n      unsafeUnwrap(this).polymerShadowRenderer_ = renderer;\n      if (renderer) renderer.invalidate();\n    };\n    scope.getRendererForHost = getRendererForHost;\n    scope.getShadowTrees = getShadowTrees;\n    scope.renderAllPending = renderAllPending;\n    scope.getDestinationInsertionPoints = getDestinationInsertionPoints;\n    scope.visual = {\n      insertBefore: insertBefore,\n      remove: remove\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var assert = scope.assert;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var elementsWithFormProperty = [ \"HTMLButtonElement\", \"HTMLFieldSetElement\", \"HTMLInputElement\", \"HTMLKeygenElement\", \"HTMLLabelElement\", \"HTMLLegendElement\", \"HTMLObjectElement\", \"HTMLOutputElement\", \"HTMLTextAreaElement\" ];\n    function createWrapperConstructor(name) {\n      if (!window[name]) return;\n      assert(!scope.wrappers[name]);\n      var GeneratedWrapper = function(node) {\n        HTMLElement.call(this, node);\n      };\n      GeneratedWrapper.prototype = Object.create(HTMLElement.prototype);\n      mixin(GeneratedWrapper.prototype, {\n        get form() {\n          return wrap(unwrap(this).form);\n        }\n      });\n      registerWrapper(window[name], GeneratedWrapper, document.createElement(name.slice(4, -7)));\n      scope.wrappers[name] = GeneratedWrapper;\n    }\n    elementsWithFormProperty.forEach(createWrapperConstructor);\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalSelection = window.Selection;\n    function Selection(impl) {\n      setWrapper(impl, this);\n    }\n    Selection.prototype = {\n      get anchorNode() {\n        return wrap(unsafeUnwrap(this).anchorNode);\n      },\n      get focusNode() {\n        return wrap(unsafeUnwrap(this).focusNode);\n      },\n      addRange: function(range) {\n        unsafeUnwrap(this).addRange(unwrapIfNeeded(range));\n      },\n      collapse: function(node, index) {\n        unsafeUnwrap(this).collapse(unwrapIfNeeded(node), index);\n      },\n      containsNode: function(node, allowPartial) {\n        return unsafeUnwrap(this).containsNode(unwrapIfNeeded(node), allowPartial);\n      },\n      getRangeAt: function(index) {\n        return wrap(unsafeUnwrap(this).getRangeAt(index));\n      },\n      removeRange: function(range) {\n        unsafeUnwrap(this).removeRange(unwrap(range));\n      },\n      selectAllChildren: function(node) {\n        unsafeUnwrap(this).selectAllChildren(node instanceof ShadowRoot ? unsafeUnwrap(node.host) : unwrapIfNeeded(node));\n      },\n      toString: function() {\n        return unsafeUnwrap(this).toString();\n      }\n    };\n    if (OriginalSelection.prototype.extend) {\n      Selection.prototype.extend = function(node, offset) {\n        unsafeUnwrap(this).extend(unwrapIfNeeded(node), offset);\n      };\n    }\n    registerWrapper(window.Selection, Selection, window.getSelection());\n    scope.wrappers.Selection = Selection;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalTreeWalker = window.TreeWalker;\n    function TreeWalker(impl) {\n      setWrapper(impl, this);\n    }\n    TreeWalker.prototype = {\n      get root() {\n        return wrap(unsafeUnwrap(this).root);\n      },\n      get currentNode() {\n        return wrap(unsafeUnwrap(this).currentNode);\n      },\n      set currentNode(node) {\n        unsafeUnwrap(this).currentNode = unwrapIfNeeded(node);\n      },\n      get filter() {\n        return unsafeUnwrap(this).filter;\n      },\n      parentNode: function() {\n        return wrap(unsafeUnwrap(this).parentNode());\n      },\n      firstChild: function() {\n        return wrap(unsafeUnwrap(this).firstChild());\n      },\n      lastChild: function() {\n        return wrap(unsafeUnwrap(this).lastChild());\n      },\n      previousSibling: function() {\n        return wrap(unsafeUnwrap(this).previousSibling());\n      },\n      previousNode: function() {\n        return wrap(unsafeUnwrap(this).previousNode());\n      },\n      nextNode: function() {\n        return wrap(unsafeUnwrap(this).nextNode());\n      }\n    };\n    registerWrapper(OriginalTreeWalker, TreeWalker);\n    scope.wrappers.TreeWalker = TreeWalker;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var Node = scope.wrappers.Node;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\n    var Selection = scope.wrappers.Selection;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    var TreeScope = scope.TreeScope;\n    var cloneNode = scope.cloneNode;\n    var defineGetter = scope.defineGetter;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var elementFromPoint = scope.elementFromPoint;\n    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n    var matchesNames = scope.matchesNames;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var renderAllPending = scope.renderAllPending;\n    var rewrap = scope.rewrap;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrapEventTargetMethods = scope.wrapEventTargetMethods;\n    var wrapNodeList = scope.wrapNodeList;\n    var implementationTable = new WeakMap();\n    function Document(node) {\n      Node.call(this, node);\n      this.treeScope_ = new TreeScope(this, null);\n    }\n    Document.prototype = Object.create(Node.prototype);\n    defineWrapGetter(Document, \"documentElement\");\n    defineWrapGetter(Document, \"body\");\n    defineWrapGetter(Document, \"head\");\n    defineGetter(Document, \"activeElement\", function() {\n      var unwrappedActiveElement = unwrap(this).activeElement;\n      if (!unwrappedActiveElement || !unwrappedActiveElement.nodeType) return null;\n      var activeElement = wrap(unwrappedActiveElement);\n      while (!this.contains(activeElement)) {\n        while (activeElement.parentNode) {\n          activeElement = activeElement.parentNode;\n        }\n        if (activeElement.host) {\n          activeElement = activeElement.host;\n        } else {\n          return null;\n        }\n      }\n      return activeElement;\n    });\n    function wrapMethod(name) {\n      var original = document[name];\n      Document.prototype[name] = function() {\n        return wrap(original.apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    [ \"createComment\", \"createDocumentFragment\", \"createElement\", \"createElementNS\", \"createEvent\", \"createEventNS\", \"createRange\", \"createTextNode\" ].forEach(wrapMethod);\n    var originalAdoptNode = document.adoptNode;\n    function adoptNodeNoRemove(node, doc) {\n      originalAdoptNode.call(unsafeUnwrap(doc), unwrap(node));\n      adoptSubtree(node, doc);\n    }\n    function adoptSubtree(node, doc) {\n      if (node.shadowRoot) doc.adoptNode(node.shadowRoot);\n      if (node instanceof ShadowRoot) adoptOlderShadowRoots(node, doc);\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        adoptSubtree(child, doc);\n      }\n    }\n    function adoptOlderShadowRoots(shadowRoot, doc) {\n      var oldShadowRoot = shadowRoot.olderShadowRoot;\n      if (oldShadowRoot) doc.adoptNode(oldShadowRoot);\n    }\n    var originalGetSelection = document.getSelection;\n    mixin(Document.prototype, {\n      adoptNode: function(node) {\n        if (node.parentNode) node.parentNode.removeChild(node);\n        adoptNodeNoRemove(node, this);\n        return node;\n      },\n      elementFromPoint: function(x, y) {\n        return elementFromPoint(this, this, x, y);\n      },\n      importNode: function(node, deep) {\n        return cloneNode(node, deep, unsafeUnwrap(this));\n      },\n      getSelection: function() {\n        renderAllPending();\n        return new Selection(originalGetSelection.call(unwrap(this)));\n      },\n      getElementsByName: function(name) {\n        return SelectorsInterface.querySelectorAll.call(this, \"[name=\" + JSON.stringify(String(name)) + \"]\");\n      }\n    });\n    var originalCreateTreeWalker = document.createTreeWalker;\n    var TreeWalkerWrapper = scope.wrappers.TreeWalker;\n    Document.prototype.createTreeWalker = function(root, whatToShow, filter, expandEntityReferences) {\n      var newFilter = null;\n      if (filter) {\n        if (filter.acceptNode && typeof filter.acceptNode === \"function\") {\n          newFilter = {\n            acceptNode: function(node) {\n              return filter.acceptNode(wrap(node));\n            }\n          };\n        } else if (typeof filter === \"function\") {\n          newFilter = function(node) {\n            return filter(wrap(node));\n          };\n        }\n      }\n      return new TreeWalkerWrapper(originalCreateTreeWalker.call(unwrap(this), unwrap(root), whatToShow, newFilter, expandEntityReferences));\n    };\n    if (document.registerElement) {\n      var originalRegisterElement = document.registerElement;\n      Document.prototype.registerElement = function(tagName, object) {\n        var prototype, extendsOption;\n        if (object !== undefined) {\n          prototype = object.prototype;\n          extendsOption = object.extends;\n        }\n        if (!prototype) prototype = Object.create(HTMLElement.prototype);\n        if (scope.nativePrototypeTable.get(prototype)) {\n          throw new Error(\"NotSupportedError\");\n        }\n        var proto = Object.getPrototypeOf(prototype);\n        var nativePrototype;\n        var prototypes = [];\n        while (proto) {\n          nativePrototype = scope.nativePrototypeTable.get(proto);\n          if (nativePrototype) break;\n          prototypes.push(proto);\n          proto = Object.getPrototypeOf(proto);\n        }\n        if (!nativePrototype) {\n          throw new Error(\"NotSupportedError\");\n        }\n        var newPrototype = Object.create(nativePrototype);\n        for (var i = prototypes.length - 1; i >= 0; i--) {\n          newPrototype = Object.create(newPrototype);\n        }\n        [ \"createdCallback\", \"attachedCallback\", \"detachedCallback\", \"attributeChangedCallback\" ].forEach(function(name) {\n          var f = prototype[name];\n          if (!f) return;\n          newPrototype[name] = function() {\n            if (!(wrap(this) instanceof CustomElementConstructor)) {\n              rewrap(this);\n            }\n            f.apply(wrap(this), arguments);\n          };\n        });\n        var p = {\n          prototype: newPrototype\n        };\n        if (extendsOption) p.extends = extendsOption;\n        function CustomElementConstructor(node) {\n          if (!node) {\n            if (extendsOption) {\n              return document.createElement(extendsOption, tagName);\n            } else {\n              return document.createElement(tagName);\n            }\n          }\n          setWrapper(node, this);\n        }\n        CustomElementConstructor.prototype = prototype;\n        CustomElementConstructor.prototype.constructor = CustomElementConstructor;\n        scope.constructorTable.set(newPrototype, CustomElementConstructor);\n        scope.nativePrototypeTable.set(prototype, newPrototype);\n        var nativeConstructor = originalRegisterElement.call(unwrap(this), tagName, p);\n        return CustomElementConstructor;\n      };\n      forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ \"registerElement\" ]);\n    }\n    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement, window.HTMLHtmlElement ], [ \"appendChild\", \"compareDocumentPosition\", \"contains\", \"getElementsByClassName\", \"getElementsByTagName\", \"getElementsByTagNameNS\", \"insertBefore\", \"querySelector\", \"querySelectorAll\", \"removeChild\", \"replaceChild\" ]);\n    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLHeadElement, window.HTMLHtmlElement ], matchesNames);\n    forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ \"adoptNode\", \"importNode\", \"contains\", \"createComment\", \"createDocumentFragment\", \"createElement\", \"createElementNS\", \"createEvent\", \"createEventNS\", \"createRange\", \"createTextNode\", \"createTreeWalker\", \"elementFromPoint\", \"getElementById\", \"getElementsByName\", \"getSelection\" ]);\n    mixin(Document.prototype, GetElementsByInterface);\n    mixin(Document.prototype, ParentNodeInterface);\n    mixin(Document.prototype, SelectorsInterface);\n    mixin(Document.prototype, NonElementParentNodeInterface);\n    mixin(Document.prototype, {\n      get implementation() {\n        var implementation = implementationTable.get(this);\n        if (implementation) return implementation;\n        implementation = new DOMImplementation(unwrap(this).implementation);\n        implementationTable.set(this, implementation);\n        return implementation;\n      },\n      get defaultView() {\n        return wrap(unwrap(this).defaultView);\n      }\n    });\n    registerWrapper(window.Document, Document, document.implementation.createHTMLDocument(\"\"));\n    if (window.HTMLDocument) registerWrapper(window.HTMLDocument, Document);\n    wrapEventTargetMethods([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement ]);\n    function DOMImplementation(impl) {\n      setWrapper(impl, this);\n    }\n    var originalCreateDocument = document.implementation.createDocument;\n    DOMImplementation.prototype.createDocument = function() {\n      arguments[2] = unwrap(arguments[2]);\n      return wrap(originalCreateDocument.apply(unsafeUnwrap(this), arguments));\n    };\n    function wrapImplMethod(constructor, name) {\n      var original = document.implementation[name];\n      constructor.prototype[name] = function() {\n        return wrap(original.apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    function forwardImplMethod(constructor, name) {\n      var original = document.implementation[name];\n      constructor.prototype[name] = function() {\n        return original.apply(unsafeUnwrap(this), arguments);\n      };\n    }\n    wrapImplMethod(DOMImplementation, \"createDocumentType\");\n    wrapImplMethod(DOMImplementation, \"createHTMLDocument\");\n    forwardImplMethod(DOMImplementation, \"hasFeature\");\n    registerWrapper(window.DOMImplementation, DOMImplementation);\n    forwardMethodsToWrapper([ window.DOMImplementation ], [ \"createDocument\", \"createDocumentType\", \"createHTMLDocument\", \"hasFeature\" ]);\n    scope.adoptNodeNoRemove = adoptNodeNoRemove;\n    scope.wrappers.DOMImplementation = DOMImplementation;\n    scope.wrappers.Document = Document;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var EventTarget = scope.wrappers.EventTarget;\n    var Selection = scope.wrappers.Selection;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var renderAllPending = scope.renderAllPending;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalWindow = window.Window;\n    var originalGetComputedStyle = window.getComputedStyle;\n    var originalGetDefaultComputedStyle = window.getDefaultComputedStyle;\n    var originalGetSelection = window.getSelection;\n    function Window(impl) {\n      EventTarget.call(this, impl);\n    }\n    Window.prototype = Object.create(EventTarget.prototype);\n    OriginalWindow.prototype.getComputedStyle = function(el, pseudo) {\n      return wrap(this || window).getComputedStyle(unwrapIfNeeded(el), pseudo);\n    };\n    if (originalGetDefaultComputedStyle) {\n      OriginalWindow.prototype.getDefaultComputedStyle = function(el, pseudo) {\n        return wrap(this || window).getDefaultComputedStyle(unwrapIfNeeded(el), pseudo);\n      };\n    }\n    OriginalWindow.prototype.getSelection = function() {\n      return wrap(this || window).getSelection();\n    };\n    delete window.getComputedStyle;\n    delete window.getDefaultComputedStyle;\n    delete window.getSelection;\n    [ \"addEventListener\", \"removeEventListener\", \"dispatchEvent\" ].forEach(function(name) {\n      OriginalWindow.prototype[name] = function() {\n        var w = wrap(this || window);\n        return w[name].apply(w, arguments);\n      };\n      delete window[name];\n    });\n    mixin(Window.prototype, {\n      getComputedStyle: function(el, pseudo) {\n        renderAllPending();\n        return originalGetComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\n      },\n      getSelection: function() {\n        renderAllPending();\n        return new Selection(originalGetSelection.call(unwrap(this)));\n      },\n      get document() {\n        return wrap(unwrap(this).document);\n      }\n    });\n    if (originalGetDefaultComputedStyle) {\n      Window.prototype.getDefaultComputedStyle = function(el, pseudo) {\n        renderAllPending();\n        return originalGetDefaultComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\n      };\n    }\n    registerWrapper(OriginalWindow, Window, window);\n    scope.wrappers.Window = Window;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var unwrap = scope.unwrap;\n    var OriginalDataTransfer = window.DataTransfer || window.Clipboard;\n    var OriginalDataTransferSetDragImage = OriginalDataTransfer.prototype.setDragImage;\n    if (OriginalDataTransferSetDragImage) {\n      OriginalDataTransfer.prototype.setDragImage = function(image, x, y) {\n        OriginalDataTransferSetDragImage.call(this, unwrap(image), x, y);\n      };\n    }\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unwrap = scope.unwrap;\n    var OriginalFormData = window.FormData;\n    if (!OriginalFormData) return;\n    function FormData(formElement) {\n      var impl;\n      if (formElement instanceof OriginalFormData) {\n        impl = formElement;\n      } else {\n        impl = new OriginalFormData(formElement && unwrap(formElement));\n      }\n      setWrapper(impl, this);\n    }\n    registerWrapper(OriginalFormData, FormData, new OriginalFormData());\n    scope.wrappers.FormData = FormData;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var originalSend = XMLHttpRequest.prototype.send;\n    XMLHttpRequest.prototype.send = function(obj) {\n      return originalSend.call(this, unwrapIfNeeded(obj));\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var isWrapperFor = scope.isWrapperFor;\n    var elements = {\n      a: \"HTMLAnchorElement\",\n      area: \"HTMLAreaElement\",\n      audio: \"HTMLAudioElement\",\n      base: \"HTMLBaseElement\",\n      body: \"HTMLBodyElement\",\n      br: \"HTMLBRElement\",\n      button: \"HTMLButtonElement\",\n      canvas: \"HTMLCanvasElement\",\n      caption: \"HTMLTableCaptionElement\",\n      col: \"HTMLTableColElement\",\n      content: \"HTMLContentElement\",\n      data: \"HTMLDataElement\",\n      datalist: \"HTMLDataListElement\",\n      del: \"HTMLModElement\",\n      dir: \"HTMLDirectoryElement\",\n      div: \"HTMLDivElement\",\n      dl: \"HTMLDListElement\",\n      embed: \"HTMLEmbedElement\",\n      fieldset: \"HTMLFieldSetElement\",\n      font: \"HTMLFontElement\",\n      form: \"HTMLFormElement\",\n      frame: \"HTMLFrameElement\",\n      frameset: \"HTMLFrameSetElement\",\n      h1: \"HTMLHeadingElement\",\n      head: \"HTMLHeadElement\",\n      hr: \"HTMLHRElement\",\n      html: \"HTMLHtmlElement\",\n      iframe: \"HTMLIFrameElement\",\n      img: \"HTMLImageElement\",\n      input: \"HTMLInputElement\",\n      keygen: \"HTMLKeygenElement\",\n      label: \"HTMLLabelElement\",\n      legend: \"HTMLLegendElement\",\n      li: \"HTMLLIElement\",\n      link: \"HTMLLinkElement\",\n      map: \"HTMLMapElement\",\n      marquee: \"HTMLMarqueeElement\",\n      menu: \"HTMLMenuElement\",\n      menuitem: \"HTMLMenuItemElement\",\n      meta: \"HTMLMetaElement\",\n      meter: \"HTMLMeterElement\",\n      object: \"HTMLObjectElement\",\n      ol: \"HTMLOListElement\",\n      optgroup: \"HTMLOptGroupElement\",\n      option: \"HTMLOptionElement\",\n      output: \"HTMLOutputElement\",\n      p: \"HTMLParagraphElement\",\n      param: \"HTMLParamElement\",\n      pre: \"HTMLPreElement\",\n      progress: \"HTMLProgressElement\",\n      q: \"HTMLQuoteElement\",\n      script: \"HTMLScriptElement\",\n      select: \"HTMLSelectElement\",\n      shadow: \"HTMLShadowElement\",\n      source: \"HTMLSourceElement\",\n      span: \"HTMLSpanElement\",\n      style: \"HTMLStyleElement\",\n      table: \"HTMLTableElement\",\n      tbody: \"HTMLTableSectionElement\",\n      template: \"HTMLTemplateElement\",\n      textarea: \"HTMLTextAreaElement\",\n      thead: \"HTMLTableSectionElement\",\n      time: \"HTMLTimeElement\",\n      title: \"HTMLTitleElement\",\n      tr: \"HTMLTableRowElement\",\n      track: \"HTMLTrackElement\",\n      ul: \"HTMLUListElement\",\n      video: \"HTMLVideoElement\"\n    };\n    function overrideConstructor(tagName) {\n      var nativeConstructorName = elements[tagName];\n      var nativeConstructor = window[nativeConstructorName];\n      if (!nativeConstructor) return;\n      var element = document.createElement(tagName);\n      var wrapperConstructor = element.constructor;\n      window[nativeConstructorName] = wrapperConstructor;\n    }\n    Object.keys(elements).forEach(overrideConstructor);\n    Object.getOwnPropertyNames(scope.wrappers).forEach(function(name) {\n      window[name] = scope.wrappers[name];\n    });\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    var ShadowCSS = {\n      strictStyling: false,\n      registry: {},\n      shimStyling: function(root, name, extendsName) {\n        var scopeStyles = this.prepareRoot(root, name, extendsName);\n        var typeExtension = this.isTypeExtension(extendsName);\n        var scopeSelector = this.makeScopeSelector(name, typeExtension);\n        var cssText = stylesToCssText(scopeStyles, true);\n        cssText = this.scopeCssText(cssText, scopeSelector);\n        if (root) {\n          root.shimmedStyle = cssText;\n        }\n        this.addCssToDocument(cssText, name);\n      },\n      shimStyle: function(style, selector) {\n        return this.shimCssText(style.textContent, selector);\n      },\n      shimCssText: function(cssText, selector) {\n        cssText = this.insertDirectives(cssText);\n        return this.scopeCssText(cssText, selector);\n      },\n      makeScopeSelector: function(name, typeExtension) {\n        if (name) {\n          return typeExtension ? \"[is=\" + name + \"]\" : name;\n        }\n        return \"\";\n      },\n      isTypeExtension: function(extendsName) {\n        return extendsName && extendsName.indexOf(\"-\") < 0;\n      },\n      prepareRoot: function(root, name, extendsName) {\n        var def = this.registerRoot(root, name, extendsName);\n        this.replaceTextInStyles(def.rootStyles, this.insertDirectives);\n        this.removeStyles(root, def.rootStyles);\n        if (this.strictStyling) {\n          this.applyScopeToContent(root, name);\n        }\n        return def.scopeStyles;\n      },\n      removeStyles: function(root, styles) {\n        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {\n          s.parentNode.removeChild(s);\n        }\n      },\n      registerRoot: function(root, name, extendsName) {\n        var def = this.registry[name] = {\n          root: root,\n          name: name,\n          extendsName: extendsName\n        };\n        var styles = this.findStyles(root);\n        def.rootStyles = styles;\n        def.scopeStyles = def.rootStyles;\n        var extendee = this.registry[def.extendsName];\n        if (extendee) {\n          def.scopeStyles = extendee.scopeStyles.concat(def.scopeStyles);\n        }\n        return def;\n      },\n      findStyles: function(root) {\n        if (!root) {\n          return [];\n        }\n        var styles = root.querySelectorAll(\"style\");\n        return Array.prototype.filter.call(styles, function(s) {\n          return !s.hasAttribute(NO_SHIM_ATTRIBUTE);\n        });\n      },\n      applyScopeToContent: function(root, name) {\n        if (root) {\n          Array.prototype.forEach.call(root.querySelectorAll(\"*\"), function(node) {\n            node.setAttribute(name, \"\");\n          });\n          Array.prototype.forEach.call(root.querySelectorAll(\"template\"), function(template) {\n            this.applyScopeToContent(template.content, name);\n          }, this);\n        }\n      },\n      insertDirectives: function(cssText) {\n        cssText = this.insertPolyfillDirectivesInCssText(cssText);\n        return this.insertPolyfillRulesInCssText(cssText);\n      },\n      insertPolyfillDirectivesInCssText: function(cssText) {\n        cssText = cssText.replace(cssCommentNextSelectorRe, function(match, p1) {\n          return p1.slice(0, -2) + \"{\";\n        });\n        return cssText.replace(cssContentNextSelectorRe, function(match, p1) {\n          return p1 + \" {\";\n        });\n      },\n      insertPolyfillRulesInCssText: function(cssText) {\n        cssText = cssText.replace(cssCommentRuleRe, function(match, p1) {\n          return p1.slice(0, -1);\n        });\n        return cssText.replace(cssContentRuleRe, function(match, p1, p2, p3) {\n          var rule = match.replace(p1, \"\").replace(p2, \"\");\n          return p3 + rule;\n        });\n      },\n      scopeCssText: function(cssText, scopeSelector) {\n        var unscoped = this.extractUnscopedRulesFromCssText(cssText);\n        cssText = this.insertPolyfillHostInCssText(cssText);\n        cssText = this.convertColonHost(cssText);\n        cssText = this.convertColonHostContext(cssText);\n        cssText = this.convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n          var self = this, cssText;\n          withCssRules(cssText, function(rules) {\n            cssText = self.scopeRules(rules, scopeSelector);\n          });\n        }\n        cssText = cssText + \"\\n\" + unscoped;\n        return cssText.trim();\n      },\n      extractUnscopedRulesFromCssText: function(cssText) {\n        var r = \"\", m;\n        while (m = cssCommentUnscopedRuleRe.exec(cssText)) {\n          r += m[1].slice(0, -1) + \"\\n\\n\";\n        }\n        while (m = cssContentUnscopedRuleRe.exec(cssText)) {\n          r += m[0].replace(m[2], \"\").replace(m[1], m[3]) + \"\\n\\n\";\n        }\n        return r;\n      },\n      convertColonHost: function(cssText) {\n        return this.convertColonRule(cssText, cssColonHostRe, this.colonHostPartReplacer);\n      },\n      convertColonHostContext: function(cssText) {\n        return this.convertColonRule(cssText, cssColonHostContextRe, this.colonHostContextPartReplacer);\n      },\n      convertColonRule: function(cssText, regExp, partReplacer) {\n        return cssText.replace(regExp, function(m, p1, p2, p3) {\n          p1 = polyfillHostNoCombinator;\n          if (p2) {\n            var parts = p2.split(\",\"), r = [];\n            for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {\n              p = p.trim();\n              r.push(partReplacer(p1, p, p3));\n            }\n            return r.join(\",\");\n          } else {\n            return p1 + p3;\n          }\n        });\n      },\n      colonHostContextPartReplacer: function(host, part, suffix) {\n        if (part.match(polyfillHost)) {\n          return this.colonHostPartReplacer(host, part, suffix);\n        } else {\n          return host + part + suffix + \", \" + part + \" \" + host + suffix;\n        }\n      },\n      colonHostPartReplacer: function(host, part, suffix) {\n        return host + part.replace(polyfillHost, \"\") + suffix;\n      },\n      convertShadowDOMSelectors: function(cssText) {\n        for (var i = 0; i < shadowDOMSelectorsRe.length; i++) {\n          cssText = cssText.replace(shadowDOMSelectorsRe[i], \" \");\n        }\n        return cssText;\n      },\n      scopeRules: function(cssRules, scopeSelector) {\n        var cssText = \"\";\n        if (cssRules) {\n          Array.prototype.forEach.call(cssRules, function(rule) {\n            if (rule.selectorText && (rule.style && rule.style.cssText !== undefined)) {\n              cssText += this.scopeSelector(rule.selectorText, scopeSelector, this.strictStyling) + \" {\\n\t\";\n              cssText += this.propertiesFromRule(rule) + \"\\n}\\n\\n\";\n            } else if (rule.type === CSSRule.MEDIA_RULE) {\n              cssText += \"@media \" + rule.media.mediaText + \" {\\n\";\n              cssText += this.scopeRules(rule.cssRules, scopeSelector);\n              cssText += \"\\n}\\n\\n\";\n            } else {\n              try {\n                if (rule.cssText) {\n                  cssText += rule.cssText + \"\\n\\n\";\n                }\n              } catch (x) {\n                if (rule.type === CSSRule.KEYFRAMES_RULE && rule.cssRules) {\n                  cssText += this.ieSafeCssTextFromKeyFrameRule(rule);\n                }\n              }\n            }\n          }, this);\n        }\n        return cssText;\n      },\n      ieSafeCssTextFromKeyFrameRule: function(rule) {\n        var cssText = \"@keyframes \" + rule.name + \" {\";\n        Array.prototype.forEach.call(rule.cssRules, function(rule) {\n          cssText += \" \" + rule.keyText + \" {\" + rule.style.cssText + \"}\";\n        });\n        cssText += \" }\";\n        return cssText;\n      },\n      scopeSelector: function(selector, scopeSelector, strict) {\n        var r = [], parts = selector.split(\",\");\n        parts.forEach(function(p) {\n          p = p.trim();\n          if (this.selectorNeedsScoping(p, scopeSelector)) {\n            p = strict && !p.match(polyfillHostNoCombinator) ? this.applyStrictSelectorScope(p, scopeSelector) : this.applySelectorScope(p, scopeSelector);\n          }\n          r.push(p);\n        }, this);\n        return r.join(\", \");\n      },\n      selectorNeedsScoping: function(selector, scopeSelector) {\n        if (Array.isArray(scopeSelector)) {\n          return true;\n        }\n        var re = this.makeScopeMatcher(scopeSelector);\n        return !selector.match(re);\n      },\n      makeScopeMatcher: function(scopeSelector) {\n        scopeSelector = scopeSelector.replace(/\\[/g, \"\\\\[\").replace(/\\]/g, \"\\\\]\");\n        return new RegExp(\"^(\" + scopeSelector + \")\" + selectorReSuffix, \"m\");\n      },\n      applySelectorScope: function(selector, selectorScope) {\n        return Array.isArray(selectorScope) ? this.applySelectorScopeList(selector, selectorScope) : this.applySimpleSelectorScope(selector, selectorScope);\n      },\n      applySelectorScopeList: function(selector, scopeSelectorList) {\n        var r = [];\n        for (var i = 0, s; s = scopeSelectorList[i]; i++) {\n          r.push(this.applySimpleSelectorScope(selector, s));\n        }\n        return r.join(\", \");\n      },\n      applySimpleSelectorScope: function(selector, scopeSelector) {\n        if (selector.match(polyfillHostRe)) {\n          selector = selector.replace(polyfillHostNoCombinator, scopeSelector);\n          return selector.replace(polyfillHostRe, scopeSelector + \" \");\n        } else {\n          return scopeSelector + \" \" + selector;\n        }\n      },\n      applyStrictSelectorScope: function(selector, scopeSelector) {\n        scopeSelector = scopeSelector.replace(/\\[is=([^\\]]*)\\]/g, \"$1\");\n        var splits = [ \" \", \">\", \"+\", \"~\" ], scoped = selector, attrName = \"[\" + scopeSelector + \"]\";\n        splits.forEach(function(sep) {\n          var parts = scoped.split(sep);\n          scoped = parts.map(function(p) {\n            var t = p.trim().replace(polyfillHostRe, \"\");\n            if (t && splits.indexOf(t) < 0 && t.indexOf(attrName) < 0) {\n              p = t.replace(/([^:]*)(:*)(.*)/, \"$1\" + attrName + \"$2$3\");\n            }\n            return p;\n          }).join(sep);\n        });\n        return scoped;\n      },\n      insertPolyfillHostInCssText: function(selector) {\n        return selector.replace(colonHostContextRe, polyfillHostContext).replace(colonHostRe, polyfillHost);\n      },\n      propertiesFromRule: function(rule) {\n        var cssText = rule.style.cssText;\n        if (rule.style.content && !rule.style.content.match(/['\"]+|attr/)) {\n          cssText = cssText.replace(/content:[^;]*;/g, \"content: '\" + rule.style.content + \"';\");\n        }\n        var style = rule.style;\n        for (var i in style) {\n          if (style[i] === \"initial\") {\n            cssText += i + \": initial; \";\n          }\n        }\n        return cssText;\n      },\n      replaceTextInStyles: function(styles, action) {\n        if (styles && action) {\n          if (!(styles instanceof Array)) {\n            styles = [ styles ];\n          }\n          Array.prototype.forEach.call(styles, function(s) {\n            s.textContent = action.call(this, s.textContent);\n          }, this);\n        }\n      },\n      addCssToDocument: function(cssText, name) {\n        if (cssText.match(\"@import\")) {\n          addOwnSheet(cssText, name);\n        } else {\n          addCssToDocument(cssText);\n        }\n      }\n    };\n    var selectorRe = /([^{]*)({[\\s\\S]*?})/gim, cssCommentRe = /\\/\\*[^*]*\\*+([^\\/*][^*]*\\*+)*\\//gim, cssCommentNextSelectorRe = /\\/\\*\\s*@polyfill ([^*]*\\*+([^\\/*][^*]*\\*+)*\\/)([^{]*?){/gim, cssContentNextSelectorRe = /polyfill-next-selector[^}]*content\\:[\\s]*?['\"](.*?)['\"][;\\s]*}([^{]*?){/gim, cssCommentRuleRe = /\\/\\*\\s@polyfill-rule([^*]*\\*+([^\\/*][^*]*\\*+)*)\\//gim, cssContentRuleRe = /(polyfill-rule)[^}]*(content\\:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim, cssCommentUnscopedRuleRe = /\\/\\*\\s@polyfill-unscoped-rule([^*]*\\*+([^\\/*][^*]*\\*+)*)\\//gim, cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content\\:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim, cssPseudoRe = /::(x-[^\\s{,(]*)/gim, cssPartRe = /::part\\(([^)]*)\\)/gim, polyfillHost = \"-shadowcsshost\", polyfillHostContext = \"-shadowcsscontext\", parenSuffix = \")(?:\\\\((\" + \"(?:\\\\([^)(]*\\\\)|[^)(]*)+?\" + \")\\\\))?([^,{]*)\";\n    var cssColonHostRe = new RegExp(\"(\" + polyfillHost + parenSuffix, \"gim\"), cssColonHostContextRe = new RegExp(\"(\" + polyfillHostContext + parenSuffix, \"gim\"), selectorReSuffix = \"([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$\", colonHostRe = /\\:host/gim, colonHostContextRe = /\\:host-context/gim, polyfillHostNoCombinator = polyfillHost + \"-no-combinator\", polyfillHostRe = new RegExp(polyfillHost, \"gim\"), polyfillHostContextRe = new RegExp(polyfillHostContext, \"gim\"), shadowDOMSelectorsRe = [ />>>/g, /::shadow/g, /::content/g, /\\/deep\\//g, /\\/shadow\\//g, /\\/shadow-deep\\//g, /\\^\\^/g, /\\^/g ];\n    function stylesToCssText(styles, preserveComments) {\n      var cssText = \"\";\n      Array.prototype.forEach.call(styles, function(s) {\n        cssText += s.textContent + \"\\n\\n\";\n      });\n      if (!preserveComments) {\n        cssText = cssText.replace(cssCommentRe, \"\");\n      }\n      return cssText;\n    }\n    function cssTextToStyle(cssText) {\n      var style = document.createElement(\"style\");\n      style.textContent = cssText;\n      return style;\n    }\n    function cssToRules(cssText) {\n      var style = cssTextToStyle(cssText);\n      document.head.appendChild(style);\n      var rules = [];\n      if (style.sheet) {\n        try {\n          rules = style.sheet.cssRules;\n        } catch (e) {}\n      } else {\n        console.warn(\"sheet not found\", style);\n      }\n      style.parentNode.removeChild(style);\n      return rules;\n    }\n    var frame = document.createElement(\"iframe\");\n    frame.style.display = \"none\";\n    function initFrame() {\n      frame.initialized = true;\n      document.body.appendChild(frame);\n      var doc = frame.contentDocument;\n      var base = doc.createElement(\"base\");\n      base.href = document.baseURI;\n      doc.head.appendChild(base);\n    }\n    function inFrame(fn) {\n      if (!frame.initialized) {\n        initFrame();\n      }\n      document.body.appendChild(frame);\n      fn(frame.contentDocument);\n      document.body.removeChild(frame);\n    }\n    var isChrome = navigator.userAgent.match(\"Chrome\");\n    function withCssRules(cssText, callback) {\n      if (!callback) {\n        return;\n      }\n      var rules;\n      if (cssText.match(\"@import\") && isChrome) {\n        var style = cssTextToStyle(cssText);\n        inFrame(function(doc) {\n          doc.head.appendChild(style.impl);\n          rules = Array.prototype.slice.call(style.sheet.cssRules, 0);\n          callback(rules);\n        });\n      } else {\n        rules = cssToRules(cssText);\n        callback(rules);\n      }\n    }\n    function rulesToCss(cssRules) {\n      for (var i = 0, css = []; i < cssRules.length; i++) {\n        css.push(cssRules[i].cssText);\n      }\n      return css.join(\"\\n\\n\");\n    }\n    function addCssToDocument(cssText) {\n      if (cssText) {\n        getSheet().appendChild(document.createTextNode(cssText));\n      }\n    }\n    function addOwnSheet(cssText, name) {\n      var style = cssTextToStyle(cssText);\n      style.setAttribute(name, \"\");\n      style.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n      document.head.appendChild(style);\n    }\n    var SHIM_ATTRIBUTE = \"shim-shadowdom\";\n    var SHIMMED_ATTRIBUTE = \"shim-shadowdom-css\";\n    var NO_SHIM_ATTRIBUTE = \"no-shim\";\n    var sheet;\n    function getSheet() {\n      if (!sheet) {\n        sheet = document.createElement(\"style\");\n        sheet.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n        sheet[SHIMMED_ATTRIBUTE] = true;\n      }\n      return sheet;\n    }\n    if (window.ShadowDOMPolyfill) {\n      addCssToDocument(\"style { display: none !important; }\\n\");\n      var doc = ShadowDOMPolyfill.wrap(document);\n      var head = doc.querySelector(\"head\");\n      head.insertBefore(getSheet(), head.childNodes[0]);\n      document.addEventListener(\"DOMContentLoaded\", function() {\n        var urlResolver = scope.urlResolver;\n        if (window.HTMLImports && !HTMLImports.useNative) {\n          var SHIM_SHEET_SELECTOR = \"link[rel=stylesheet]\" + \"[\" + SHIM_ATTRIBUTE + \"]\";\n          var SHIM_STYLE_SELECTOR = \"style[\" + SHIM_ATTRIBUTE + \"]\";\n          HTMLImports.importer.documentPreloadSelectors += \",\" + SHIM_SHEET_SELECTOR;\n          HTMLImports.importer.importsPreloadSelectors += \",\" + SHIM_SHEET_SELECTOR;\n          HTMLImports.parser.documentSelectors = [ HTMLImports.parser.documentSelectors, SHIM_SHEET_SELECTOR, SHIM_STYLE_SELECTOR ].join(\",\");\n          var originalParseGeneric = HTMLImports.parser.parseGeneric;\n          HTMLImports.parser.parseGeneric = function(elt) {\n            if (elt[SHIMMED_ATTRIBUTE]) {\n              return;\n            }\n            var style = elt.__importElement || elt;\n            if (!style.hasAttribute(SHIM_ATTRIBUTE)) {\n              originalParseGeneric.call(this, elt);\n              return;\n            }\n            if (elt.__resource) {\n              style = elt.ownerDocument.createElement(\"style\");\n              style.textContent = elt.__resource;\n            }\n            HTMLImports.path.resolveUrlsInStyle(style, elt.href);\n            style.textContent = ShadowCSS.shimStyle(style);\n            style.removeAttribute(SHIM_ATTRIBUTE, \"\");\n            style.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n            style[SHIMMED_ATTRIBUTE] = true;\n            if (style.parentNode !== head) {\n              if (elt.parentNode === head) {\n                head.replaceChild(style, elt);\n              } else {\n                this.addElementToDocument(style);\n              }\n            }\n            style.__importParsed = true;\n            this.markParsingComplete(elt);\n            this.parseNext();\n          };\n          var hasResource = HTMLImports.parser.hasResource;\n          HTMLImports.parser.hasResource = function(node) {\n            if (node.localName === \"link\" && node.rel === \"stylesheet\" && node.hasAttribute(SHIM_ATTRIBUTE)) {\n              return node.__resource;\n            } else {\n              return hasResource.call(this, node);\n            }\n          };\n        }\n      });\n    }\n    scope.ShadowCSS = ShadowCSS;\n  })(window.WebComponents);\n}\n\n(function(scope) {\n  if (window.ShadowDOMPolyfill) {\n    window.wrap = ShadowDOMPolyfill.wrapIfNeeded;\n    window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;\n  } else {\n    window.wrap = window.unwrap = function(n) {\n      return n;\n    };\n  }\n})(window.WebComponents);\n\n(function(scope) {\n  \"use strict\";\n  var hasWorkingUrl = false;\n  if (!scope.forceJURL) {\n    try {\n      var u = new URL(\"b\", \"http://a\");\n      u.pathname = \"c%20d\";\n      hasWorkingUrl = u.href === \"http://a/c%20d\";\n    } catch (e) {}\n  }\n  if (hasWorkingUrl) return;\n  var relative = Object.create(null);\n  relative[\"ftp\"] = 21;\n  relative[\"file\"] = 0;\n  relative[\"gopher\"] = 70;\n  relative[\"http\"] = 80;\n  relative[\"https\"] = 443;\n  relative[\"ws\"] = 80;\n  relative[\"wss\"] = 443;\n  var relativePathDotMapping = Object.create(null);\n  relativePathDotMapping[\"%2e\"] = \".\";\n  relativePathDotMapping[\".%2e\"] = \"..\";\n  relativePathDotMapping[\"%2e.\"] = \"..\";\n  relativePathDotMapping[\"%2e%2e\"] = \"..\";\n  function isRelativeScheme(scheme) {\n    return relative[scheme] !== undefined;\n  }\n  function invalid() {\n    clear.call(this);\n    this._isInvalid = true;\n  }\n  function IDNAToASCII(h) {\n    if (\"\" == h) {\n      invalid.call(this);\n    }\n    return h.toLowerCase();\n  }\n  function percentEscape(c) {\n    var unicode = c.charCodeAt(0);\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) == -1) {\n      return c;\n    }\n    return encodeURIComponent(c);\n  }\n  function percentEscapeQuery(c) {\n    var unicode = c.charCodeAt(0);\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 96 ].indexOf(unicode) == -1) {\n      return c;\n    }\n    return encodeURIComponent(c);\n  }\n  var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\\+\\-\\.]/;\n  function parse(input, stateOverride, base) {\n    function err(message) {\n      errors.push(message);\n    }\n    var state = stateOverride || \"scheme start\", cursor = 0, buffer = \"\", seenAt = false, seenBracket = false, errors = [];\n    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {\n      var c = input[cursor];\n      switch (state) {\n       case \"scheme start\":\n        if (c && ALPHA.test(c)) {\n          buffer += c.toLowerCase();\n          state = \"scheme\";\n        } else if (!stateOverride) {\n          buffer = \"\";\n          state = \"no scheme\";\n          continue;\n        } else {\n          err(\"Invalid scheme.\");\n          break loop;\n        }\n        break;\n\n       case \"scheme\":\n        if (c && ALPHANUMERIC.test(c)) {\n          buffer += c.toLowerCase();\n        } else if (\":\" == c) {\n          this._scheme = buffer;\n          buffer = \"\";\n          if (stateOverride) {\n            break loop;\n          }\n          if (isRelativeScheme(this._scheme)) {\n            this._isRelative = true;\n          }\n          if (\"file\" == this._scheme) {\n            state = \"relative\";\n          } else if (this._isRelative && base && base._scheme == this._scheme) {\n            state = \"relative or authority\";\n          } else if (this._isRelative) {\n            state = \"authority first slash\";\n          } else {\n            state = \"scheme data\";\n          }\n        } else if (!stateOverride) {\n          buffer = \"\";\n          cursor = 0;\n          state = \"no scheme\";\n          continue;\n        } else if (EOF == c) {\n          break loop;\n        } else {\n          err(\"Code point not allowed in scheme: \" + c);\n          break loop;\n        }\n        break;\n\n       case \"scheme data\":\n        if (\"?\" == c) {\n          this._query = \"?\";\n          state = \"query\";\n        } else if (\"#\" == c) {\n          this._fragment = \"#\";\n          state = \"fragment\";\n        } else {\n          if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n            this._schemeData += percentEscape(c);\n          }\n        }\n        break;\n\n       case \"no scheme\":\n        if (!base || !isRelativeScheme(base._scheme)) {\n          err(\"Missing scheme.\");\n          invalid.call(this);\n        } else {\n          state = \"relative\";\n          continue;\n        }\n        break;\n\n       case \"relative or authority\":\n        if (\"/\" == c && \"/\" == input[cursor + 1]) {\n          state = \"authority ignore slashes\";\n        } else {\n          err(\"Expected /, got: \" + c);\n          state = \"relative\";\n          continue;\n        }\n        break;\n\n       case \"relative\":\n        this._isRelative = true;\n        if (\"file\" != this._scheme) this._scheme = base._scheme;\n        if (EOF == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = base._query;\n          this._username = base._username;\n          this._password = base._password;\n          break loop;\n        } else if (\"/\" == c || \"\\\\\" == c) {\n          if (\"\\\\\" == c) err(\"\\\\ is an invalid code point.\");\n          state = \"relative slash\";\n        } else if (\"?\" == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = \"?\";\n          this._username = base._username;\n          this._password = base._password;\n          state = \"query\";\n        } else if (\"#\" == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = base._query;\n          this._fragment = \"#\";\n          this._username = base._username;\n          this._password = base._password;\n          state = \"fragment\";\n        } else {\n          var nextC = input[cursor + 1];\n          var nextNextC = input[cursor + 2];\n          if (\"file\" != this._scheme || !ALPHA.test(c) || nextC != \":\" && nextC != \"|\" || EOF != nextNextC && \"/\" != nextNextC && \"\\\\\" != nextNextC && \"?\" != nextNextC && \"#\" != nextNextC) {\n            this._host = base._host;\n            this._port = base._port;\n            this._username = base._username;\n            this._password = base._password;\n            this._path = base._path.slice();\n            this._path.pop();\n          }\n          state = \"relative path\";\n          continue;\n        }\n        break;\n\n       case \"relative slash\":\n        if (\"/\" == c || \"\\\\\" == c) {\n          if (\"\\\\\" == c) {\n            err(\"\\\\ is an invalid code point.\");\n          }\n          if (\"file\" == this._scheme) {\n            state = \"file host\";\n          } else {\n            state = \"authority ignore slashes\";\n          }\n        } else {\n          if (\"file\" != this._scheme) {\n            this._host = base._host;\n            this._port = base._port;\n            this._username = base._username;\n            this._password = base._password;\n          }\n          state = \"relative path\";\n          continue;\n        }\n        break;\n\n       case \"authority first slash\":\n        if (\"/\" == c) {\n          state = \"authority second slash\";\n        } else {\n          err(\"Expected '/', got: \" + c);\n          state = \"authority ignore slashes\";\n          continue;\n        }\n        break;\n\n       case \"authority second slash\":\n        state = \"authority ignore slashes\";\n        if (\"/\" != c) {\n          err(\"Expected '/', got: \" + c);\n          continue;\n        }\n        break;\n\n       case \"authority ignore slashes\":\n        if (\"/\" != c && \"\\\\\" != c) {\n          state = \"authority\";\n          continue;\n        } else {\n          err(\"Expected authority, got: \" + c);\n        }\n        break;\n\n       case \"authority\":\n        if (\"@\" == c) {\n          if (seenAt) {\n            err(\"@ already seen.\");\n            buffer += \"%40\";\n          }\n          seenAt = true;\n          for (var i = 0; i < buffer.length; i++) {\n            var cp = buffer[i];\n            if (\"\t\" == cp || \"\\n\" == cp || \"\\r\" == cp) {\n              err(\"Invalid whitespace in authority.\");\n              continue;\n            }\n            if (\":\" == cp && null === this._password) {\n              this._password = \"\";\n              continue;\n            }\n            var tempC = percentEscape(cp);\n            null !== this._password ? this._password += tempC : this._username += tempC;\n          }\n          buffer = \"\";\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n          cursor -= buffer.length;\n          buffer = \"\";\n          state = \"host\";\n          continue;\n        } else {\n          buffer += c;\n        }\n        break;\n\n       case \"file host\":\n        if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n          if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == \":\" || buffer[1] == \"|\")) {\n            state = \"relative path\";\n          } else if (buffer.length == 0) {\n            state = \"relative path start\";\n          } else {\n            this._host = IDNAToASCII.call(this, buffer);\n            buffer = \"\";\n            state = \"relative path start\";\n          }\n          continue;\n        } else if (\"\t\" == c || \"\\n\" == c || \"\\r\" == c) {\n          err(\"Invalid whitespace in file host.\");\n        } else {\n          buffer += c;\n        }\n        break;\n\n       case \"host\":\n       case \"hostname\":\n        if (\":\" == c && !seenBracket) {\n          this._host = IDNAToASCII.call(this, buffer);\n          buffer = \"\";\n          state = \"port\";\n          if (\"hostname\" == stateOverride) {\n            break loop;\n          }\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n          this._host = IDNAToASCII.call(this, buffer);\n          buffer = \"\";\n          state = \"relative path start\";\n          if (stateOverride) {\n            break loop;\n          }\n          continue;\n        } else if (\"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          if (\"[\" == c) {\n            seenBracket = true;\n          } else if (\"]\" == c) {\n            seenBracket = false;\n          }\n          buffer += c;\n        } else {\n          err(\"Invalid code point in host/hostname: \" + c);\n        }\n        break;\n\n       case \"port\":\n        if (/[0-9]/.test(c)) {\n          buffer += c;\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c || stateOverride) {\n          if (\"\" != buffer) {\n            var temp = parseInt(buffer, 10);\n            if (temp != relative[this._scheme]) {\n              this._port = temp + \"\";\n            }\n            buffer = \"\";\n          }\n          if (stateOverride) {\n            break loop;\n          }\n          state = \"relative path start\";\n          continue;\n        } else if (\"\t\" == c || \"\\n\" == c || \"\\r\" == c) {\n          err(\"Invalid code point in port: \" + c);\n        } else {\n          invalid.call(this);\n        }\n        break;\n\n       case \"relative path start\":\n        if (\"\\\\\" == c) err(\"'\\\\' not allowed in path.\");\n        state = \"relative path\";\n        if (\"/\" != c && \"\\\\\" != c) {\n          continue;\n        }\n        break;\n\n       case \"relative path\":\n        if (EOF == c || \"/\" == c || \"\\\\\" == c || !stateOverride && (\"?\" == c || \"#\" == c)) {\n          if (\"\\\\\" == c) {\n            err(\"\\\\ not allowed in relative path.\");\n          }\n          var tmp;\n          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {\n            buffer = tmp;\n          }\n          if (\"..\" == buffer) {\n            this._path.pop();\n            if (\"/\" != c && \"\\\\\" != c) {\n              this._path.push(\"\");\n            }\n          } else if (\".\" == buffer && \"/\" != c && \"\\\\\" != c) {\n            this._path.push(\"\");\n          } else if (\".\" != buffer) {\n            if (\"file\" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == \"|\") {\n              buffer = buffer[0] + \":\";\n            }\n            this._path.push(buffer);\n          }\n          buffer = \"\";\n          if (\"?\" == c) {\n            this._query = \"?\";\n            state = \"query\";\n          } else if (\"#\" == c) {\n            this._fragment = \"#\";\n            state = \"fragment\";\n          }\n        } else if (\"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          buffer += percentEscape(c);\n        }\n        break;\n\n       case \"query\":\n        if (!stateOverride && \"#\" == c) {\n          this._fragment = \"#\";\n          state = \"fragment\";\n        } else if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          this._query += percentEscapeQuery(c);\n        }\n        break;\n\n       case \"fragment\":\n        if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          this._fragment += c;\n        }\n        break;\n      }\n      cursor++;\n    }\n  }\n  function clear() {\n    this._scheme = \"\";\n    this._schemeData = \"\";\n    this._username = \"\";\n    this._password = null;\n    this._host = \"\";\n    this._port = \"\";\n    this._path = [];\n    this._query = \"\";\n    this._fragment = \"\";\n    this._isInvalid = false;\n    this._isRelative = false;\n  }\n  function jURL(url, base) {\n    if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));\n    this._url = url;\n    clear.call(this);\n    var input = url.replace(/^[ \\t\\r\\n\\f]+|[ \\t\\r\\n\\f]+$/g, \"\");\n    parse.call(this, input, null, base);\n  }\n  jURL.prototype = {\n    toString: function() {\n      return this.href;\n    },\n    get href() {\n      if (this._isInvalid) return this._url;\n      var authority = \"\";\n      if (\"\" != this._username || null != this._password) {\n        authority = this._username + (null != this._password ? \":\" + this._password : \"\") + \"@\";\n      }\n      return this.protocol + (this._isRelative ? \"//\" + authority + this.host : \"\") + this.pathname + this._query + this._fragment;\n    },\n    set href(href) {\n      clear.call(this);\n      parse.call(this, href);\n    },\n    get protocol() {\n      return this._scheme + \":\";\n    },\n    set protocol(protocol) {\n      if (this._isInvalid) return;\n      parse.call(this, protocol + \":\", \"scheme start\");\n    },\n    get host() {\n      return this._isInvalid ? \"\" : this._port ? this._host + \":\" + this._port : this._host;\n    },\n    set host(host) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, host, \"host\");\n    },\n    get hostname() {\n      return this._host;\n    },\n    set hostname(hostname) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, hostname, \"hostname\");\n    },\n    get port() {\n      return this._port;\n    },\n    set port(port) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, port, \"port\");\n    },\n    get pathname() {\n      return this._isInvalid ? \"\" : this._isRelative ? \"/\" + this._path.join(\"/\") : this._schemeData;\n    },\n    set pathname(pathname) {\n      if (this._isInvalid || !this._isRelative) return;\n      this._path = [];\n      parse.call(this, pathname, \"relative path start\");\n    },\n    get search() {\n      return this._isInvalid || !this._query || \"?\" == this._query ? \"\" : this._query;\n    },\n    set search(search) {\n      if (this._isInvalid || !this._isRelative) return;\n      this._query = \"?\";\n      if (\"?\" == search[0]) search = search.slice(1);\n      parse.call(this, search, \"query\");\n    },\n    get hash() {\n      return this._isInvalid || !this._fragment || \"#\" == this._fragment ? \"\" : this._fragment;\n    },\n    set hash(hash) {\n      if (this._isInvalid) return;\n      this._fragment = \"#\";\n      if (\"#\" == hash[0]) hash = hash.slice(1);\n      parse.call(this, hash, \"fragment\");\n    },\n    get origin() {\n      var host;\n      if (this._isInvalid || !this._scheme) {\n        return \"\";\n      }\n      switch (this._scheme) {\n       case \"data\":\n       case \"file\":\n       case \"javascript\":\n       case \"mailto\":\n        return \"null\";\n      }\n      host = this.host;\n      if (!host) {\n        return \"\";\n      }\n      return this._scheme + \"://\" + host;\n    }\n  };\n  var OriginalURL = scope.URL;\n  if (OriginalURL) {\n    jURL.createObjectURL = function(blob) {\n      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);\n    };\n    jURL.revokeObjectURL = function(url) {\n      OriginalURL.revokeObjectURL(url);\n    };\n  }\n  scope.URL = jURL;\n})(self);\n\n(function(global) {\n  if (global.JsMutationObserver) {\n    return;\n  }\n  var registrationsTable = new WeakMap();\n  var setImmediate;\n  if (/Trident|Edge/.test(navigator.userAgent)) {\n    setImmediate = setTimeout;\n  } else if (window.setImmediate) {\n    setImmediate = window.setImmediate;\n  } else {\n    var setImmediateQueue = [];\n    var sentinel = String(Math.random());\n    window.addEventListener(\"message\", function(e) {\n      if (e.data === sentinel) {\n        var queue = setImmediateQueue;\n        setImmediateQueue = [];\n        queue.forEach(function(func) {\n          func();\n        });\n      }\n    });\n    setImmediate = function(func) {\n      setImmediateQueue.push(func);\n      window.postMessage(sentinel, \"*\");\n    };\n  }\n  var isScheduled = false;\n  var scheduledObservers = [];\n  function scheduleCallback(observer) {\n    scheduledObservers.push(observer);\n    if (!isScheduled) {\n      isScheduled = true;\n      setImmediate(dispatchCallbacks);\n    }\n  }\n  function wrapIfNeeded(node) {\n    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;\n  }\n  function dispatchCallbacks() {\n    isScheduled = false;\n    var observers = scheduledObservers;\n    scheduledObservers = [];\n    observers.sort(function(o1, o2) {\n      return o1.uid_ - o2.uid_;\n    });\n    var anyNonEmpty = false;\n    observers.forEach(function(observer) {\n      var queue = observer.takeRecords();\n      removeTransientObserversFor(observer);\n      if (queue.length) {\n        observer.callback_(queue, observer);\n        anyNonEmpty = true;\n      }\n    });\n    if (anyNonEmpty) dispatchCallbacks();\n  }\n  function removeTransientObserversFor(observer) {\n    observer.nodes_.forEach(function(node) {\n      var registrations = registrationsTable.get(node);\n      if (!registrations) return;\n      registrations.forEach(function(registration) {\n        if (registration.observer === observer) registration.removeTransientObservers();\n      });\n    });\n  }\n  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\n    for (var node = target; node; node = node.parentNode) {\n      var registrations = registrationsTable.get(node);\n      if (registrations) {\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n          if (node !== target && !options.subtree) continue;\n          var record = callback(options);\n          if (record) registration.enqueue(record);\n        }\n      }\n    }\n  }\n  var uidCounter = 0;\n  function JsMutationObserver(callback) {\n    this.callback_ = callback;\n    this.nodes_ = [];\n    this.records_ = [];\n    this.uid_ = ++uidCounter;\n  }\n  JsMutationObserver.prototype = {\n    observe: function(target, options) {\n      target = wrapIfNeeded(target);\n      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {\n        throw new SyntaxError();\n      }\n      var registrations = registrationsTable.get(target);\n      if (!registrations) registrationsTable.set(target, registrations = []);\n      var registration;\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i].observer === this) {\n          registration = registrations[i];\n          registration.removeListeners();\n          registration.options = options;\n          break;\n        }\n      }\n      if (!registration) {\n        registration = new Registration(this, target, options);\n        registrations.push(registration);\n        this.nodes_.push(target);\n      }\n      registration.addListeners();\n    },\n    disconnect: function() {\n      this.nodes_.forEach(function(node) {\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.observer === this) {\n            registration.removeListeners();\n            registrations.splice(i, 1);\n            break;\n          }\n        }\n      }, this);\n      this.records_ = [];\n    },\n    takeRecords: function() {\n      var copyOfRecords = this.records_;\n      this.records_ = [];\n      return copyOfRecords;\n    }\n  };\n  function MutationRecord(type, target) {\n    this.type = type;\n    this.target = target;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.attributeName = null;\n    this.attributeNamespace = null;\n    this.oldValue = null;\n  }\n  function copyMutationRecord(original) {\n    var record = new MutationRecord(original.type, original.target);\n    record.addedNodes = original.addedNodes.slice();\n    record.removedNodes = original.removedNodes.slice();\n    record.previousSibling = original.previousSibling;\n    record.nextSibling = original.nextSibling;\n    record.attributeName = original.attributeName;\n    record.attributeNamespace = original.attributeNamespace;\n    record.oldValue = original.oldValue;\n    return record;\n  }\n  var currentRecord, recordWithOldValue;\n  function getRecord(type, target) {\n    return currentRecord = new MutationRecord(type, target);\n  }\n  function getRecordWithOldValue(oldValue) {\n    if (recordWithOldValue) return recordWithOldValue;\n    recordWithOldValue = copyMutationRecord(currentRecord);\n    recordWithOldValue.oldValue = oldValue;\n    return recordWithOldValue;\n  }\n  function clearRecords() {\n    currentRecord = recordWithOldValue = undefined;\n  }\n  function recordRepresentsCurrentMutation(record) {\n    return record === recordWithOldValue || record === currentRecord;\n  }\n  function selectRecord(lastRecord, newRecord) {\n    if (lastRecord === newRecord) return lastRecord;\n    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n    return null;\n  }\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n  Registration.prototype = {\n    enqueue: function(record) {\n      var records = this.observer.records_;\n      var length = records.length;\n      if (records.length > 0) {\n        var lastRecord = records[length - 1];\n        var recordToReplaceLast = selectRecord(lastRecord, record);\n        if (recordToReplaceLast) {\n          records[length - 1] = recordToReplaceLast;\n          return;\n        }\n      } else {\n        scheduleCallback(this.observer);\n      }\n      records[length] = record;\n    },\n    addListeners: function() {\n      this.addListeners_(this.target);\n    },\n    addListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes) node.addEventListener(\"DOMAttrModified\", this, true);\n      if (options.characterData) node.addEventListener(\"DOMCharacterDataModified\", this, true);\n      if (options.childList) node.addEventListener(\"DOMNodeInserted\", this, true);\n      if (options.childList || options.subtree) node.addEventListener(\"DOMNodeRemoved\", this, true);\n    },\n    removeListeners: function() {\n      this.removeListeners_(this.target);\n    },\n    removeListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes) node.removeEventListener(\"DOMAttrModified\", this, true);\n      if (options.characterData) node.removeEventListener(\"DOMCharacterDataModified\", this, true);\n      if (options.childList) node.removeEventListener(\"DOMNodeInserted\", this, true);\n      if (options.childList || options.subtree) node.removeEventListener(\"DOMNodeRemoved\", this, true);\n    },\n    addTransientObserver: function(node) {\n      if (node === this.target) return;\n      this.addListeners_(node);\n      this.transientObservedNodes.push(node);\n      var registrations = registrationsTable.get(node);\n      if (!registrations) registrationsTable.set(node, registrations = []);\n      registrations.push(this);\n    },\n    removeTransientObservers: function() {\n      var transientObservedNodes = this.transientObservedNodes;\n      this.transientObservedNodes = [];\n      transientObservedNodes.forEach(function(node) {\n        this.removeListeners_(node);\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i] === this) {\n            registrations.splice(i, 1);\n            break;\n          }\n        }\n      }, this);\n    },\n    handleEvent: function(e) {\n      e.stopImmediatePropagation();\n      switch (e.type) {\n       case \"DOMAttrModified\":\n        var name = e.attrName;\n        var namespace = e.relatedNode.namespaceURI;\n        var target = e.target;\n        var record = new getRecord(\"attributes\", target);\n        record.attributeName = name;\n        record.attributeNamespace = namespace;\n        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          if (!options.attributes) return;\n          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {\n            return;\n          }\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\n          return record;\n        });\n        break;\n\n       case \"DOMCharacterDataModified\":\n        var target = e.target;\n        var record = getRecord(\"characterData\", target);\n        var oldValue = e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          if (!options.characterData) return;\n          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);\n          return record;\n        });\n        break;\n\n       case \"DOMNodeRemoved\":\n        this.addTransientObserver(e.target);\n\n       case \"DOMNodeInserted\":\n        var changedNode = e.target;\n        var addedNodes, removedNodes;\n        if (e.type === \"DOMNodeInserted\") {\n          addedNodes = [ changedNode ];\n          removedNodes = [];\n        } else {\n          addedNodes = [];\n          removedNodes = [ changedNode ];\n        }\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling;\n        var record = getRecord(\"childList\", e.target.parentNode);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {\n          if (!options.childList) return;\n          return record;\n        });\n      }\n      clearRecords();\n    }\n  };\n  global.JsMutationObserver = JsMutationObserver;\n  if (!global.MutationObserver) {\n    global.MutationObserver = JsMutationObserver;\n    JsMutationObserver._isPolyfilled = true;\n  }\n})(self);\n\n(function(scope) {\n  \"use strict\";\n  if (!window.performance) {\n    var start = Date.now();\n    window.performance = {\n      now: function() {\n        return Date.now() - start;\n      }\n    };\n  }\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function() {\n      var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n      return nativeRaf ? function(callback) {\n        return nativeRaf(function() {\n          callback(performance.now());\n        });\n      } : function(callback) {\n        return window.setTimeout(callback, 1e3 / 60);\n      };\n    }();\n  }\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function() {\n      return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {\n        clearTimeout(id);\n      };\n    }();\n  }\n  var workingDefaultPrevented = function() {\n    var e = document.createEvent(\"Event\");\n    e.initEvent(\"foo\", true, true);\n    e.preventDefault();\n    return e.defaultPrevented;\n  }();\n  if (!workingDefaultPrevented) {\n    var origPreventDefault = Event.prototype.preventDefault;\n    Event.prototype.preventDefault = function() {\n      if (!this.cancelable) {\n        return;\n      }\n      origPreventDefault.call(this);\n      Object.defineProperty(this, \"defaultPrevented\", {\n        get: function() {\n          return true;\n        },\n        configurable: true\n      });\n    };\n  }\n  var isIE = /Trident/.test(navigator.userAgent);\n  if (!window.CustomEvent || isIE && typeof window.CustomEvent !== \"function\") {\n    window.CustomEvent = function(inType, params) {\n      params = params || {};\n      var e = document.createEvent(\"CustomEvent\");\n      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n      return e;\n    };\n    window.CustomEvent.prototype = window.Event.prototype;\n  }\n  if (!window.Event || isIE && typeof window.Event !== \"function\") {\n    var origEvent = window.Event;\n    window.Event = function(inType, params) {\n      params = params || {};\n      var e = document.createEvent(\"Event\");\n      e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n      return e;\n    };\n    window.Event.prototype = origEvent.prototype;\n  }\n})(window.WebComponents);\n\nwindow.HTMLImports = window.HTMLImports || {\n  flags: {}\n};\n\n(function(scope) {\n  var IMPORT_LINK_TYPE = \"import\";\n  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement(\"link\"));\n  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\n  var wrap = function(node) {\n    return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;\n  };\n  var rootDocument = wrap(document);\n  var currentScriptDescriptor = {\n    get: function() {\n      var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== \"complete\" ? document.scripts[document.scripts.length - 1] : null);\n      return wrap(script);\n    },\n    configurable: true\n  };\n  Object.defineProperty(document, \"_currentScript\", currentScriptDescriptor);\n  Object.defineProperty(rootDocument, \"_currentScript\", currentScriptDescriptor);\n  var isIE = /Trident/.test(navigator.userAgent);\n  function whenReady(callback, doc) {\n    doc = doc || rootDocument;\n    whenDocumentReady(function() {\n      watchImportsLoad(callback, doc);\n    }, doc);\n  }\n  var requiredReadyState = isIE ? \"complete\" : \"interactive\";\n  var READY_EVENT = \"readystatechange\";\n  function isDocumentReady(doc) {\n    return doc.readyState === \"complete\" || doc.readyState === requiredReadyState;\n  }\n  function whenDocumentReady(callback, doc) {\n    if (!isDocumentReady(doc)) {\n      var checkReady = function() {\n        if (doc.readyState === \"complete\" || doc.readyState === requiredReadyState) {\n          doc.removeEventListener(READY_EVENT, checkReady);\n          whenDocumentReady(callback, doc);\n        }\n      };\n      doc.addEventListener(READY_EVENT, checkReady);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function markTargetLoaded(event) {\n    event.target.__loaded = true;\n  }\n  function watchImportsLoad(callback, doc) {\n    var imports = doc.querySelectorAll(\"link[rel=import]\");\n    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];\n    function checkDone() {\n      if (parsedCount == importCount && callback) {\n        callback({\n          allImports: imports,\n          loadedImports: newImports,\n          errorImports: errorImports\n        });\n      }\n    }\n    function loadedImport(e) {\n      markTargetLoaded(e);\n      newImports.push(this);\n      parsedCount++;\n      checkDone();\n    }\n    function errorLoadingImport(e) {\n      errorImports.push(this);\n      parsedCount++;\n      checkDone();\n    }\n    if (importCount) {\n      for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {\n        if (isImportLoaded(imp)) {\n          newImports.push(this);\n          parsedCount++;\n          checkDone();\n        } else {\n          imp.addEventListener(\"load\", loadedImport);\n          imp.addEventListener(\"error\", errorLoadingImport);\n        }\n      }\n    } else {\n      checkDone();\n    }\n  }\n  function isImportLoaded(link) {\n    return useNative ? link.__loaded || link.import && link.import.readyState !== \"loading\" : link.__importParsed;\n  }\n  if (useNative) {\n    new MutationObserver(function(mxns) {\n      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {\n        if (m.addedNodes) {\n          handleImports(m.addedNodes);\n        }\n      }\n    }).observe(document.head, {\n      childList: true\n    });\n    function handleImports(nodes) {\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        if (isImport(n)) {\n          handleImport(n);\n        }\n      }\n    }\n    function isImport(element) {\n      return element.localName === \"link\" && element.rel === \"import\";\n    }\n    function handleImport(element) {\n      var loaded = element.import;\n      if (loaded) {\n        markTargetLoaded({\n          target: element\n        });\n      } else {\n        element.addEventListener(\"load\", markTargetLoaded);\n        element.addEventListener(\"error\", markTargetLoaded);\n      }\n    }\n    (function() {\n      if (document.readyState === \"loading\") {\n        var imports = document.querySelectorAll(\"link[rel=import]\");\n        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {\n          handleImport(imp);\n        }\n      }\n    })();\n  }\n  whenReady(function(detail) {\n    window.HTMLImports.ready = true;\n    window.HTMLImports.readyTime = new Date().getTime();\n    var evt = rootDocument.createEvent(\"CustomEvent\");\n    evt.initCustomEvent(\"HTMLImportsLoaded\", true, true, detail);\n    rootDocument.dispatchEvent(evt);\n  });\n  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\n  scope.useNative = useNative;\n  scope.rootDocument = rootDocument;\n  scope.whenReady = whenReady;\n  scope.isIE = isIE;\n})(window.HTMLImports);\n\n(function(scope) {\n  var modules = [];\n  var addModule = function(module) {\n    modules.push(module);\n  };\n  var initializeModules = function() {\n    modules.forEach(function(module) {\n      module(scope);\n    });\n  };\n  scope.addModule = addModule;\n  scope.initializeModules = initializeModules;\n})(window.HTMLImports);\n\nwindow.HTMLImports.addModule(function(scope) {\n  var CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\n  var CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n  var path = {\n    resolveUrlsInStyle: function(style, linkUrl) {\n      var doc = style.ownerDocument;\n      var resolver = doc.createElement(\"a\");\n      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);\n      return style;\n    },\n    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {\n      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);\n      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);\n      return r;\n    },\n    replaceUrls: function(text, urlObj, linkUrl, regexp) {\n      return text.replace(regexp, function(m, pre, url, post) {\n        var urlPath = url.replace(/[\"']/g, \"\");\n        if (linkUrl) {\n          urlPath = new URL(urlPath, linkUrl).href;\n        }\n        urlObj.href = urlPath;\n        urlPath = urlObj.href;\n        return pre + \"'\" + urlPath + \"'\" + post;\n      });\n    }\n  };\n  scope.path = path;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var xhr = {\n    async: true,\n    ok: function(request) {\n      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;\n    },\n    load: function(url, next, nextContext) {\n      var request = new XMLHttpRequest();\n      if (scope.flags.debug || scope.flags.bust) {\n        url += \"?\" + Math.random();\n      }\n      request.open(\"GET\", url, xhr.async);\n      request.addEventListener(\"readystatechange\", function(e) {\n        if (request.readyState === 4) {\n          var redirectedUrl = null;\n          try {\n            var locationHeader = request.getResponseHeader(\"Location\");\n            if (locationHeader) {\n              redirectedUrl = locationHeader.substr(0, 1) === \"/\" ? location.origin + locationHeader : locationHeader;\n            }\n          } catch (e) {\n            console.error(e.message);\n          }\n          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);\n        }\n      });\n      request.send();\n      return request;\n    },\n    loadDocument: function(url, next, nextContext) {\n      this.load(url, next, nextContext).responseType = \"document\";\n    }\n  };\n  scope.xhr = xhr;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var xhr = scope.xhr;\n  var flags = scope.flags;\n  var Loader = function(onLoad, onComplete) {\n    this.cache = {};\n    this.onload = onLoad;\n    this.oncomplete = onComplete;\n    this.inflight = 0;\n    this.pending = {};\n  };\n  Loader.prototype = {\n    addNodes: function(nodes) {\n      this.inflight += nodes.length;\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        this.require(n);\n      }\n      this.checkDone();\n    },\n    addNode: function(node) {\n      this.inflight++;\n      this.require(node);\n      this.checkDone();\n    },\n    require: function(elt) {\n      var url = elt.src || elt.href;\n      elt.__nodeUrl = url;\n      if (!this.dedupe(url, elt)) {\n        this.fetch(url, elt);\n      }\n    },\n    dedupe: function(url, elt) {\n      if (this.pending[url]) {\n        this.pending[url].push(elt);\n        return true;\n      }\n      var resource;\n      if (this.cache[url]) {\n        this.onload(url, elt, this.cache[url]);\n        this.tail();\n        return true;\n      }\n      this.pending[url] = [ elt ];\n      return false;\n    },\n    fetch: function(url, elt) {\n      flags.load && console.log(\"fetch\", url, elt);\n      if (!url) {\n        setTimeout(function() {\n          this.receive(url, elt, {\n            error: \"href must be specified\"\n          }, null);\n        }.bind(this), 0);\n      } else if (url.match(/^data:/)) {\n        var pieces = url.split(\",\");\n        var header = pieces[0];\n        var body = pieces[1];\n        if (header.indexOf(\";base64\") > -1) {\n          body = atob(body);\n        } else {\n          body = decodeURIComponent(body);\n        }\n        setTimeout(function() {\n          this.receive(url, elt, null, body);\n        }.bind(this), 0);\n      } else {\n        var receiveXhr = function(err, resource, redirectedUrl) {\n          this.receive(url, elt, err, resource, redirectedUrl);\n        }.bind(this);\n        xhr.load(url, receiveXhr);\n      }\n    },\n    receive: function(url, elt, err, resource, redirectedUrl) {\n      this.cache[url] = resource;\n      var $p = this.pending[url];\n      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\n        this.onload(url, p, resource, err, redirectedUrl);\n        this.tail();\n      }\n      this.pending[url] = null;\n    },\n    tail: function() {\n      --this.inflight;\n      this.checkDone();\n    },\n    checkDone: function() {\n      if (!this.inflight) {\n        this.oncomplete();\n      }\n    }\n  };\n  scope.Loader = Loader;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var Observer = function(addCallback) {\n    this.addCallback = addCallback;\n    this.mo = new MutationObserver(this.handler.bind(this));\n  };\n  Observer.prototype = {\n    handler: function(mutations) {\n      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {\n        if (m.type === \"childList\" && m.addedNodes.length) {\n          this.addedNodes(m.addedNodes);\n        }\n      }\n    },\n    addedNodes: function(nodes) {\n      if (this.addCallback) {\n        this.addCallback(nodes);\n      }\n      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {\n        if (n.children && n.children.length) {\n          this.addedNodes(n.children);\n        }\n      }\n    },\n    observe: function(root) {\n      this.mo.observe(root, {\n        childList: true,\n        subtree: true\n      });\n    }\n  };\n  scope.Observer = Observer;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var path = scope.path;\n  var rootDocument = scope.rootDocument;\n  var flags = scope.flags;\n  var isIE = scope.isIE;\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n  var IMPORT_SELECTOR = \"link[rel=\" + IMPORT_LINK_TYPE + \"]\";\n  var importParser = {\n    documentSelectors: IMPORT_SELECTOR,\n    importsSelectors: [ IMPORT_SELECTOR, \"link[rel=stylesheet]:not([type])\", \"style:not([type])\", \"script:not([type])\", 'script[type=\"application/javascript\"]', 'script[type=\"text/javascript\"]' ].join(\",\"),\n    map: {\n      link: \"parseLink\",\n      script: \"parseScript\",\n      style: \"parseStyle\"\n    },\n    dynamicElements: [],\n    parseNext: function() {\n      var next = this.nextToParse();\n      if (next) {\n        this.parse(next);\n      }\n    },\n    parse: function(elt) {\n      if (this.isParsed(elt)) {\n        flags.parse && console.log(\"[%s] is already parsed\", elt.localName);\n        return;\n      }\n      var fn = this[this.map[elt.localName]];\n      if (fn) {\n        this.markParsing(elt);\n        fn.call(this, elt);\n      }\n    },\n    parseDynamic: function(elt, quiet) {\n      this.dynamicElements.push(elt);\n      if (!quiet) {\n        this.parseNext();\n      }\n    },\n    markParsing: function(elt) {\n      flags.parse && console.log(\"parsing\", elt);\n      this.parsingElement = elt;\n    },\n    markParsingComplete: function(elt) {\n      elt.__importParsed = true;\n      this.markDynamicParsingComplete(elt);\n      if (elt.__importElement) {\n        elt.__importElement.__importParsed = true;\n        this.markDynamicParsingComplete(elt.__importElement);\n      }\n      this.parsingElement = null;\n      flags.parse && console.log(\"completed\", elt);\n    },\n    markDynamicParsingComplete: function(elt) {\n      var i = this.dynamicElements.indexOf(elt);\n      if (i >= 0) {\n        this.dynamicElements.splice(i, 1);\n      }\n    },\n    parseImport: function(elt) {\n      elt.import = elt.__doc;\n      if (window.HTMLImports.__importsParsingHook) {\n        window.HTMLImports.__importsParsingHook(elt);\n      }\n      if (elt.import) {\n        elt.import.__importParsed = true;\n      }\n      this.markParsingComplete(elt);\n      if (elt.__resource && !elt.__error) {\n        elt.dispatchEvent(new CustomEvent(\"load\", {\n          bubbles: false\n        }));\n      } else {\n        elt.dispatchEvent(new CustomEvent(\"error\", {\n          bubbles: false\n        }));\n      }\n      if (elt.__pending) {\n        var fn;\n        while (elt.__pending.length) {\n          fn = elt.__pending.shift();\n          if (fn) {\n            fn({\n              target: elt\n            });\n          }\n        }\n      }\n      this.parseNext();\n    },\n    parseLink: function(linkElt) {\n      if (nodeIsImport(linkElt)) {\n        this.parseImport(linkElt);\n      } else {\n        linkElt.href = linkElt.href;\n        this.parseGeneric(linkElt);\n      }\n    },\n    parseStyle: function(elt) {\n      var src = elt;\n      elt = cloneStyle(elt);\n      src.__appliedElement = elt;\n      elt.__importElement = src;\n      this.parseGeneric(elt);\n    },\n    parseGeneric: function(elt) {\n      this.trackElement(elt);\n      this.addElementToDocument(elt);\n    },\n    rootImportForElement: function(elt) {\n      var n = elt;\n      while (n.ownerDocument.__importLink) {\n        n = n.ownerDocument.__importLink;\n      }\n      return n;\n    },\n    addElementToDocument: function(elt) {\n      var port = this.rootImportForElement(elt.__importElement || elt);\n      port.parentNode.insertBefore(elt, port);\n    },\n    trackElement: function(elt, callback) {\n      var self = this;\n      var done = function(e) {\n        elt.removeEventListener(\"load\", done);\n        elt.removeEventListener(\"error\", done);\n        if (callback) {\n          callback(e);\n        }\n        self.markParsingComplete(elt);\n        self.parseNext();\n      };\n      elt.addEventListener(\"load\", done);\n      elt.addEventListener(\"error\", done);\n      if (isIE && elt.localName === \"style\") {\n        var fakeLoad = false;\n        if (elt.textContent.indexOf(\"@import\") == -1) {\n          fakeLoad = true;\n        } else if (elt.sheet) {\n          fakeLoad = true;\n          var csr = elt.sheet.cssRules;\n          var len = csr ? csr.length : 0;\n          for (var i = 0, r; i < len && (r = csr[i]); i++) {\n            if (r.type === CSSRule.IMPORT_RULE) {\n              fakeLoad = fakeLoad && Boolean(r.styleSheet);\n            }\n          }\n        }\n        if (fakeLoad) {\n          setTimeout(function() {\n            elt.dispatchEvent(new CustomEvent(\"load\", {\n              bubbles: false\n            }));\n          });\n        }\n      }\n    },\n    parseScript: function(scriptElt) {\n      var script = document.createElement(\"script\");\n      script.__importElement = scriptElt;\n      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);\n      scope.currentScript = scriptElt;\n      this.trackElement(script, function(e) {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n        scope.currentScript = null;\n      });\n      this.addElementToDocument(script);\n    },\n    nextToParse: function() {\n      this._mayParse = [];\n      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());\n    },\n    nextToParseInDoc: function(doc, link) {\n      if (doc && this._mayParse.indexOf(doc) < 0) {\n        this._mayParse.push(doc);\n        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));\n        for (var i = 0, l = nodes.length, p = 0, n; i < l && (n = nodes[i]); i++) {\n          if (!this.isParsed(n)) {\n            if (this.hasResource(n)) {\n              return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;\n            } else {\n              return;\n            }\n          }\n        }\n      }\n      return link;\n    },\n    nextToParseDynamic: function() {\n      return this.dynamicElements[0];\n    },\n    parseSelectorsForNode: function(node) {\n      var doc = node.ownerDocument || node;\n      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;\n    },\n    isParsed: function(node) {\n      return node.__importParsed;\n    },\n    needsDynamicParsing: function(elt) {\n      return this.dynamicElements.indexOf(elt) >= 0;\n    },\n    hasResource: function(node) {\n      if (nodeIsImport(node) && node.__doc === undefined) {\n        return false;\n      }\n      return true;\n    }\n  };\n  function nodeIsImport(elt) {\n    return elt.localName === \"link\" && elt.rel === IMPORT_LINK_TYPE;\n  }\n  function generateScriptDataUrl(script) {\n    var scriptContent = generateScriptContent(script);\n    return \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(scriptContent);\n  }\n  function generateScriptContent(script) {\n    return script.textContent + generateSourceMapHint(script);\n  }\n  function generateSourceMapHint(script) {\n    var owner = script.ownerDocument;\n    owner.__importedScripts = owner.__importedScripts || 0;\n    var moniker = script.ownerDocument.baseURI;\n    var num = owner.__importedScripts ? \"-\" + owner.__importedScripts : \"\";\n    owner.__importedScripts++;\n    return \"\\n//# sourceURL=\" + moniker + num + \".js\\n\";\n  }\n  function cloneStyle(style) {\n    var clone = style.ownerDocument.createElement(\"style\");\n    clone.textContent = style.textContent;\n    path.resolveUrlsInStyle(clone);\n    return clone;\n  }\n  scope.parser = importParser;\n  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var flags = scope.flags;\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;\n  var rootDocument = scope.rootDocument;\n  var Loader = scope.Loader;\n  var Observer = scope.Observer;\n  var parser = scope.parser;\n  var importer = {\n    documents: {},\n    documentPreloadSelectors: IMPORT_SELECTOR,\n    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(\",\"),\n    loadNode: function(node) {\n      importLoader.addNode(node);\n    },\n    loadSubtree: function(parent) {\n      var nodes = this.marshalNodes(parent);\n      importLoader.addNodes(nodes);\n    },\n    marshalNodes: function(parent) {\n      return parent.querySelectorAll(this.loadSelectorsForNode(parent));\n    },\n    loadSelectorsForNode: function(node) {\n      var doc = node.ownerDocument || node;\n      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;\n    },\n    loaded: function(url, elt, resource, err, redirectedUrl) {\n      flags.load && console.log(\"loaded\", url, elt);\n      elt.__resource = resource;\n      elt.__error = err;\n      if (isImportLink(elt)) {\n        var doc = this.documents[url];\n        if (doc === undefined) {\n          doc = err ? null : makeDocument(resource, redirectedUrl || url);\n          if (doc) {\n            doc.__importLink = elt;\n            this.bootDocument(doc);\n          }\n          this.documents[url] = doc;\n        }\n        elt.__doc = doc;\n      }\n      parser.parseNext();\n    },\n    bootDocument: function(doc) {\n      this.loadSubtree(doc);\n      this.observer.observe(doc);\n      parser.parseNext();\n    },\n    loadedAll: function() {\n      parser.parseNext();\n    }\n  };\n  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));\n  importer.observer = new Observer();\n  function isImportLink(elt) {\n    return isLinkRel(elt, IMPORT_LINK_TYPE);\n  }\n  function isLinkRel(elt, rel) {\n    return elt.localName === \"link\" && elt.getAttribute(\"rel\") === rel;\n  }\n  function hasBaseURIAccessor(doc) {\n    return !!Object.getOwnPropertyDescriptor(doc, \"baseURI\");\n  }\n  function makeDocument(resource, url) {\n    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);\n    doc._URL = url;\n    var base = doc.createElement(\"base\");\n    base.setAttribute(\"href\", url);\n    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {\n      Object.defineProperty(doc, \"baseURI\", {\n        value: url\n      });\n    }\n    var meta = doc.createElement(\"meta\");\n    meta.setAttribute(\"charset\", \"utf-8\");\n    doc.head.appendChild(meta);\n    doc.head.appendChild(base);\n    doc.body.innerHTML = resource;\n    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\n      HTMLTemplateElement.bootstrap(doc);\n    }\n    return doc;\n  }\n  if (!document.baseURI) {\n    var baseURIDescriptor = {\n      get: function() {\n        var base = document.querySelector(\"base\");\n        return base ? base.href : window.location.href;\n      },\n      configurable: true\n    };\n    Object.defineProperty(document, \"baseURI\", baseURIDescriptor);\n    Object.defineProperty(rootDocument, \"baseURI\", baseURIDescriptor);\n  }\n  scope.importer = importer;\n  scope.importLoader = importLoader;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var parser = scope.parser;\n  var importer = scope.importer;\n  var dynamic = {\n    added: function(nodes) {\n      var owner, parsed, loading;\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        if (!owner) {\n          owner = n.ownerDocument;\n          parsed = parser.isParsed(owner);\n        }\n        loading = this.shouldLoadNode(n);\n        if (loading) {\n          importer.loadNode(n);\n        }\n        if (this.shouldParseNode(n) && parsed) {\n          parser.parseDynamic(n, loading);\n        }\n      }\n    },\n    shouldLoadNode: function(node) {\n      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));\n    },\n    shouldParseNode: function(node) {\n      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));\n    }\n  };\n  importer.observer.addCallback = dynamic.added.bind(dynamic);\n  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;\n});\n\n(function(scope) {\n  var initializeModules = scope.initializeModules;\n  var isIE = scope.isIE;\n  if (scope.useNative) {\n    return;\n  }\n  initializeModules();\n  var rootDocument = scope.rootDocument;\n  function bootstrap() {\n    window.HTMLImports.importer.bootDocument(rootDocument);\n  }\n  if (document.readyState === \"complete\" || document.readyState === \"interactive\" && !window.attachEvent) {\n    bootstrap();\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", bootstrap);\n  }\n})(window.HTMLImports);\n\nwindow.CustomElements = window.CustomElements || {\n  flags: {}\n};\n\n(function(scope) {\n  var flags = scope.flags;\n  var modules = [];\n  var addModule = function(module) {\n    modules.push(module);\n  };\n  var initializeModules = function() {\n    modules.forEach(function(module) {\n      module(scope);\n    });\n  };\n  scope.addModule = addModule;\n  scope.initializeModules = initializeModules;\n  scope.hasNative = Boolean(document.registerElement);\n  scope.isIE = /Trident/.test(navigator.userAgent);\n  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);\n})(window.CustomElements);\n\nwindow.CustomElements.addModule(function(scope) {\n  var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : \"none\";\n  function forSubtree(node, cb) {\n    findAllElements(node, function(e) {\n      if (cb(e)) {\n        return true;\n      }\n      forRoots(e, cb);\n    });\n    forRoots(node, cb);\n  }\n  function findAllElements(node, find, data) {\n    var e = node.firstElementChild;\n    if (!e) {\n      e = node.firstChild;\n      while (e && e.nodeType !== Node.ELEMENT_NODE) {\n        e = e.nextSibling;\n      }\n    }\n    while (e) {\n      if (find(e, data) !== true) {\n        findAllElements(e, find, data);\n      }\n      e = e.nextElementSibling;\n    }\n    return null;\n  }\n  function forRoots(node, cb) {\n    var root = node.shadowRoot;\n    while (root) {\n      forSubtree(root, cb);\n      root = root.olderShadowRoot;\n    }\n  }\n  function forDocumentTree(doc, cb) {\n    _forDocumentTree(doc, cb, []);\n  }\n  function _forDocumentTree(doc, cb, processingDocuments) {\n    doc = window.wrap(doc);\n    if (processingDocuments.indexOf(doc) >= 0) {\n      return;\n    }\n    processingDocuments.push(doc);\n    var imports = doc.querySelectorAll(\"link[rel=\" + IMPORT_LINK_TYPE + \"]\");\n    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {\n      if (n.import) {\n        _forDocumentTree(n.import, cb, processingDocuments);\n      }\n    }\n    cb(doc);\n  }\n  scope.forDocumentTree = forDocumentTree;\n  scope.forSubtree = forSubtree;\n});\n\nwindow.CustomElements.addModule(function(scope) {\n  var flags = scope.flags;\n  var forSubtree = scope.forSubtree;\n  var forDocumentTree = scope.forDocumentTree;\n  function addedNode(node, isAttached) {\n    return added(node, isAttached) || addedSubtree(node, isAttached);\n  }\n  function added(node, isAttached) {\n    if (scope.upgrade(node, isAttached)) {\n      return true;\n    }\n    if (isAttached) {\n      attached(node);\n    }\n  }\n  function addedSubtree(node, isAttached) {\n    forSubtree(node, function(e) {\n      if (added(e, isAttached)) {\n        return true;\n      }\n    });\n  }\n  var hasThrottledAttached = window.MutationObserver._isPolyfilled && flags[\"throttle-attached\"];\n  scope.hasPolyfillMutations = hasThrottledAttached;\n  scope.hasThrottledAttached = hasThrottledAttached;\n  var isPendingMutations = false;\n  var pendingMutations = [];\n  function deferMutation(fn) {\n    pendingMutations.push(fn);\n    if (!isPendingMutations) {\n      isPendingMutations = true;\n      setTimeout(takeMutations);\n    }\n  }\n  function takeMutations() {\n    isPendingMutations = false;\n    var $p = pendingMutations;\n    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\n      p();\n    }\n    pendingMutations = [];\n  }\n  function attached(element) {\n    if (hasThrottledAttached) {\n      deferMutation(function() {\n        _attached(element);\n      });\n    } else {\n      _attached(element);\n    }\n  }\n  function _attached(element) {\n    if (element.__upgraded__ && !element.__attached) {\n      element.__attached = true;\n      if (element.attachedCallback) {\n        element.attachedCallback();\n      }\n    }\n  }\n  function detachedNode(node) {\n    detached(node);\n    forSubtree(node, function(e) {\n      detached(e);\n    });\n  }\n  function detached(element) {\n    if (hasThrottledAttached) {\n      deferMutation(function() {\n        _detached(element);\n      });\n    } else {\n      _detached(element);\n    }\n  }\n  function _detached(element) {\n    if (element.__upgraded__ && element.__attached) {\n      element.__attached = false;\n      if (element.detachedCallback) {\n        element.detachedCallback();\n      }\n    }\n  }\n  function inDocument(element) {\n    var p = element;\n    var doc = window.wrap(document);\n    while (p) {\n      if (p == doc) {\n        return true;\n      }\n      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;\n    }\n  }\n  function watchShadow(node) {\n    if (node.shadowRoot && !node.shadowRoot.__watched) {\n      flags.dom && console.log(\"watching shadow-root for: \", node.localName);\n      var root = node.shadowRoot;\n      while (root) {\n        observe(root);\n        root = root.olderShadowRoot;\n      }\n    }\n  }\n  function handler(root, mutations) {\n    if (flags.dom) {\n      var mx = mutations[0];\n      if (mx && mx.type === \"childList\" && mx.addedNodes) {\n        if (mx.addedNodes) {\n          var d = mx.addedNodes[0];\n          while (d && d !== document && !d.host) {\n            d = d.parentNode;\n          }\n          var u = d && (d.URL || d._URL || d.host && d.host.localName) || \"\";\n          u = u.split(\"/?\").shift().split(\"/\").pop();\n        }\n      }\n      console.group(\"mutations (%d) [%s]\", mutations.length, u || \"\");\n    }\n    var isAttached = inDocument(root);\n    mutations.forEach(function(mx) {\n      if (mx.type === \"childList\") {\n        forEach(mx.addedNodes, function(n) {\n          if (!n.localName) {\n            return;\n          }\n          addedNode(n, isAttached);\n        });\n        forEach(mx.removedNodes, function(n) {\n          if (!n.localName) {\n            return;\n          }\n          detachedNode(n);\n        });\n      }\n    });\n    flags.dom && console.groupEnd();\n  }\n  function takeRecords(node) {\n    node = window.wrap(node);\n    if (!node) {\n      node = window.wrap(document);\n    }\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    var observer = node.__observer;\n    if (observer) {\n      handler(node, observer.takeRecords());\n      takeMutations();\n    }\n  }\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n  function observe(inRoot) {\n    if (inRoot.__observer) {\n      return;\n    }\n    var observer = new MutationObserver(handler.bind(this, inRoot));\n    observer.observe(inRoot, {\n      childList: true,\n      subtree: true\n    });\n    inRoot.__observer = observer;\n  }\n  function upgradeDocument(doc) {\n    doc = window.wrap(doc);\n    flags.dom && console.group(\"upgradeDocument: \", doc.baseURI.split(\"/\").pop());\n    var isMainDocument = doc === window.wrap(document);\n    addedNode(doc, isMainDocument);\n    observe(doc);\n    flags.dom && console.groupEnd();\n  }\n  function upgradeDocumentTree(doc) {\n    forDocumentTree(doc, upgradeDocument);\n  }\n  var originalCreateShadowRoot = Element.prototype.createShadowRoot;\n  if (originalCreateShadowRoot) {\n    Element.prototype.createShadowRoot = function() {\n      var root = originalCreateShadowRoot.call(this);\n      window.CustomElements.watchShadow(this);\n      return root;\n    };\n  }\n  scope.watchShadow = watchShadow;\n  scope.upgradeDocumentTree = upgradeDocumentTree;\n  scope.upgradeDocument = upgradeDocument;\n  scope.upgradeSubtree = addedSubtree;\n  scope.upgradeAll = addedNode;\n  scope.attached = attached;\n  scope.takeRecords = takeRecords;\n});\n\nwindow.CustomElements.addModule(function(scope) {\n  var flags = scope.flags;\n  function upgrade(node, isAttached) {\n    if (node.localName === \"template\") {\n      if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(node);\n      }\n    }\n    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {\n      var is = node.getAttribute(\"is\");\n      var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);\n      if (definition) {\n        if (is && definition.tag == node.localName || !is && !definition.extends) {\n          return upgradeWithDefinition(node, definition, isAttached);\n        }\n      }\n    }\n  }\n  function upgradeWithDefinition(element, definition, isAttached) {\n    flags.upgrade && console.group(\"upgrade:\", element.localName);\n    if (definition.is) {\n      element.setAttribute(\"is\", definition.is);\n    }\n    implementPrototype(element, definition);\n    element.__upgraded__ = true;\n    created(element);\n    if (isAttached) {\n      scope.attached(element);\n    }\n    scope.upgradeSubtree(element, isAttached);\n    flags.upgrade && console.groupEnd();\n    return element;\n  }\n  function implementPrototype(element, definition) {\n    if (Object.__proto__) {\n      element.__proto__ = definition.prototype;\n    } else {\n      customMixin(element, definition.prototype, definition.native);\n      element.__proto__ = definition.prototype;\n    }\n  }\n  function customMixin(inTarget, inSrc, inNative) {\n    var used = {};\n    var p = inSrc;\n    while (p !== inNative && p !== HTMLElement.prototype) {\n      var keys = Object.getOwnPropertyNames(p);\n      for (var i = 0, k; k = keys[i]; i++) {\n        if (!used[k]) {\n          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));\n          used[k] = 1;\n        }\n      }\n      p = Object.getPrototypeOf(p);\n    }\n  }\n  function created(element) {\n    if (element.createdCallback) {\n      element.createdCallback();\n    }\n  }\n  scope.upgrade = upgrade;\n  scope.upgradeWithDefinition = upgradeWithDefinition;\n  scope.implementPrototype = implementPrototype;\n});\n\nwindow.CustomElements.addModule(function(scope) {\n  var isIE = scope.isIE;\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\n  var upgradeAll = scope.upgradeAll;\n  var upgradeWithDefinition = scope.upgradeWithDefinition;\n  var implementPrototype = scope.implementPrototype;\n  var useNative = scope.useNative;\n  function register(name, options) {\n    var definition = options || {};\n    if (!name) {\n      throw new Error(\"document.registerElement: first argument `name` must not be empty\");\n    }\n    if (name.indexOf(\"-\") < 0) {\n      throw new Error(\"document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '\" + String(name) + \"'.\");\n    }\n    if (isReservedTag(name)) {\n      throw new Error(\"Failed to execute 'registerElement' on 'Document': Registration failed for type '\" + String(name) + \"'. The type name is invalid.\");\n    }\n    if (getRegisteredDefinition(name)) {\n      throw new Error(\"DuplicateDefinitionError: a type with name '\" + String(name) + \"' is already registered\");\n    }\n    if (!definition.prototype) {\n      definition.prototype = Object.create(HTMLElement.prototype);\n    }\n    definition.__name = name.toLowerCase();\n    definition.lifecycle = definition.lifecycle || {};\n    definition.ancestry = ancestry(definition.extends);\n    resolveTagName(definition);\n    resolvePrototypeChain(definition);\n    overrideAttributeApi(definition.prototype);\n    registerDefinition(definition.__name, definition);\n    definition.ctor = generateConstructor(definition);\n    definition.ctor.prototype = definition.prototype;\n    definition.prototype.constructor = definition.ctor;\n    if (scope.ready) {\n      upgradeDocumentTree(document);\n    }\n    return definition.ctor;\n  }\n  function overrideAttributeApi(prototype) {\n    if (prototype.setAttribute._polyfilled) {\n      return;\n    }\n    var setAttribute = prototype.setAttribute;\n    prototype.setAttribute = function(name, value) {\n      changeAttribute.call(this, name, value, setAttribute);\n    };\n    var removeAttribute = prototype.removeAttribute;\n    prototype.removeAttribute = function(name) {\n      changeAttribute.call(this, name, null, removeAttribute);\n    };\n    prototype.setAttribute._polyfilled = true;\n  }\n  function changeAttribute(name, value, operation) {\n    name = name.toLowerCase();\n    var oldValue = this.getAttribute(name);\n    operation.apply(this, arguments);\n    var newValue = this.getAttribute(name);\n    if (this.attributeChangedCallback && newValue !== oldValue) {\n      this.attributeChangedCallback(name, oldValue, newValue);\n    }\n  }\n  function isReservedTag(name) {\n    for (var i = 0; i < reservedTagList.length; i++) {\n      if (name === reservedTagList[i]) {\n        return true;\n      }\n    }\n  }\n  var reservedTagList = [ \"annotation-xml\", \"color-profile\", \"font-face\", \"font-face-src\", \"font-face-uri\", \"font-face-format\", \"font-face-name\", \"missing-glyph\" ];\n  function ancestry(extnds) {\n    var extendee = getRegisteredDefinition(extnds);\n    if (extendee) {\n      return ancestry(extendee.extends).concat([ extendee ]);\n    }\n    return [];\n  }\n  function resolveTagName(definition) {\n    var baseTag = definition.extends;\n    for (var i = 0, a; a = definition.ancestry[i]; i++) {\n      baseTag = a.is && a.tag;\n    }\n    definition.tag = baseTag || definition.__name;\n    if (baseTag) {\n      definition.is = definition.__name;\n    }\n  }\n  function resolvePrototypeChain(definition) {\n    if (!Object.__proto__) {\n      var nativePrototype = HTMLElement.prototype;\n      if (definition.is) {\n        var inst = document.createElement(definition.tag);\n        nativePrototype = Object.getPrototypeOf(inst);\n      }\n      var proto = definition.prototype, ancestor;\n      var foundPrototype = false;\n      while (proto) {\n        if (proto == nativePrototype) {\n          foundPrototype = true;\n        }\n        ancestor = Object.getPrototypeOf(proto);\n        if (ancestor) {\n          proto.__proto__ = ancestor;\n        }\n        proto = ancestor;\n      }\n      if (!foundPrototype) {\n        console.warn(definition.tag + \" prototype not found in prototype chain for \" + definition.is);\n      }\n      definition.native = nativePrototype;\n    }\n  }\n  function instantiate(definition) {\n    return upgradeWithDefinition(domCreateElement(definition.tag), definition);\n  }\n  var registry = {};\n  function getRegisteredDefinition(name) {\n    if (name) {\n      return registry[name.toLowerCase()];\n    }\n  }\n  function registerDefinition(name, definition) {\n    registry[name] = definition;\n  }\n  function generateConstructor(definition) {\n    return function() {\n      return instantiate(definition);\n    };\n  }\n  var HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n  function createElementNS(namespace, tag, typeExtension) {\n    if (namespace === HTML_NAMESPACE) {\n      return createElement(tag, typeExtension);\n    } else {\n      return domCreateElementNS(namespace, tag);\n    }\n  }\n  function createElement(tag, typeExtension) {\n    if (tag) {\n      tag = tag.toLowerCase();\n    }\n    if (typeExtension) {\n      typeExtension = typeExtension.toLowerCase();\n    }\n    var definition = getRegisteredDefinition(typeExtension || tag);\n    if (definition) {\n      if (tag == definition.tag && typeExtension == definition.is) {\n        return new definition.ctor();\n      }\n      if (!typeExtension && !definition.is) {\n        return new definition.ctor();\n      }\n    }\n    var element;\n    if (typeExtension) {\n      element = createElement(tag);\n      element.setAttribute(\"is\", typeExtension);\n      return element;\n    }\n    element = domCreateElement(tag);\n    if (tag.indexOf(\"-\") >= 0) {\n      implementPrototype(element, HTMLElement);\n    }\n    return element;\n  }\n  var domCreateElement = document.createElement.bind(document);\n  var domCreateElementNS = document.createElementNS.bind(document);\n  var isInstance;\n  if (!Object.__proto__ && !useNative) {\n    isInstance = function(obj, ctor) {\n      if (obj instanceof ctor) {\n        return true;\n      }\n      var p = obj;\n      while (p) {\n        if (p === ctor.prototype) {\n          return true;\n        }\n        p = p.__proto__;\n      }\n      return false;\n    };\n  } else {\n    isInstance = function(obj, base) {\n      return obj instanceof base;\n    };\n  }\n  function wrapDomMethodToForceUpgrade(obj, methodName) {\n    var orig = obj[methodName];\n    obj[methodName] = function() {\n      var n = orig.apply(this, arguments);\n      upgradeAll(n);\n      return n;\n    };\n  }\n  wrapDomMethodToForceUpgrade(Node.prototype, \"cloneNode\");\n  wrapDomMethodToForceUpgrade(document, \"importNode\");\n  if (isIE) {\n    (function() {\n      var importNode = document.importNode;\n      document.importNode = function() {\n        var n = importNode.apply(document, arguments);\n        if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {\n          var f = document.createDocumentFragment();\n          f.appendChild(n);\n          return f;\n        } else {\n          return n;\n        }\n      };\n    })();\n  }\n  document.registerElement = register;\n  document.createElement = createElement;\n  document.createElementNS = createElementNS;\n  scope.registry = registry;\n  scope.instanceof = isInstance;\n  scope.reservedTagList = reservedTagList;\n  scope.getRegisteredDefinition = getRegisteredDefinition;\n  document.register = document.registerElement;\n});\n\n(function(scope) {\n  var useNative = scope.useNative;\n  var initializeModules = scope.initializeModules;\n  var isIE = scope.isIE;\n  if (useNative) {\n    var nop = function() {};\n    scope.watchShadow = nop;\n    scope.upgrade = nop;\n    scope.upgradeAll = nop;\n    scope.upgradeDocumentTree = nop;\n    scope.upgradeSubtree = nop;\n    scope.takeRecords = nop;\n    scope.instanceof = function(obj, base) {\n      return obj instanceof base;\n    };\n  } else {\n    initializeModules();\n  }\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\n  var upgradeDocument = scope.upgradeDocument;\n  if (!window.wrap) {\n    if (window.ShadowDOMPolyfill) {\n      window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;\n      window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;\n    } else {\n      window.wrap = window.unwrap = function(node) {\n        return node;\n      };\n    }\n  }\n  if (window.HTMLImports) {\n    window.HTMLImports.__importsParsingHook = function(elt) {\n      if (elt.import) {\n        upgradeDocument(wrap(elt.import));\n      }\n    };\n  }\n  function bootstrap() {\n    upgradeDocumentTree(window.wrap(document));\n    window.CustomElements.ready = true;\n    var requestAnimationFrame = window.requestAnimationFrame || function(f) {\n      setTimeout(f, 16);\n    };\n    requestAnimationFrame(function() {\n      setTimeout(function() {\n        window.CustomElements.readyTime = Date.now();\n        if (window.HTMLImports) {\n          window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;\n        }\n        document.dispatchEvent(new CustomEvent(\"WebComponentsReady\", {\n          bubbles: true\n        }));\n      });\n    });\n  }\n  if (document.readyState === \"complete\" || scope.flags.eager) {\n    bootstrap();\n  } else if (document.readyState === \"interactive\" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {\n    bootstrap();\n  } else {\n    var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? \"HTMLImportsLoaded\" : \"DOMContentLoaded\";\n    window.addEventListener(loadEvent, bootstrap);\n  }\n})(window.CustomElements);\n\n(function(scope) {\n  if (!Function.prototype.bind) {\n    Function.prototype.bind = function(scope) {\n      var self = this;\n      var args = Array.prototype.slice.call(arguments, 1);\n      return function() {\n        var args2 = args.slice();\n        args2.push.apply(args2, arguments);\n        return self.apply(scope, args2);\n      };\n    };\n  }\n})(window.WebComponents);\n\n(function(scope) {\n  var style = document.createElement(\"style\");\n  style.textContent = \"\" + \"body {\" + \"transition: opacity ease-in 0.2s;\" + \" } \\n\" + \"body[unresolved] {\" + \"opacity: 0; display: block; overflow: hidden; position: relative;\" + \" } \\n\";\n  var head = document.querySelector(\"head\");\n  head.insertBefore(style, head.firstChild);\n})(window.WebComponents);\n\n(function(scope) {\n  window.Platform = scope;\n})(window.WebComponents);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/webcomponents.js/webcomponents.js\n ** module id = 0\n ** module chunks = 1\n **/"],"sourceRoot":""}